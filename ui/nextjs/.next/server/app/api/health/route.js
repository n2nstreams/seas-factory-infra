/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/health/route";
exports.ids = ["app/api/health/route"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fhealth%2Froute&page=%2Fapi%2Fhealth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fhealth%2Froute.ts&appDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!":
/*!***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fhealth%2Froute&page=%2Fapi%2Fhealth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fhealth%2Froute.ts&appDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=! ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   handler: () => (/* binding */ handler),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dist/server/request-meta */ \"(rsc)/./node_modules/next/dist/server/request-meta.js\");\n/* harmony import */ var next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/dist/server/lib/trace/tracer */ \"(rsc)/./node_modules/next/dist/server/lib/trace/tracer.js\");\n/* harmony import */ var next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/dist/shared/lib/router/utils/app-paths */ \"next/dist/shared/lib/router/utils/app-paths\");\n/* harmony import */ var next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/dist/server/base-http/node */ \"(rsc)/./node_modules/next/dist/server/base-http/node.js\");\n/* harmony import */ var next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! next/dist/server/web/spec-extension/adapters/next-request */ \"(rsc)/./node_modules/next/dist/server/web/spec-extension/adapters/next-request.js\");\n/* harmony import */ var next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! next/dist/server/lib/trace/constants */ \"(rsc)/./node_modules/next/dist/server/lib/trace/constants.js\");\n/* harmony import */ var next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/dist/server/instrumentation/utils */ \"(rsc)/./node_modules/next/dist/server/instrumentation/utils.js\");\n/* harmony import */ var next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/dist/server/send-response */ \"(rsc)/./node_modules/next/dist/server/send-response.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/dist/server/web/utils */ \"(rsc)/./node_modules/next/dist/server/web/utils.js\");\n/* harmony import */ var next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! next/dist/server/lib/cache-control */ \"(rsc)/./node_modules/next/dist/server/lib/cache-control.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! next/dist/lib/constants */ \"(rsc)/./node_modules/next/dist/lib/constants.js\");\n/* harmony import */ var next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! next/dist/shared/lib/no-fallback-error.external */ \"next/dist/shared/lib/no-fallback-error.external\");\n/* harmony import */ var next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! next/dist/server/response-cache */ \"(rsc)/./node_modules/next/dist/server/response-cache/index.js\");\n/* harmony import */ var next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _Users_macmini_Documents_Projects_SaaS_Factory_ui_nextjs_src_app_api_health_route_ts__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/app/api/health/route.ts */ \"(rsc)/./src/app/api/health/route.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/health/route\",\n        pathname: \"/api/health\",\n        filename: \"route\",\n        bundlePath: \"app/api/health/route\"\n    },\n    distDir: \".next\" || 0,\n    relativeProjectDir:  false || '',\n    resolvedPagePath: \"/Users/macmini/Documents/Projects/SaaS Factory/ui/nextjs/src/app/api/health/route.ts\",\n    nextConfigOutput,\n    userland: _Users_macmini_Documents_Projects_SaaS_Factory_ui_nextjs_src_app_api_health_route_ts__WEBPACK_IMPORTED_MODULE_16__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\nasync function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/health/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (false) {} else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = false;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = (0,next_dist_shared_lib_router_utils_app_paths__WEBPACK_IMPORTED_MODULE_5__.normalizeAppPath)(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = (0,next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.getTracer)();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: (0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextRequest(req);\n    const nodeNextRes = new next_dist_server_base_http_node__WEBPACK_IMPORTED_MODULE_6__.NodeNextResponse(res);\n    const nextReq = next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.NextRequestAdapter.fromNodeNextRequest(nodeNextReq, (0,next_dist_server_web_spec_extension_adapters_next_request__WEBPACK_IMPORTED_MODULE_7__.signalFromNodeResponse)(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.toNodeOutgoingHttpHeaders)(response.headers);\n                        if (cacheTags) {\n                            headers[next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== next_dist_server_response_cache__WEBPACK_IMPORTED_MODULE_15__.CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!(0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = (0,next_dist_server_web_utils__WEBPACK_IMPORTED_MODULE_11__.fromNodeOutgoingHttpHeaders)(cacheEntry.value.headers);\n            if (!((0,next_dist_server_request_meta__WEBPACK_IMPORTED_MODULE_3__.getRequestMeta)(req, 'minimalMode') && isIsr)) {\n                headers.delete(next_dist_lib_constants__WEBPACK_IMPORTED_MODULE_13__.NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', (0,next_dist_server_lib_cache_control__WEBPACK_IMPORTED_MODULE_12__.getCacheControlHeader)(cacheEntry.cacheControl));\n            }\n            await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(next_dist_server_lib_trace_constants__WEBPACK_IMPORTED_MODULE_8__.BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: next_dist_server_lib_trace_tracer__WEBPACK_IMPORTED_MODULE_4__.SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof next_dist_shared_lib_no_fallback_error_external__WEBPACK_IMPORTED_MODULE_14__.NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: (0,next_dist_server_instrumentation_utils__WEBPACK_IMPORTED_MODULE_9__.getRevalidateReason)({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await (0,next_dist_server_send_response__WEBPACK_IMPORTED_MODULE_10__.sendResponse)(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZoZWFsdGglMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRmhlYWx0aCUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRmhlYWx0aCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRm1hY21pbmklMkZEb2N1bWVudHMlMkZQcm9qZWN0cyUyRlNhYVMlMjBGYWN0b3J5JTJGdWklMkZuZXh0anMlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRlVzZXJzJTJGbWFjbWluaSUyRkRvY3VtZW50cyUyRlByb2plY3RzJTJGU2FhUyUyMEZhY3RvcnklMkZ1aSUyRm5leHRqcyZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCZpc0dsb2JhbE5vdEZvdW5kRW5hYmxlZD0hIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQ2Q7QUFDUztBQUNPO0FBQ0s7QUFDbUM7QUFDakQ7QUFDTztBQUNmO0FBQ3NDO0FBQ3pCO0FBQ007QUFDQztBQUNoQjtBQUMrQztBQUNqSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhLE9BQW9DLElBQUksQ0FBRTtBQUN2RCx3QkFBd0IsTUFBdUM7QUFDL0Q7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBc0Q7QUFDOUQ7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDMEY7QUFDbkY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQixFQUFFLEVBRTFCLENBQUM7QUFDTjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBd0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0pBQW9KO0FBQ2hLLDhCQUE4Qiw2RkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZGQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRFQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw4QkFBOEIsNkVBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRFQUFlO0FBQzNDLDRCQUE0Qiw2RUFBZ0I7QUFDNUMsb0JBQW9CLHlHQUFrQixrQ0FBa0MsaUhBQXNCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0ZBQWM7QUFDL0UsK0RBQStELHlDQUF5QztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLEVBQUUsTUFBTTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGtCQUFrQjtBQUNsQix1Q0FBdUMsUUFBUSxFQUFFLFFBQVE7QUFDekQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQjtBQUNuRTtBQUNBLHlCQUF5Qiw2RUFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNGQUF5QjtBQUNqRTtBQUNBLG9DQUFvQyw0RUFBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSkFBc0osb0VBQWM7QUFDcEssMElBQTBJLG9FQUFjO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsOEJBQThCLDZFQUFZO0FBQzFDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkZBQW1CO0FBQ2pFO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0VBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSUFBcUksNkVBQWU7QUFDcEo7QUFDQSwyR0FBMkcsaUhBQWlIO0FBQzVOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQiw2RUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0ZBQTJCO0FBQ3ZELGtCQUFrQiw2RUFBYztBQUNoQywrQkFBK0IsNEVBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBGQUFxQjtBQUNsRTtBQUNBLGtCQUFrQiw2RUFBWTtBQUM5QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2RUFBNkUsZ0ZBQWM7QUFDM0YsaUNBQWlDLFFBQVEsRUFBRSxRQUFRO0FBQ25ELDBCQUEwQix1RUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU07QUFDTjtBQUNBLDRDQUE0Qyw2RkFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyRkFBbUI7QUFDckQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkVBQVk7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0IHsgZ2V0UmVxdWVzdE1ldGEgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yZXF1ZXN0LW1ldGFcIjtcbmltcG9ydCB7IGdldFRyYWNlciwgU3BhbktpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvdHJhY2UvdHJhY2VyXCI7XG5pbXBvcnQgeyBub3JtYWxpemVBcHBQYXRoIH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hcHAtcGF0aHNcIjtcbmltcG9ydCB7IE5vZGVOZXh0UmVxdWVzdCwgTm9kZU5leHRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Jhc2UtaHR0cC9ub2RlXCI7XG5pbXBvcnQgeyBOZXh0UmVxdWVzdEFkYXB0ZXIsIHNpZ25hbEZyb21Ob2RlUmVzcG9uc2UgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci93ZWIvc3BlYy1leHRlbnNpb24vYWRhcHRlcnMvbmV4dC1yZXF1ZXN0XCI7XG5pbXBvcnQgeyBCYXNlU2VydmVyU3BhbiB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi90cmFjZS9jb25zdGFudHNcIjtcbmltcG9ydCB7IGdldFJldmFsaWRhdGVSZWFzb24gfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9pbnN0cnVtZW50YXRpb24vdXRpbHNcIjtcbmltcG9ydCB7IHNlbmRSZXNwb25zZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3NlbmQtcmVzcG9uc2VcIjtcbmltcG9ydCB7IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycywgdG9Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3dlYi91dGlsc1wiO1xuaW1wb3J0IHsgZ2V0Q2FjaGVDb250cm9sSGVhZGVyIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL2NhY2hlLWNvbnRyb2xcIjtcbmltcG9ydCB7IElORklOSVRFX0NBQ0hFLCBORVhUX0NBQ0hFX1RBR1NfSEVBREVSIH0gZnJvbSBcIm5leHQvZGlzdC9saWIvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBOb0ZhbGxiYWNrRXJyb3IgfSBmcm9tIFwibmV4dC9kaXN0L3NoYXJlZC9saWIvbm8tZmFsbGJhY2stZXJyb3IuZXh0ZXJuYWxcIjtcbmltcG9ydCB7IENhY2hlZFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3Jlc3BvbnNlLWNhY2hlXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2FwcC9hcGkvaGVhbHRoL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcIlwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9oZWFsdGgvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9oZWFsdGhcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL2hlYWx0aC9yb3V0ZVwiXG4gICAgfSxcbiAgICBkaXN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfRElTVF9ESVIgfHwgJycsXG4gICAgcmVsYXRpdmVQcm9qZWN0RGlyOiBwcm9jZXNzLmVudi5fX05FWFRfUkVMQVRJVkVfUFJPSkVDVF9ESVIgfHwgJycsXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvYXBwL2FwaS9oZWFsdGgvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICB3b3JrQXN5bmNTdG9yYWdlLFxuICAgICAgICB3b3JrVW5pdEFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHdvcmtBc3luY1N0b3JhZ2UsIHdvcmtVbml0QXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgcGF0Y2hGZXRjaCwgIH07XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcywgY3R4KSB7XG4gICAgdmFyIF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbDtcbiAgICBsZXQgc3JjUGFnZSA9IFwiL2FwaS9oZWFsdGgvcm91dGVcIjtcbiAgICAvLyB0dXJib3BhY2sgZG9lc24ndCBub3JtYWxpemUgYC9pbmRleGAgaW4gdGhlIHBhZ2UgbmFtZVxuICAgIC8vIHNvIHdlIG5lZWQgdG8gdG8gcHJvY2VzcyBkeW5hbWljIHJvdXRlcyBwcm9wZXJseVxuICAgIC8vIFRPRE86IGZpeCB0dXJib3BhY2sgcHJvdmlkaW5nIGRpZmZlcmluZyB2YWx1ZSBmcm9tIHdlYnBhY2tcbiAgICBpZiAocHJvY2Vzcy5lbnYuVFVSQk9QQUNLKSB7XG4gICAgICAgIHNyY1BhZ2UgPSBzcmNQYWdlLnJlcGxhY2UoL1xcL2luZGV4JC8sICcnKSB8fCAnLyc7XG4gICAgfSBlbHNlIGlmIChzcmNQYWdlID09PSAnL2luZGV4Jykge1xuICAgICAgICAvLyB3ZSBhbHdheXMgbm9ybWFsaXplIC9pbmRleCBzcGVjaWZpY2FsbHlcbiAgICAgICAgc3JjUGFnZSA9ICcvJztcbiAgICB9XG4gICAgY29uc3QgbXVsdGlab25lRHJhZnRNb2RlID0gcHJvY2Vzcy5lbnYuX19ORVhUX01VTFRJX1pPTkVfRFJBRlRfTU9ERTtcbiAgICBjb25zdCBwcmVwYXJlUmVzdWx0ID0gYXdhaXQgcm91dGVNb2R1bGUucHJlcGFyZShyZXEsIHJlcywge1xuICAgICAgICBzcmNQYWdlLFxuICAgICAgICBtdWx0aVpvbmVEcmFmdE1vZGVcbiAgICB9KTtcbiAgICBpZiAoIXByZXBhcmVSZXN1bHQpIHtcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDA7XG4gICAgICAgIHJlcy5lbmQoJ0JhZCBSZXF1ZXN0Jyk7XG4gICAgICAgIGN0eC53YWl0VW50aWwgPT0gbnVsbCA/IHZvaWQgMCA6IGN0eC53YWl0VW50aWwuY2FsbChjdHgsIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgcGFyYW1zLCBuZXh0Q29uZmlnLCBpc0RyYWZ0TW9kZSwgcHJlcmVuZGVyTWFuaWZlc3QsIHJvdXRlclNlcnZlckNvbnRleHQsIGlzT25EZW1hbmRSZXZhbGlkYXRlLCByZXZhbGlkYXRlT25seUdlbmVyYXRlZCwgcmVzb2x2ZWRQYXRobmFtZSB9ID0gcHJlcGFyZVJlc3VsdDtcbiAgICBjb25zdCBub3JtYWxpemVkU3JjUGFnZSA9IG5vcm1hbGl6ZUFwcFBhdGgoc3JjUGFnZSk7XG4gICAgbGV0IGlzSXNyID0gQm9vbGVhbihwcmVyZW5kZXJNYW5pZmVzdC5keW5hbWljUm91dGVzW25vcm1hbGl6ZWRTcmNQYWdlXSB8fCBwcmVyZW5kZXJNYW5pZmVzdC5yb3V0ZXNbcmVzb2x2ZWRQYXRobmFtZV0pO1xuICAgIGlmIChpc0lzciAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY29uc3QgaXNQcmVyZW5kZXJlZCA9IEJvb2xlYW4ocHJlcmVuZGVyTWFuaWZlc3Qucm91dGVzW3Jlc29sdmVkUGF0aG5hbWVdKTtcbiAgICAgICAgY29uc3QgcHJlcmVuZGVySW5mbyA9IHByZXJlbmRlck1hbmlmZXN0LmR5bmFtaWNSb3V0ZXNbbm9ybWFsaXplZFNyY1BhZ2VdO1xuICAgICAgICBpZiAocHJlcmVuZGVySW5mbykge1xuICAgICAgICAgICAgaWYgKHByZXJlbmRlckluZm8uZmFsbGJhY2sgPT09IGZhbHNlICYmICFpc1ByZXJlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vRmFsbGJhY2tFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjYWNoZUtleSA9IG51bGw7XG4gICAgaWYgKGlzSXNyICYmICFyb3V0ZU1vZHVsZS5pc0RldiAmJiAhaXNEcmFmdE1vZGUpIHtcbiAgICAgICAgY2FjaGVLZXkgPSByZXNvbHZlZFBhdGhuYW1lO1xuICAgICAgICAvLyBlbnN1cmUgL2luZGV4IGFuZCAvIGlzIG5vcm1hbGl6ZWQgdG8gb25lIGtleVxuICAgICAgICBjYWNoZUtleSA9IGNhY2hlS2V5ID09PSAnL2luZGV4JyA/ICcvJyA6IGNhY2hlS2V5O1xuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0R5bmFtaWNSZXNwb25zZSA9IC8vIElmIHdlJ3JlIGluIGRldmVsb3BtZW50LCB3ZSBhbHdheXMgc3VwcG9ydCBkeW5hbWljIEhUTUxcbiAgICByb3V0ZU1vZHVsZS5pc0RldiA9PT0gdHJ1ZSB8fCAvLyBJZiB0aGlzIGlzIG5vdCBTU0cgb3IgZG9lcyBub3QgaGF2ZSBzdGF0aWMgcGF0aHMsIHRoZW4gaXQgc3VwcG9ydHNcbiAgICAvLyBkeW5hbWljIEhUTUwuXG4gICAgIWlzSXNyO1xuICAgIC8vIFRoaXMgaXMgYSByZXZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgcmVxdWVzdCBpcyBmb3IgYSBzdGF0aWNcbiAgICAvLyBwYWdlIGFuZCBpdCBpcyBub3QgYmVpbmcgcmVzdW1lZCBmcm9tIGEgcG9zdHBvbmVkIHJlbmRlciBhbmRcbiAgICAvLyBpdCBpcyBub3QgYSBkeW5hbWljIFJTQyByZXF1ZXN0IHRoZW4gaXQgaXMgYSByZXZhbGlkYXRpb25cbiAgICAvLyByZXF1ZXN0LlxuICAgIGNvbnN0IGlzUmV2YWxpZGF0ZSA9IGlzSXNyICYmICFzdXBwb3J0c0R5bmFtaWNSZXNwb25zZTtcbiAgICBjb25zdCBtZXRob2QgPSByZXEubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSB0cmFjZXIuZ2V0QWN0aXZlU2NvcGVTcGFuKCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBwcmVyZW5kZXJNYW5pZmVzdCxcbiAgICAgICAgcmVuZGVyT3B0czoge1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiB7XG4gICAgICAgICAgICAgICAgY2FjaGVDb21wb25lbnRzOiBCb29sZWFuKG5leHRDb25maWcuZXhwZXJpbWVudGFsLmNhY2hlQ29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgYXV0aEludGVycnVwdHM6IEJvb2xlYW4obmV4dENvbmZpZy5leHBlcmltZW50YWwuYXV0aEludGVycnVwdHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3VwcG9ydHNEeW5hbWljUmVzcG9uc2UsXG4gICAgICAgICAgICBpbmNyZW1lbnRhbENhY2hlOiBnZXRSZXF1ZXN0TWV0YShyZXEsICdpbmNyZW1lbnRhbENhY2hlJyksXG4gICAgICAgICAgICBjYWNoZUxpZmVQcm9maWxlczogKF9uZXh0Q29uZmlnX2V4cGVyaW1lbnRhbCA9IG5leHRDb25maWcuZXhwZXJpbWVudGFsKSA9PSBudWxsID8gdm9pZCAwIDogX25leHRDb25maWdfZXhwZXJpbWVudGFsLmNhY2hlTGlmZSxcbiAgICAgICAgICAgIGlzUmV2YWxpZGF0ZSxcbiAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbCxcbiAgICAgICAgICAgIG9uQ2xvc2U6IChjYik9PntcbiAgICAgICAgICAgICAgICByZXMub24oJ2Nsb3NlJywgY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQWZ0ZXJUYXNrRXJyb3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9uSW5zdHJ1bWVudGF0aW9uUmVxdWVzdEVycm9yOiAoZXJyb3IsIF9yZXF1ZXN0LCBlcnJvckNvbnRleHQpPT5yb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVycm9yLCBlcnJvckNvbnRleHQsIHJvdXRlclNlcnZlckNvbnRleHQpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZENvbnRleHQ6IHtcbiAgICAgICAgICAgIGJ1aWxkSWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9kZU5leHRSZXEgPSBuZXcgTm9kZU5leHRSZXF1ZXN0KHJlcSk7XG4gICAgY29uc3Qgbm9kZU5leHRSZXMgPSBuZXcgTm9kZU5leHRSZXNwb25zZShyZXMpO1xuICAgIGNvbnN0IG5leHRSZXEgPSBOZXh0UmVxdWVzdEFkYXB0ZXIuZnJvbU5vZGVOZXh0UmVxdWVzdChub2RlTmV4dFJlcSwgc2lnbmFsRnJvbU5vZGVSZXNwb25zZShyZXMpKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnZva2VSb3V0ZU1vZHVsZSA9IGFzeW5jIChzcGFuKT0+e1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlTW9kdWxlLmhhbmRsZShuZXh0UmVxLCBjb250ZXh0KS5maW5hbGx5KCgpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFzcGFuKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgJ2h0dHAuc3RhdHVzX2NvZGUnOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgJ25leHQucnNjJzogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByb290U3BhbkF0dHJpYnV0ZXMgPSB0cmFjZXIuZ2V0Um9vdFNwYW5BdHRyaWJ1dGVzKCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugd2VyZSB1bmFibGUgdG8gZ2V0IGF0dHJpYnV0ZXMsIHByb2JhYmx5IE9URUwgaXMgbm90IGVuYWJsZWRcbiAgICAgICAgICAgICAgICBpZiAoIXJvb3RTcGFuQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpICE9PSBCYXNlU2VydmVyU3Bhbi5oYW5kbGVSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5leHBlY3RlZCByb290IHNwYW4gdHlwZSAnJHtyb290U3BhbkF0dHJpYnV0ZXMuZ2V0KCduZXh0LnNwYW5fdHlwZScpfScuIFBsZWFzZSByZXBvcnQgdGhpcyBOZXh0LmpzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qc2ApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gcm9vdFNwYW5BdHRyaWJ1dGVzLmdldCgnbmV4dC5yb3V0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7bWV0aG9kfSAke3JvdXRlfWA7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAnbmV4dC5yb3V0ZSc6IHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHAucm91dGUnOiByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXh0LnNwYW5fbmFtZSc6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4udXBkYXRlTmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnVwZGF0ZU5hbWUoYCR7bWV0aG9kfSAke3JlcS51cmx9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gYXN5bmMgKGN1cnJlbnRTcGFuKT0+e1xuICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VHZW5lcmF0b3IgPSBhc3luYyAoeyBwcmV2aW91c0NhY2hlRW50cnkgfSk9PntcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWdldFJlcXVlc3RNZXRhKHJlcSwgJ21pbmltYWxNb2RlJykgJiYgaXNPbkRlbWFuZFJldmFsaWRhdGUgJiYgcmV2YWxpZGF0ZU9ubHlHZW5lcmF0ZWQgJiYgIXByZXZpb3VzQ2FjaGVFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbi1kZW1hbmQgcmV2YWxpZGF0ZSBhbHdheXMgc2V0cyB0aGlzIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCAnUkVWQUxJREFURUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaW52b2tlUm91dGVNb2R1bGUoY3VycmVudFNwYW4pO1xuICAgICAgICAgICAgICAgICAgICByZXEuZmV0Y2hNZXRyaWNzID0gY29udGV4dC5yZW5kZXJPcHRzLmZldGNoTWV0cmljcztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBlbmRpbmdXYWl0VW50aWwgPSBjb250ZXh0LnJlbmRlck9wdHMucGVuZGluZ1dhaXRVbnRpbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB1c2luZyBwcm92aWRlZCB3YWl0VW50aWwgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IHdlIGZhbGxiYWNrIHRvIHNlbmRSZXNwb25zZSdzIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nV2FpdFVudGlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3R4LndhaXRVbnRpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC53YWl0VW50aWwocGVuZGluZ1dhaXRVbnRpbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1dhaXRVbnRpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZVRhZ3MgPSBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkVGFncztcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXMgZm9yIGEgc3RhdGljIHJlc3BvbnNlLCB3ZSBjYW4gY2FjaGUgaXQgc28gbG9uZ1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIG5vdCBlZGdlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJc3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBoZWFkZXJzIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRvTm9kZU91dGdvaW5nSHR0cEhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tORVhUX0NBQ0hFX1RBR1NfSEVBREVSXSA9IGNhY2hlVGFncztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGVhZGVyc1snY29udGVudC10eXBlJ10gJiYgYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBibG9iLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gdHlwZW9mIGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRSZXZhbGlkYXRlID09PSAndW5kZWZpbmVkJyB8fCBjb250ZXh0LnJlbmRlck9wdHMuY29sbGVjdGVkUmV2YWxpZGF0ZSA+PSBJTkZJTklURV9DQUNIRSA/IGZhbHNlIDogY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZFJldmFsaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmUgPSB0eXBlb2YgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29udGV4dC5yZW5kZXJPcHRzLmNvbGxlY3RlZEV4cGlyZSA+PSBJTkZJTklURV9DQUNIRSA/IHVuZGVmaW5lZCA6IGNvbnRleHQucmVuZGVyT3B0cy5jb2xsZWN0ZWRFeHBpcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGNhY2hlIGVudHJ5IGZvciB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IENhY2hlZFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuZnJvbShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUNvbnRyb2w6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2YWxpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZUVudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VuZCByZXNwb25zZSB3aXRob3V0IGNhY2hpbmcgaWYgbm90IElTUlxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2VuZFJlc3BvbnNlKG5vZGVOZXh0UmVxLCBub2RlTmV4dFJlcywgcmVzcG9uc2UsIGNvbnRleHQucmVuZGVyT3B0cy5wZW5kaW5nV2FpdFVudGlsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBiYWNrZ3JvdW5kIHJldmFsaWRhdGUgd2UgbmVlZCB0byByZXBvcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJlcXVlc3QgZXJyb3IgaGVyZSBhcyBpdCB3b24ndCBiZSBidWJibGVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlRW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZpb3VzQ2FjaGVFbnRyeS5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZU1vZHVsZS5vblJlcXVlc3RFcnJvcihyZXEsIGVyciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcktpbmQ6ICdBcHAgUm91dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVBhdGg6IHNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlclNlcnZlckNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY2FjaGVFbnRyeSA9IGF3YWl0IHJvdXRlTW9kdWxlLmhhbmRsZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICByb3V0ZUtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJlcmVuZGVyTWFuaWZlc3QsXG4gICAgICAgICAgICAgICAgaXNSb3V0ZVBQUkVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVPbmx5R2VuZXJhdGVkLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlR2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIHdhaXRVbnRpbDogY3R4LndhaXRVbnRpbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjcmVhdGUgYSBjYWNoZUVudHJ5IGZvciBJU1JcbiAgICAgICAgICAgIGlmICghaXNJc3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlID0gY2FjaGVFbnRyeS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWNoZUVudHJ5X3ZhbHVlLmtpbmQpICE9PSBDYWNoZWRSb3V0ZUtpbmQuQVBQX1JPVVRFKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jYWNoZUVudHJ5X3ZhbHVlMTtcbiAgICAgICAgICAgICAgICB0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3IEVycm9yKGBJbnZhcmlhbnQ6IGFwcC1yb3V0ZSByZWNlaXZlZCBpbnZhbGlkIGNhY2hlIGVudHJ5ICR7Y2FjaGVFbnRyeSA9PSBudWxsID8gdm9pZCAwIDogKF9jYWNoZUVudHJ5X3ZhbHVlMSA9IGNhY2hlRW50cnkudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBfY2FjaGVFbnRyeV92YWx1ZTEua2luZH1gKSwgXCJfX05FWFRfRVJST1JfQ09ERVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIkU3MDFcIixcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnZXRSZXF1ZXN0TWV0YShyZXEsICdtaW5pbWFsTW9kZScpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcigneC1uZXh0anMtY2FjaGUnLCBpc09uRGVtYW5kUmV2YWxpZGF0ZSA/ICdSRVZBTElEQVRFRCcgOiBjYWNoZUVudHJ5LmlzTWlzcyA/ICdNSVNTJyA6IGNhY2hlRW50cnkuaXNTdGFsZSA/ICdTVEFMRScgOiAnSElUJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlIHNob3VsZCBuZXZlciBiZSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChpc0RyYWZ0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnLCAncHJpdmF0ZSwgbm8tY2FjaGUsIG5vLXN0b3JlLCBtYXgtYWdlPTAsIG11c3QtcmV2YWxpZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IGZyb21Ob2RlT3V0Z29pbmdIdHRwSGVhZGVycyhjYWNoZUVudHJ5LnZhbHVlLmhlYWRlcnMpO1xuICAgICAgICAgICAgaWYgKCEoZ2V0UmVxdWVzdE1ldGEocmVxLCAnbWluaW1hbE1vZGUnKSAmJiBpc0lzcikpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmRlbGV0ZShORVhUX0NBQ0hFX1RBR1NfSEVBREVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNhY2hlIGNvbnRyb2wgaXMgYWxyZWFkeSBzZXQgb24gdGhlIHJlc3BvbnNlIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBvdmVycmlkZSBpdCB0byBhbGxvdyB1c2VycyB0byBjdXN0b21pemUgaXQgdmlhIG5leHQuY29uZmlnXG4gICAgICAgICAgICBpZiAoY2FjaGVFbnRyeS5jYWNoZUNvbnRyb2wgJiYgIXJlcy5nZXRIZWFkZXIoJ0NhY2hlLUNvbnRyb2wnKSAmJiAhaGVhZGVycy5nZXQoJ0NhY2hlLUNvbnRyb2wnKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdDYWNoZS1Db250cm9sJywgZ2V0Q2FjaGVDb250cm9sSGVhZGVyKGNhY2hlRW50cnkuY2FjaGVDb250cm9sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UoY2FjaGVFbnRyeS52YWx1ZS5ib2R5LCB7XG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IGNhY2hlRW50cnkudmFsdWUuc3RhdHVzIHx8IDIwMFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGFjdGl2ZVNwYW4gY29kZSBwYXRoIGlzIGZvciB3aGVuIHdyYXBwZWQgYnlcbiAgICAgICAgLy8gbmV4dC1zZXJ2ZXIgY2FuIGJlIHJlbW92ZWQgd2hlbiB0aGlzIGlzIG5vIGxvbmdlciB1c2VkXG4gICAgICAgIGlmIChhY3RpdmVTcGFuKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXNwb25zZShhY3RpdmVTcGFuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRyYWNlci53aXRoUHJvcGFnYXRlZENvbnRleHQocmVxLmhlYWRlcnMsICgpPT50cmFjZXIudHJhY2UoQmFzZVNlcnZlclNwYW4uaGFuZGxlUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgICAgICBzcGFuTmFtZTogYCR7bWV0aG9kfSAke3JlcS51cmx9YCxcbiAgICAgICAgICAgICAgICAgICAga2luZDogU3BhbktpbmQuU0VSVkVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC5tZXRob2QnOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaHR0cC50YXJnZXQnOiByZXEudXJsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBoYW5kbGVSZXNwb25zZSkpO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZW4ndCB3cmFwcGVkIGJ5IGJhc2Utc2VydmVyIGhhbmRsZSBoZXJlXG4gICAgICAgIGlmICghYWN0aXZlU3BhbiAmJiAhKGVyciBpbnN0YW5jZW9mIE5vRmFsbGJhY2tFcnJvcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHJvdXRlTW9kdWxlLm9uUmVxdWVzdEVycm9yKHJlcSwgZXJyLCB7XG4gICAgICAgICAgICAgICAgcm91dGVyS2luZDogJ0FwcCBSb3V0ZXInLFxuICAgICAgICAgICAgICAgIHJvdXRlUGF0aDogbm9ybWFsaXplZFNyY1BhZ2UsXG4gICAgICAgICAgICAgICAgcm91dGVUeXBlOiAncm91dGUnLFxuICAgICAgICAgICAgICAgIHJldmFsaWRhdGVSZWFzb246IGdldFJldmFsaWRhdGVSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBpc1JldmFsaWRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGlzT25EZW1hbmRSZXZhbGlkYXRlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldGhyb3cgc28gdGhhdCB3ZSBjYW4gaGFuZGxlIHNlcnZpbmcgZXJyb3IgcGFnZVxuICAgICAgICAvLyBJZiB0aGlzIGlzIGR1cmluZyBzdGF0aWMgZ2VuZXJhdGlvbiwgdGhyb3cgdGhlIGVycm9yIGFnYWluLlxuICAgICAgICBpZiAoaXNJc3IpIHRocm93IGVycjtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZW5kIGEgNTAwIHJlc3BvbnNlLlxuICAgICAgICBhd2FpdCBzZW5kUmVzcG9uc2Uobm9kZU5leHRSZXEsIG5vZGVOZXh0UmVzLCBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fhealth%2Froute&page=%2Fapi%2Fhealth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fhealth%2Froute.ts&appDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./src/app/api/health/route.ts":
/*!*************************************!*\
  !*** ./src/app/api/health/route.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   HEAD: () => (/* binding */ HEAD)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/health-monitoring-simple */ \"(rsc)/./src/lib/health-monitoring-simple.ts\");\n\n\n// GET /api/health - Health check endpoint\nasync function GET(request) {\n    const startTime = Date.now();\n    try {\n        // Extract correlation ID from request headers\n        const correlationId = request.headers.get('X-Correlation-ID') || request.headers.get('x-correlation-id');\n        // Run comprehensive health check\n        const healthResult = await _lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_1__.healthMonitoring.runComprehensiveHealthCheck();\n        const responseTime = Date.now() - startTime;\n        // Add response metadata\n        const response = {\n            ...healthResult,\n            responseTime,\n            correlationId: correlationId || 'generated-' + Math.random().toString(36).substr(2, 9),\n            requestHeaders: {\n                'user-agent': request.headers.get('user-agent'),\n                'accept': request.headers.get('accept'),\n                'host': request.headers.get('host')\n            }\n        };\n        // Build response headers with exact case expected by verification script\n        const responseHeaders = {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-cache, no-store, must-revalidate',\n            'X-Response-Time': `${responseTime}ms`\n        };\n        // Always include the correlation ID in response headers with exact case\n        if (correlationId) {\n            responseHeaders['X-Correlation-ID'] = correlationId;\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(response, {\n            status: 200,\n            headers: responseHeaders\n        });\n    } catch (error) {\n        const responseTime = Date.now() - startTime;\n        const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n        const correlationId = request.headers.get('X-Correlation-ID') || request.headers.get('x-correlation-id');\n        // Build error response headers\n        const responseHeaders = {\n            'Content-Type': 'application/json',\n            'X-Response-Time': `${responseTime}ms`\n        };\n        // Include correlation ID in error response headers with exact case\n        if (correlationId) {\n            responseHeaders['X-Correlation-ID'] = correlationId;\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            status: 'unhealthy',\n            error: errorMessage,\n            responseTime,\n            timestamp: new Date().toISOString(),\n            correlationId: correlationId || 'error-' + Math.random().toString(36).substr(2, 9),\n            metadata: {\n                service: 'AI SaaS Factory - Next.js Frontend',\n                region: 'local',\n                instance: 'localhost',\n                build: 'local',\n                commit: 'local'\n            }\n        }, {\n            status: 503,\n            headers: responseHeaders\n        });\n    }\n}\n// HEAD /api/health - Lightweight health check (no body)\nasync function HEAD(request) {\n    try {\n        const correlationId = request.headers.get('X-Correlation-ID') || request.headers.get('x-correlation-id');\n        // Quick health check - just return basic status\n        const currentHealth = _lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_1__.healthMonitoring.getCurrentHealth();\n        // Build response headers\n        const responseHeaders = {\n            'X-Timestamp': new Date().toISOString()\n        };\n        // Include correlation ID in response headers with exact case\n        if (correlationId) {\n            responseHeaders['X-Correlation-ID'] = correlationId;\n        }\n        if (currentHealth && currentHealth.status === 'healthy') {\n            responseHeaders['X-Health-Status'] = 'healthy';\n            return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n                status: 200,\n                headers: responseHeaders\n            });\n        } else {\n            responseHeaders['X-Health-Status'] = 'unhealthy';\n            return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n                status: 503,\n                headers: responseHeaders\n            });\n        }\n    } catch (error) {\n        const correlationId = request.headers.get('X-Correlation-ID') || request.headers.get('x-correlation-id');\n        // Build error response headers\n        const responseHeaders = {\n            'X-Health-Status': 'error',\n            'X-Timestamp': new Date().toISOString()\n        };\n        // Include correlation ID in error response headers with exact case\n        if (correlationId) {\n            responseHeaders['X-Correlation-ID'] = correlationId;\n        }\n        return new next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse(null, {\n            status: 503,\n            headers: responseHeaders\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3hDO1FBRUEsSUFBSTRCLGlCQUFpQkEsY0FBY2QsTUFBTSxLQUFLLFdBQVc7WUFDdkRGLGVBQWUsQ0FBQyxrQkFBa0IsR0FBRztZQUNyQyxPQUFPLElBQUluQixxREFBWUEsQ0FBQyxNQUFNO2dCQUM1QnFCLFFBQVE7Z0JBQ1JiLFNBQVNXO1lBQ1g7UUFDRixPQUFPO1lBQ0xBLGVBQWUsQ0FBQyxrQkFBa0IsR0FBRztZQUNyQyxPQUFPLElBQUluQixxREFBWUEsQ0FBQyxNQUFNO2dCQUM1QnFCLFFBQVE7Z0JBQ1JiLFNBQVNXO1lBQ1g7UUFDRjtJQUNGLEVBQUUsT0FBT0csT0FBTztRQUNkLE1BQU1mLGdCQUFnQkosUUFBUUssT0FBTyxDQUFDQyxHQUFHLENBQUMsdUJBQXVCTixRQUFRSyxPQUFPLENBQUNDLEdBQUcsQ0FBQztRQUVyRiwrQkFBK0I7UUFDL0IsTUFBTVUsa0JBQTBDO1lBQzlDLG1CQUFtQjtZQUNuQixlQUFlLElBQUlkLE9BQU9zQixXQUFXO1FBQ3ZDO1FBRUEsbUVBQW1FO1FBQ25FLElBQUlwQixlQUFlO1lBQ2pCWSxlQUFlLENBQUMsbUJBQW1CLEdBQUdaO1FBQ3hDO1FBRUEsT0FBTyxJQUFJUCxxREFBWUEsQ0FBQyxNQUFNO1lBQzVCcUIsUUFBUTtZQUNSYixTQUFTVztRQUNYO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2FwcC9hcGkvaGVhbHRoL3JvdXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcidcbmltcG9ydCB7IGhlYWx0aE1vbml0b3JpbmcgfSBmcm9tICdAL2xpYi9oZWFsdGgtbW9uaXRvcmluZy1zaW1wbGUnXG5cbi8vIEdFVCAvYXBpL2hlYWx0aCAtIEhlYWx0aCBjaGVjayBlbmRwb2ludFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gIFxuICB0cnkge1xuICAgIC8vIEV4dHJhY3QgY29ycmVsYXRpb24gSUQgZnJvbSByZXF1ZXN0IGhlYWRlcnNcbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnWC1Db3JyZWxhdGlvbi1JRCcpIHx8IHJlcXVlc3QuaGVhZGVycy5nZXQoJ3gtY29ycmVsYXRpb24taWQnKVxuICAgIFxuICAgIC8vIFJ1biBjb21wcmVoZW5zaXZlIGhlYWx0aCBjaGVja1xuICAgIGNvbnN0IGhlYWx0aFJlc3VsdCA9IGF3YWl0IGhlYWx0aE1vbml0b3JpbmcucnVuQ29tcHJlaGVuc2l2ZUhlYWx0aENoZWNrKClcbiAgICBcbiAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgXG4gICAgLy8gQWRkIHJlc3BvbnNlIG1ldGFkYXRhXG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAuLi5oZWFsdGhSZXN1bHQsXG4gICAgICByZXNwb25zZVRpbWUsXG4gICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8ICdnZW5lcmF0ZWQtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSxcbiAgICAgIHJlcXVlc3RIZWFkZXJzOiB7XG4gICAgICAgICd1c2VyLWFnZW50JzogcmVxdWVzdC5oZWFkZXJzLmdldCgndXNlci1hZ2VudCcpLFxuICAgICAgICAnYWNjZXB0JzogcmVxdWVzdC5oZWFkZXJzLmdldCgnYWNjZXB0JyksXG4gICAgICAgICdob3N0JzogcmVxdWVzdC5oZWFkZXJzLmdldCgnaG9zdCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgcmVzcG9uc2UgaGVhZGVycyB3aXRoIGV4YWN0IGNhc2UgZXhwZWN0ZWQgYnkgdmVyaWZpY2F0aW9uIHNjcmlwdFxuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSwgbm8tc3RvcmUsIG11c3QtcmV2YWxpZGF0ZScsXG4gICAgICAnWC1SZXNwb25zZS1UaW1lJzogYCR7cmVzcG9uc2VUaW1lfW1zYFxuICAgIH1cblxuICAgIC8vIEFsd2F5cyBpbmNsdWRlIHRoZSBjb3JyZWxhdGlvbiBJRCBpbiByZXNwb25zZSBoZWFkZXJzIHdpdGggZXhhY3QgY2FzZVxuICAgIGlmIChjb3JyZWxhdGlvbklkKSB7XG4gICAgICByZXNwb25zZUhlYWRlcnNbJ1gtQ29ycmVsYXRpb24tSUQnXSA9IGNvcnJlbGF0aW9uSWRcbiAgICB9XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzcG9uc2UsIHtcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcidcbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnWC1Db3JyZWxhdGlvbi1JRCcpIHx8IHJlcXVlc3QuaGVhZGVycy5nZXQoJ3gtY29ycmVsYXRpb24taWQnKVxuXG4gICAgLy8gQnVpbGQgZXJyb3IgcmVzcG9uc2UgaGVhZGVyc1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnWC1SZXNwb25zZS1UaW1lJzogYCR7cmVzcG9uc2VUaW1lfW1zYFxuICAgIH1cblxuICAgIC8vIEluY2x1ZGUgY29ycmVsYXRpb24gSUQgaW4gZXJyb3IgcmVzcG9uc2UgaGVhZGVycyB3aXRoIGV4YWN0IGNhc2VcbiAgICBpZiAoY29ycmVsYXRpb25JZCkge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzWydYLUNvcnJlbGF0aW9uLUlEJ10gPSBjb3JyZWxhdGlvbklkXG4gICAgfVxuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAge1xuICAgICAgICBzdGF0dXM6ICd1bmhlYWx0aHknLFxuICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICByZXNwb25zZVRpbWUsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjb3JyZWxhdGlvbklkOiBjb3JyZWxhdGlvbklkIHx8ICdlcnJvci0nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpLFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHNlcnZpY2U6ICdBSSBTYWFTIEZhY3RvcnkgLSBOZXh0LmpzIEZyb250ZW5kJyxcbiAgICAgICAgICByZWdpb246ICdsb2NhbCcsXG4gICAgICAgICAgaW5zdGFuY2U6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgIGJ1aWxkOiAnbG9jYWwnLFxuICAgICAgICAgIGNvbW1pdDogJ2xvY2FsJ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdGF0dXM6IDUwMyxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gICAgICB9XG4gICAgKVxuICB9XG59XG5cbi8vIEhFQUQgL2FwaS9oZWFsdGggLSBMaWdodHdlaWdodCBoZWFsdGggY2hlY2sgKG5vIGJvZHkpXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gSEVBRChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdYLUNvcnJlbGF0aW9uLUlEJykgfHwgcmVxdWVzdC5oZWFkZXJzLmdldCgneC1jb3JyZWxhdGlvbi1pZCcpXG4gICAgXG4gICAgLy8gUXVpY2sgaGVhbHRoIGNoZWNrIC0ganVzdCByZXR1cm4gYmFzaWMgc3RhdHVzXG4gICAgY29uc3QgY3VycmVudEhlYWx0aCA9IGhlYWx0aE1vbml0b3JpbmcuZ2V0Q3VycmVudEhlYWx0aCgpXG4gICAgXG4gICAgLy8gQnVpbGQgcmVzcG9uc2UgaGVhZGVyc1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdYLVRpbWVzdGFtcCc6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH1cblxuICAgIC8vIEluY2x1ZGUgY29ycmVsYXRpb24gSUQgaW4gcmVzcG9uc2UgaGVhZGVycyB3aXRoIGV4YWN0IGNhc2VcbiAgICBpZiAoY29ycmVsYXRpb25JZCkge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzWydYLUNvcnJlbGF0aW9uLUlEJ10gPSBjb3JyZWxhdGlvbklkXG4gICAgfVxuICAgIFxuICAgIGlmIChjdXJyZW50SGVhbHRoICYmIGN1cnJlbnRIZWFsdGguc3RhdHVzID09PSAnaGVhbHRoeScpIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVyc1snWC1IZWFsdGgtU3RhdHVzJ10gPSAnaGVhbHRoeSdcbiAgICAgIHJldHVybiBuZXcgTmV4dFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVyc1xuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzWydYLUhlYWx0aC1TdGF0dXMnXSA9ICd1bmhlYWx0aHknXG4gICAgICByZXR1cm4gbmV3IE5leHRSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNTAzLFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICAgIH0pXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdYLUNvcnJlbGF0aW9uLUlEJykgfHwgcmVxdWVzdC5oZWFkZXJzLmdldCgneC1jb3JyZWxhdGlvbi1pZCcpXG4gICAgXG4gICAgLy8gQnVpbGQgZXJyb3IgcmVzcG9uc2UgaGVhZGVyc1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICdYLUhlYWx0aC1TdGF0dXMnOiAnZXJyb3InLFxuICAgICAgJ1gtVGltZXN0YW1wJzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfVxuXG4gICAgLy8gSW5jbHVkZSBjb3JyZWxhdGlvbiBJRCBpbiBlcnJvciByZXNwb25zZSBoZWFkZXJzIHdpdGggZXhhY3QgY2FzZVxuICAgIGlmIChjb3JyZWxhdGlvbklkKSB7XG4gICAgICByZXNwb25zZUhlYWRlcnNbJ1gtQ29ycmVsYXRpb24tSUQnXSA9IGNvcnJlbGF0aW9uSWRcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ldyBOZXh0UmVzcG9uc2UobnVsbCwge1xuICAgICAgc3RhdHVzOiA1MDMsXG4gICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICB9KVxuICB9XG59IFxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImhlYWx0aE1vbml0b3JpbmciLCJHRVQiLCJyZXF1ZXN0Iiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImNvcnJlbGF0aW9uSWQiLCJoZWFkZXJzIiwiZ2V0IiwiaGVhbHRoUmVzdWx0IiwicnVuQ29tcHJlaGVuc2l2ZUhlYWx0aENoZWNrIiwicmVzcG9uc2VUaW1lIiwicmVzcG9uc2UiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJyZXF1ZXN0SGVhZGVycyIsInJlc3BvbnNlSGVhZGVycyIsImpzb24iLCJzdGF0dXMiLCJlcnJvciIsImVycm9yTWVzc2FnZSIsIkVycm9yIiwibWVzc2FnZSIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwibWV0YWRhdGEiLCJzZXJ2aWNlIiwicmVnaW9uIiwiaW5zdGFuY2UiLCJidWlsZCIsImNvbW1pdCIsIkhFQUQiLCJjdXJyZW50SGVhbHRoIiwiZ2V0Q3VycmVudEhlYWx0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/health/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/correlation-id.ts":
/*!***********************************!*\
  !*** ./src/lib/correlation-id.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CorrelationIDManager: () => (/* binding */ CorrelationIDManager),\n/* harmony export */   correlationIDManager: () => (/* binding */ correlationIDManager),\n/* harmony export */   fetchWithCorrelation: () => (/* binding */ fetchWithCorrelation),\n/* harmony export */   getCorrelationHeaders: () => (/* binding */ getCorrelationHeaders),\n/* harmony export */   useCorrelationID: () => (/* binding */ useCorrelationID)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm/v4.js\");\n\n// Global correlation context\nlet globalCorrelationContext = null;\n// Correlation ID manager\nclass CorrelationIDManager {\n    static getInstance() {\n        if (!CorrelationIDManager.instance) {\n            CorrelationIDManager.instance = new CorrelationIDManager();\n        }\n        return CorrelationIDManager.instance;\n    }\n    // Generate a new correlation context\n    generateContext(parentId, userId, tenantId, sessionId, metadata = {}) {\n        const correlationId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        const requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        const spanId = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        const traceId = parentId || (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n        const context = {\n            correlationId,\n            requestId,\n            parentId,\n            spanId,\n            traceId,\n            userId,\n            tenantId,\n            sessionId,\n            timestamp: Date.now(),\n            metadata: {\n                service: 'frontend',\n                version: process.env.NEXT_PUBLIC_APP_VERSION || '1.0.0',\n                environment: \"development\" || 0,\n                ...metadata\n            }\n        };\n        this.contextMap.set(correlationId, context);\n        globalCorrelationContext = context;\n        return context;\n    }\n    // Get current correlation context\n    getCurrentContext() {\n        return globalCorrelationContext;\n    }\n    // Get context by correlation ID\n    getContext(correlationId) {\n        return this.contextMap.get(correlationId) || null;\n    }\n    // Set current context\n    setCurrentContext(context) {\n        globalCorrelationContext = context;\n        this.contextMap.set(context.correlationId, context);\n    }\n    // Clear current context\n    clearCurrentContext() {\n        globalCorrelationContext = null;\n    }\n    // Propagate correlation ID to headers\n    getHeaders() {\n        const context = this.getCurrentContext();\n        if (!context) return {};\n        return {\n            'X-Correlation-ID': context.correlationId,\n            'X-Request-ID': context.requestId,\n            'X-Span-ID': context.spanId,\n            'X-Trace-ID': context.traceId,\n            'X-Parent-ID': context.parentId || '',\n            'X-User-ID': context.userId || '',\n            'X-Tenant-ID': context.tenantId || '',\n            'X-Session-ID': context.sessionId || '',\n            'X-Timestamp': context.timestamp.toString(),\n            'X-Service': context.metadata.service || 'frontend'\n        };\n    }\n    // Extract correlation ID from headers\n    extractFromHeaders(headers) {\n        const correlationId = headers['x-correlation-id'] || headers['X-Correlation-ID'];\n        if (!correlationId) return null;\n        // Check if we already have this context\n        const existingContext = this.getContext(correlationId);\n        if (existingContext) {\n            this.setCurrentContext(existingContext);\n            return existingContext;\n        }\n        // Create new context from headers, preserving the incoming correlation ID\n        const newContext = {\n            correlationId: correlationId,\n            requestId: headers['x-request-id'] || headers['X-Request-ID'] || (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n            parentId: headers['x-parent-id'] || headers['X-Parent-ID'] || undefined,\n            spanId: headers['x-span-id'] || headers['X-Span-ID'] || (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n            traceId: headers['x-trace-id'] || headers['X-Trace-ID'] || correlationId,\n            userId: headers['x-user-id'] || headers['X-User-ID'] || undefined,\n            tenantId: headers['x-tenant-id'] || headers['X-Tenant-ID'] || undefined,\n            sessionId: headers['x-session-id'] || headers['X-Session-ID'] || undefined,\n            timestamp: parseInt(headers['x-timestamp'] || headers['X-Timestamp'] || Date.now().toString()),\n            metadata: {\n                service: headers['x-service'] || headers['X-Service'] || 'unknown',\n                version: process.env.NEXT_PUBLIC_APP_VERSION || '1.0.0',\n                environment: \"development\" || 0\n            }\n        };\n        // Store and set as current context\n        this.contextMap.set(correlationId, newContext);\n        this.setCurrentContext(newContext);\n        return newContext;\n    }\n    // Create child span\n    createChildSpan(metadata = {}) {\n        const parentContext = this.getCurrentContext();\n        if (!parentContext) {\n            return this.generateContext(undefined, undefined, undefined, undefined, metadata);\n        }\n        const childContext = {\n            ...parentContext,\n            requestId: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n            spanId: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n            parentId: parentContext.spanId,\n            timestamp: Date.now(),\n            metadata: {\n                ...parentContext.metadata,\n                ...metadata,\n                parentSpanId: parentContext.spanId\n            }\n        };\n        this.contextMap.set(childContext.correlationId, childContext);\n        return childContext;\n    }\n    // Log correlation context\n    logContext(context, level = 'info') {\n        const logData = {\n            level,\n            correlationId: context.correlationId,\n            requestId: context.requestId,\n            spanId: context.spanId,\n            traceId: context.traceId,\n            parentId: context.parentId,\n            userId: context.userId,\n            tenantId: context.tenantId,\n            sessionId: context.sessionId,\n            timestamp: context.timestamp,\n            metadata: context.metadata\n        };\n        switch(level){\n            case 'error':\n                console.error('🔗 Correlation Context:', logData);\n                break;\n            case 'warn':\n                console.warn('🔗 Correlation Context:', logData);\n                break;\n            default:\n                console.log('🔗 Correlation Context:', logData);\n        }\n    }\n    // Get all contexts for a trace\n    getTraceContexts(traceId) {\n        return Array.from(this.contextMap.values()).filter((context)=>context.traceId === traceId);\n    }\n    // Clean up old contexts (older than 1 hour)\n    cleanup() {\n        const oneHourAgo = Date.now() - 60 * 60 * 1000;\n        for (const [correlationId, context] of this.contextMap.entries()){\n            if (context.timestamp < oneHourAgo) {\n                this.contextMap.delete(correlationId);\n            }\n        }\n    }\n    constructor(){\n        this.contextMap = new Map();\n    }\n}\n// Export singleton instance\nconst correlationIDManager = CorrelationIDManager.getInstance();\n// React hook for correlation ID\nfunction useCorrelationID() {\n    const context = correlationIDManager.getCurrentContext();\n    const generateNew = (parentId, userId, tenantId, sessionId, metadata)=>{\n        return correlationIDManager.generateContext(parentId, userId, tenantId, sessionId, metadata);\n    };\n    const getHeaders = ()=>correlationIDManager.getHeaders();\n    const logContext = (level = 'info')=>{\n        if (context) correlationIDManager.logContext(context, level);\n    };\n    return {\n        context,\n        generateNew,\n        getHeaders,\n        logContext,\n        correlationId: context?.correlationId,\n        requestId: context?.requestId,\n        spanId: context?.spanId,\n        traceId: context?.traceId\n    };\n}\n// Utility function to add correlation headers to fetch requests\nfunction fetchWithCorrelation(url, options = {}) {\n    const headers = correlationIDManager.getHeaders();\n    const enhancedOptions = {\n        ...options,\n        headers: {\n            ...headers,\n            ...options.headers\n        }\n    };\n    return fetch(url, enhancedOptions);\n}\n// Utility function to add correlation headers to axios requests\nfunction getCorrelationHeaders() {\n    return correlationIDManager.getHeaders();\n}\n// Auto-cleanup every hour\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRytCLFFBQVEvQixPQUFPO1FBQ3BCO0lBQ0Y7SUFFQSxPQUFPaUMsTUFBTUgsS0FBS0U7QUFDcEI7QUFFQSxnRUFBZ0U7QUFDekQsU0FBU0U7SUFDZCxPQUFPUixxQkFBcUI3QixVQUFVO0FBQ3hDO0FBRUEsMEJBQTBCO0FBQzFCLElBQUksS0FBNkIsRUFBRSxFQUlsQyIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2xpYi9jb3JyZWxhdGlvbi1pZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJ1xuXG4vLyBDb3JyZWxhdGlvbiBJRCBjb250ZXh0IGZvciByZXF1ZXN0IHRyYWNpbmdcbmV4cG9ydCBpbnRlcmZhY2UgQ29ycmVsYXRpb25Db250ZXh0IHtcbiAgY29ycmVsYXRpb25JZDogc3RyaW5nXG4gIHJlcXVlc3RJZDogc3RyaW5nXG4gIHBhcmVudElkPzogc3RyaW5nXG4gIHNwYW5JZDogc3RyaW5nXG4gIHRyYWNlSWQ6IHN0cmluZ1xuICB1c2VySWQ/OiBzdHJpbmdcbiAgdGVuYW50SWQ/OiBzdHJpbmdcbiAgc2Vzc2lvbklkPzogc3RyaW5nXG4gIHRpbWVzdGFtcDogbnVtYmVyXG4gIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG59XG5cbi8vIEdsb2JhbCBjb3JyZWxhdGlvbiBjb250ZXh0XG5sZXQgZ2xvYmFsQ29ycmVsYXRpb25Db250ZXh0OiBDb3JyZWxhdGlvbkNvbnRleHQgfCBudWxsID0gbnVsbFxuXG4vLyBDb3JyZWxhdGlvbiBJRCBtYW5hZ2VyXG5leHBvcnQgY2xhc3MgQ29ycmVsYXRpb25JRE1hbmFnZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogQ29ycmVsYXRpb25JRE1hbmFnZXJcbiAgcHJpdmF0ZSBjb250ZXh0TWFwID0gbmV3IE1hcDxzdHJpbmcsIENvcnJlbGF0aW9uQ29udGV4dD4oKVxuXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBDb3JyZWxhdGlvbklETWFuYWdlciB7XG4gICAgaWYgKCFDb3JyZWxhdGlvbklETWFuYWdlci5pbnN0YW5jZSkge1xuICAgICAgQ29ycmVsYXRpb25JRE1hbmFnZXIuaW5zdGFuY2UgPSBuZXcgQ29ycmVsYXRpb25JRE1hbmFnZXIoKVxuICAgIH1cbiAgICByZXR1cm4gQ29ycmVsYXRpb25JRE1hbmFnZXIuaW5zdGFuY2VcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIGEgbmV3IGNvcnJlbGF0aW9uIGNvbnRleHRcbiAgZ2VuZXJhdGVDb250ZXh0KFxuICAgIHBhcmVudElkPzogc3RyaW5nLFxuICAgIHVzZXJJZD86IHN0cmluZyxcbiAgICB0ZW5hbnRJZD86IHN0cmluZyxcbiAgICBzZXNzaW9uSWQ/OiBzdHJpbmcsXG4gICAgbWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuICApOiBDb3JyZWxhdGlvbkNvbnRleHQge1xuICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSB1dWlkdjQoKVxuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWR2NCgpXG4gICAgY29uc3Qgc3BhbklkID0gdXVpZHY0KClcbiAgICBjb25zdCB0cmFjZUlkID0gcGFyZW50SWQgfHwgdXVpZHY0KClcblxuICAgIGNvbnN0IGNvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dCA9IHtcbiAgICAgIGNvcnJlbGF0aW9uSWQsXG4gICAgICByZXF1ZXN0SWQsXG4gICAgICBwYXJlbnRJZCxcbiAgICAgIHNwYW5JZCxcbiAgICAgIHRyYWNlSWQsXG4gICAgICB1c2VySWQsXG4gICAgICB0ZW5hbnRJZCxcbiAgICAgIHNlc3Npb25JZCxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHNlcnZpY2U6ICdmcm9udGVuZCcsXG4gICAgICAgIHZlcnNpb246IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQUF9WRVJTSU9OIHx8ICcxLjAuMCcsXG4gICAgICAgIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnLFxuICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29udGV4dE1hcC5zZXQoY29ycmVsYXRpb25JZCwgY29udGV4dClcbiAgICBnbG9iYWxDb3JyZWxhdGlvbkNvbnRleHQgPSBjb250ZXh0XG5cbiAgICByZXR1cm4gY29udGV4dFxuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgY29ycmVsYXRpb24gY29udGV4dFxuICBnZXRDdXJyZW50Q29udGV4dCgpOiBDb3JyZWxhdGlvbkNvbnRleHQgfCBudWxsIHtcbiAgICByZXR1cm4gZ2xvYmFsQ29ycmVsYXRpb25Db250ZXh0XG4gIH1cblxuICAvLyBHZXQgY29udGV4dCBieSBjb3JyZWxhdGlvbiBJRFxuICBnZXRDb250ZXh0KGNvcnJlbGF0aW9uSWQ6IHN0cmluZyk6IENvcnJlbGF0aW9uQ29udGV4dCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHRNYXAuZ2V0KGNvcnJlbGF0aW9uSWQpIHx8IG51bGxcbiAgfVxuXG4gIC8vIFNldCBjdXJyZW50IGNvbnRleHRcbiAgc2V0Q3VycmVudENvbnRleHQoY29udGV4dDogQ29ycmVsYXRpb25Db250ZXh0KTogdm9pZCB7XG4gICAgZ2xvYmFsQ29ycmVsYXRpb25Db250ZXh0ID0gY29udGV4dFxuICAgIHRoaXMuY29udGV4dE1hcC5zZXQoY29udGV4dC5jb3JyZWxhdGlvbklkLCBjb250ZXh0KVxuICB9XG5cbiAgLy8gQ2xlYXIgY3VycmVudCBjb250ZXh0XG4gIGNsZWFyQ3VycmVudENvbnRleHQoKTogdm9pZCB7XG4gICAgZ2xvYmFsQ29ycmVsYXRpb25Db250ZXh0ID0gbnVsbFxuICB9XG5cbiAgLy8gUHJvcGFnYXRlIGNvcnJlbGF0aW9uIElEIHRvIGhlYWRlcnNcbiAgZ2V0SGVhZGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dCgpXG4gICAgaWYgKCFjb250ZXh0KSByZXR1cm4ge31cblxuICAgIHJldHVybiB7XG4gICAgICAnWC1Db3JyZWxhdGlvbi1JRCc6IGNvbnRleHQuY29ycmVsYXRpb25JZCxcbiAgICAgICdYLVJlcXVlc3QtSUQnOiBjb250ZXh0LnJlcXVlc3RJZCxcbiAgICAgICdYLVNwYW4tSUQnOiBjb250ZXh0LnNwYW5JZCxcbiAgICAgICdYLVRyYWNlLUlEJzogY29udGV4dC50cmFjZUlkLFxuICAgICAgJ1gtUGFyZW50LUlEJzogY29udGV4dC5wYXJlbnRJZCB8fCAnJyxcbiAgICAgICdYLVVzZXItSUQnOiBjb250ZXh0LnVzZXJJZCB8fCAnJyxcbiAgICAgICdYLVRlbmFudC1JRCc6IGNvbnRleHQudGVuYW50SWQgfHwgJycsXG4gICAgICAnWC1TZXNzaW9uLUlEJzogY29udGV4dC5zZXNzaW9uSWQgfHwgJycsXG4gICAgICAnWC1UaW1lc3RhbXAnOiBjb250ZXh0LnRpbWVzdGFtcC50b1N0cmluZygpLFxuICAgICAgJ1gtU2VydmljZSc6IGNvbnRleHQubWV0YWRhdGEuc2VydmljZSB8fCAnZnJvbnRlbmQnXG4gICAgfVxuICB9XG5cbiAgLy8gRXh0cmFjdCBjb3JyZWxhdGlvbiBJRCBmcm9tIGhlYWRlcnNcbiAgZXh0cmFjdEZyb21IZWFkZXJzKGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBDb3JyZWxhdGlvbkNvbnRleHQgfCBudWxsIHtcbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gaGVhZGVyc1sneC1jb3JyZWxhdGlvbi1pZCddIHx8IGhlYWRlcnNbJ1gtQ29ycmVsYXRpb24tSUQnXVxuICAgIGlmICghY29ycmVsYXRpb25JZCkgcmV0dXJuIG51bGxcblxuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIGNvbnRleHRcbiAgICBjb25zdCBleGlzdGluZ0NvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY29ycmVsYXRpb25JZClcbiAgICBpZiAoZXhpc3RpbmdDb250ZXh0KSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRDb250ZXh0KGV4aXN0aW5nQ29udGV4dClcbiAgICAgIHJldHVybiBleGlzdGluZ0NvbnRleHRcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IGNvbnRleHQgZnJvbSBoZWFkZXJzLCBwcmVzZXJ2aW5nIHRoZSBpbmNvbWluZyBjb3JyZWxhdGlvbiBJRFxuICAgIGNvbnN0IG5ld0NvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dCA9IHtcbiAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQsIC8vIFVzZSB0aGUgaW5jb21pbmcgY29ycmVsYXRpb24gSUQgZXhhY3RseVxuICAgICAgcmVxdWVzdElkOiBoZWFkZXJzWyd4LXJlcXVlc3QtaWQnXSB8fCBoZWFkZXJzWydYLVJlcXVlc3QtSUQnXSB8fCB1dWlkdjQoKSxcbiAgICAgIHBhcmVudElkOiBoZWFkZXJzWyd4LXBhcmVudC1pZCddIHx8IGhlYWRlcnNbJ1gtUGFyZW50LUlEJ10gfHwgdW5kZWZpbmVkLFxuICAgICAgc3BhbklkOiBoZWFkZXJzWyd4LXNwYW4taWQnXSB8fCBoZWFkZXJzWydYLVNwYW4tSUQnXSB8fCB1dWlkdjQoKSxcbiAgICAgIHRyYWNlSWQ6IGhlYWRlcnNbJ3gtdHJhY2UtaWQnXSB8fCBoZWFkZXJzWydYLVRyYWNlLUlEJ10gfHwgY29ycmVsYXRpb25JZCxcbiAgICAgIHVzZXJJZDogaGVhZGVyc1sneC11c2VyLWlkJ10gfHwgaGVhZGVyc1snWC1Vc2VyLUlEJ10gfHwgdW5kZWZpbmVkLFxuICAgICAgdGVuYW50SWQ6IGhlYWRlcnNbJ3gtdGVuYW50LWlkJ10gfHwgaGVhZGVyc1snWC1UZW5hbnQtSUQnXSB8fCB1bmRlZmluZWQsXG4gICAgICBzZXNzaW9uSWQ6IGhlYWRlcnNbJ3gtc2Vzc2lvbi1pZCddIHx8IGhlYWRlcnNbJ1gtU2Vzc2lvbi1JRCddIHx8IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzdGFtcDogcGFyc2VJbnQoaGVhZGVyc1sneC10aW1lc3RhbXAnXSB8fCBoZWFkZXJzWydYLVRpbWVzdGFtcCddIHx8IERhdGUubm93KCkudG9TdHJpbmcoKSksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBzZXJ2aWNlOiBoZWFkZXJzWyd4LXNlcnZpY2UnXSB8fCBoZWFkZXJzWydYLVNlcnZpY2UnXSB8fCAndW5rbm93bicsXG4gICAgICAgIHZlcnNpb246IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQUF9WRVJTSU9OIHx8ICcxLjAuMCcsXG4gICAgICAgIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5OT0RFX0VOViB8fCAnZGV2ZWxvcG1lbnQnXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RvcmUgYW5kIHNldCBhcyBjdXJyZW50IGNvbnRleHRcbiAgICB0aGlzLmNvbnRleHRNYXAuc2V0KGNvcnJlbGF0aW9uSWQsIG5ld0NvbnRleHQpXG4gICAgdGhpcy5zZXRDdXJyZW50Q29udGV4dChuZXdDb250ZXh0KVxuICAgIFxuICAgIHJldHVybiBuZXdDb250ZXh0XG4gIH1cblxuICAvLyBDcmVhdGUgY2hpbGQgc3BhblxuICBjcmVhdGVDaGlsZFNwYW4obWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSk6IENvcnJlbGF0aW9uQ29udGV4dCB7XG4gICAgY29uc3QgcGFyZW50Q29udGV4dCA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoKVxuICAgIGlmICghcGFyZW50Q29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVDb250ZXh0KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWV0YWRhdGEpXG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRDb250ZXh0OiBDb3JyZWxhdGlvbkNvbnRleHQgPSB7XG4gICAgICAuLi5wYXJlbnRDb250ZXh0LFxuICAgICAgcmVxdWVzdElkOiB1dWlkdjQoKSxcbiAgICAgIHNwYW5JZDogdXVpZHY0KCksXG4gICAgICBwYXJlbnRJZDogcGFyZW50Q29udGV4dC5zcGFuSWQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICAuLi5wYXJlbnRDb250ZXh0Lm1ldGFkYXRhLFxuICAgICAgICAuLi5tZXRhZGF0YSxcbiAgICAgICAgcGFyZW50U3BhbklkOiBwYXJlbnRDb250ZXh0LnNwYW5JZFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29udGV4dE1hcC5zZXQoY2hpbGRDb250ZXh0LmNvcnJlbGF0aW9uSWQsIGNoaWxkQ29udGV4dClcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0XG4gIH1cblxuICAvLyBMb2cgY29ycmVsYXRpb24gY29udGV4dFxuICBsb2dDb250ZXh0KGNvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dCwgbGV2ZWw6ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcicgPSAnaW5mbycpOiB2b2lkIHtcbiAgICBjb25zdCBsb2dEYXRhID0ge1xuICAgICAgbGV2ZWwsXG4gICAgICBjb3JyZWxhdGlvbklkOiBjb250ZXh0LmNvcnJlbGF0aW9uSWQsXG4gICAgICByZXF1ZXN0SWQ6IGNvbnRleHQucmVxdWVzdElkLFxuICAgICAgc3BhbklkOiBjb250ZXh0LnNwYW5JZCxcbiAgICAgIHRyYWNlSWQ6IGNvbnRleHQudHJhY2VJZCxcbiAgICAgIHBhcmVudElkOiBjb250ZXh0LnBhcmVudElkLFxuICAgICAgdXNlcklkOiBjb250ZXh0LnVzZXJJZCxcbiAgICAgIHRlbmFudElkOiBjb250ZXh0LnRlbmFudElkLFxuICAgICAgc2Vzc2lvbklkOiBjb250ZXh0LnNlc3Npb25JZCxcbiAgICAgIHRpbWVzdGFtcDogY29udGV4dC50aW1lc3RhbXAsXG4gICAgICBtZXRhZGF0YTogY29udGV4dC5tZXRhZGF0YVxuICAgIH1cblxuICAgIHN3aXRjaCAobGV2ZWwpIHtcbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgY29uc29sZS5lcnJvcign8J+UlyBDb3JyZWxhdGlvbiBDb250ZXh0OicsIGxvZ0RhdGEpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgY29uc29sZS53YXJuKCfwn5SXIENvcnJlbGF0aW9uIENvbnRleHQ6JywgbG9nRGF0YSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SXIENvcnJlbGF0aW9uIENvbnRleHQ6JywgbG9nRGF0YSlcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYWxsIGNvbnRleHRzIGZvciBhIHRyYWNlXG4gIGdldFRyYWNlQ29udGV4dHModHJhY2VJZDogc3RyaW5nKTogQ29ycmVsYXRpb25Db250ZXh0W10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29udGV4dE1hcC52YWx1ZXMoKSkuZmlsdGVyKGNvbnRleHQgPT4gY29udGV4dC50cmFjZUlkID09PSB0cmFjZUlkKVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgb2xkIGNvbnRleHRzIChvbGRlciB0aGFuIDEgaG91cilcbiAgY2xlYW51cCgpOiB2b2lkIHtcbiAgICBjb25zdCBvbmVIb3VyQWdvID0gRGF0ZS5ub3coKSAtICg2MCAqIDYwICogMTAwMClcbiAgICBmb3IgKGNvbnN0IFtjb3JyZWxhdGlvbklkLCBjb250ZXh0XSBvZiB0aGlzLmNvbnRleHRNYXAuZW50cmllcygpKSB7XG4gICAgICBpZiAoY29udGV4dC50aW1lc3RhbXAgPCBvbmVIb3VyQWdvKSB7XG4gICAgICAgIHRoaXMuY29udGV4dE1hcC5kZWxldGUoY29ycmVsYXRpb25JZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGNvcnJlbGF0aW9uSURNYW5hZ2VyID0gQ29ycmVsYXRpb25JRE1hbmFnZXIuZ2V0SW5zdGFuY2UoKVxuXG4vLyBSZWFjdCBob29rIGZvciBjb3JyZWxhdGlvbiBJRFxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvcnJlbGF0aW9uSUQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBjb3JyZWxhdGlvbklETWFuYWdlci5nZXRDdXJyZW50Q29udGV4dCgpXG4gIFxuICBjb25zdCBnZW5lcmF0ZU5ldyA9IChcbiAgICBwYXJlbnRJZD86IHN0cmluZyxcbiAgICB1c2VySWQ/OiBzdHJpbmcsXG4gICAgdGVuYW50SWQ/OiBzdHJpbmcsXG4gICAgc2Vzc2lvbklkPzogc3RyaW5nLFxuICAgIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PlxuICApID0+IHtcbiAgICByZXR1cm4gY29ycmVsYXRpb25JRE1hbmFnZXIuZ2VuZXJhdGVDb250ZXh0KHBhcmVudElkLCB1c2VySWQsIHRlbmFudElkLCBzZXNzaW9uSWQsIG1ldGFkYXRhKVxuICB9XG5cbiAgY29uc3QgZ2V0SGVhZGVycyA9ICgpID0+IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEhlYWRlcnMoKVxuICBjb25zdCBsb2dDb250ZXh0ID0gKGxldmVsOiAnaW5mbycgfCAnd2FybicgfCAnZXJyb3InID0gJ2luZm8nKSA9PiB7XG4gICAgaWYgKGNvbnRleHQpIGNvcnJlbGF0aW9uSURNYW5hZ2VyLmxvZ0NvbnRleHQoY29udGV4dCwgbGV2ZWwpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbnRleHQsXG4gICAgZ2VuZXJhdGVOZXcsXG4gICAgZ2V0SGVhZGVycyxcbiAgICBsb2dDb250ZXh0LFxuICAgIGNvcnJlbGF0aW9uSWQ6IGNvbnRleHQ/LmNvcnJlbGF0aW9uSWQsXG4gICAgcmVxdWVzdElkOiBjb250ZXh0Py5yZXF1ZXN0SWQsXG4gICAgc3BhbklkOiBjb250ZXh0Py5zcGFuSWQsXG4gICAgdHJhY2VJZDogY29udGV4dD8udHJhY2VJZFxuICB9XG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gYWRkIGNvcnJlbGF0aW9uIGhlYWRlcnMgdG8gZmV0Y2ggcmVxdWVzdHNcbmV4cG9ydCBmdW5jdGlvbiBmZXRjaFdpdGhDb3JyZWxhdGlvbihcbiAgdXJsOiBzdHJpbmcsXG4gIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cbik6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgY29uc3QgaGVhZGVycyA9IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEhlYWRlcnMoKVxuICBcbiAgY29uc3QgZW5oYW5jZWRPcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmV0Y2godXJsLCBlbmhhbmNlZE9wdGlvbnMpXG59XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gYWRkIGNvcnJlbGF0aW9uIGhlYWRlcnMgdG8gYXhpb3MgcmVxdWVzdHNcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb3JyZWxhdGlvbkhlYWRlcnMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIHJldHVybiBjb3JyZWxhdGlvbklETWFuYWdlci5nZXRIZWFkZXJzKClcbn1cblxuLy8gQXV0by1jbGVhbnVwIGV2ZXJ5IGhvdXJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgY29ycmVsYXRpb25JRE1hbmFnZXIuY2xlYW51cCgpXG4gIH0sIDYwICogNjAgKiAxMDAwKSAvLyAxIGhvdXJcbn1cbiJdLCJuYW1lcyI6WyJ2NCIsInV1aWR2NCIsImdsb2JhbENvcnJlbGF0aW9uQ29udGV4dCIsIkNvcnJlbGF0aW9uSURNYW5hZ2VyIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImdlbmVyYXRlQ29udGV4dCIsInBhcmVudElkIiwidXNlcklkIiwidGVuYW50SWQiLCJzZXNzaW9uSWQiLCJtZXRhZGF0YSIsImNvcnJlbGF0aW9uSWQiLCJyZXF1ZXN0SWQiLCJzcGFuSWQiLCJ0cmFjZUlkIiwiY29udGV4dCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJzZXJ2aWNlIiwidmVyc2lvbiIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUFBfVkVSU0lPTiIsImVudmlyb25tZW50IiwiY29udGV4dE1hcCIsInNldCIsImdldEN1cnJlbnRDb250ZXh0IiwiZ2V0Q29udGV4dCIsImdldCIsInNldEN1cnJlbnRDb250ZXh0IiwiY2xlYXJDdXJyZW50Q29udGV4dCIsImdldEhlYWRlcnMiLCJ0b1N0cmluZyIsImV4dHJhY3RGcm9tSGVhZGVycyIsImhlYWRlcnMiLCJleGlzdGluZ0NvbnRleHQiLCJuZXdDb250ZXh0IiwidW5kZWZpbmVkIiwicGFyc2VJbnQiLCJjcmVhdGVDaGlsZFNwYW4iLCJwYXJlbnRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwicGFyZW50U3BhbklkIiwibG9nQ29udGV4dCIsImxldmVsIiwibG9nRGF0YSIsImNvbnNvbGUiLCJlcnJvciIsIndhcm4iLCJsb2ciLCJnZXRUcmFjZUNvbnRleHRzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZmlsdGVyIiwiY2xlYW51cCIsIm9uZUhvdXJBZ28iLCJlbnRyaWVzIiwiZGVsZXRlIiwiTWFwIiwiY29ycmVsYXRpb25JRE1hbmFnZXIiLCJ1c2VDb3JyZWxhdGlvbklEIiwiZ2VuZXJhdGVOZXciLCJmZXRjaFdpdGhDb3JyZWxhdGlvbiIsInVybCIsIm9wdGlvbnMiLCJlbmhhbmNlZE9wdGlvbnMiLCJmZXRjaCIsImdldENvcnJlbGF0aW9uSGVhZGVycyIsInNldEludGVydmFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/correlation-id.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/health-monitoring-simple.ts":
/*!*********************************************!*\
  !*** ./src/lib/health-monitoring-simple.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   healthMonitoring: () => (/* binding */ healthMonitoring)\n/* harmony export */ });\n/* harmony import */ var _correlation_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./correlation-id */ \"(rsc)/./src/lib/correlation-id.ts\");\n\n// Default health check configurations\nconst DEFAULT_HEALTH_CHECKS = [\n    {\n        name: 'system',\n        endpoint: 'internal',\n        timeout: 5000,\n        critical: false,\n        retries: 2\n    },\n    // Remove frontend self-check to avoid circular dependency\n    // The frontend health is determined by the overall API response\n    {\n        name: 'backend-api',\n        endpoint: process.env.NEXT_PUBLIC_HEALTH_API_URL || 'http://localhost:8000/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3,\n        method: 'GET'\n    }\n];\n// Health monitoring service\nclass HealthMonitoringService {\n    // Run a single health check\n    async runHealthCheck(config) {\n        const startTime = Date.now();\n        const correlationId = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()?.correlationId;\n        try {\n            let result;\n            if (config.endpoint === 'internal') {\n                // Internal system check\n                result = await this.runInternalHealthCheck(config);\n            } else {\n                // External endpoint check\n                result = await this.runExternalHealthCheck(config);\n            }\n            // Add correlation ID to result\n            if (correlationId) {\n                result.correlationId = correlationId;\n            }\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString(),\n                correlationId\n            };\n        }\n    }\n    // Run internal health check\n    async runInternalHealthCheck(config) {\n        const startTime = Date.now();\n        try {\n            // Check system resources\n            const systemInfo = await this.getSystemInfo();\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'pass',\n                responseTime,\n                details: systemInfo,\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Run external health check\n    async runExternalHealthCheck(config) {\n        const startTime = Date.now();\n        let lastError = null;\n        // Try with retries\n        for(let attempt = 1; attempt <= config.retries; attempt++){\n            try {\n                const headers = {\n                    ...(0,_correlation_id__WEBPACK_IMPORTED_MODULE_0__.getCorrelationHeaders)(),\n                    ...config.headers,\n                    'User-Agent': 'Health-Monitor/1.0'\n                };\n                const controller = new AbortController();\n                const timeoutId = setTimeout(()=>controller.abort(), config.timeout);\n                const response = await fetch(config.endpoint, {\n                    method: config.method || 'HEAD',\n                    headers,\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                const responseTime = Date.now() - startTime;\n                if (config.expectedStatus && response.status !== config.expectedStatus) {\n                    throw new Error(`Expected status ${config.expectedStatus}, got ${response.status}`);\n                }\n                return {\n                    status: response.status < 400 ? 'pass' : response.status < 500 ? 'warn' : 'fail',\n                    responseTime,\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText,\n                        headers: Object.fromEntries(response.headers.entries())\n                    },\n                    timestamp: new Date().toISOString()\n                };\n            } catch (error) {\n                lastError = error instanceof Error ? error : new Error(String(error));\n                // If this is the last attempt, throw the error\n                if (attempt === config.retries) {\n                    break;\n                }\n                // Wait before retry (exponential backoff)\n                await new Promise((resolve)=>setTimeout(resolve, Math.pow(2, attempt) * 100));\n            }\n        }\n        const responseTime = Date.now() - startTime;\n        throw lastError || new Error('Health check failed after all retries');\n    }\n    // Get system information\n    async getSystemInfo() {\n        if (true) {\n            // Server-side\n            return {\n                platform: 'server',\n                timestamp: new Date().toISOString()\n            };\n        }\n        // Client-side\n        return {\n            platform: 'browser',\n            userAgent: navigator.userAgent,\n            language: navigator.language,\n            cookieEnabled: navigator.cookieEnabled,\n            onLine: navigator.onLine,\n            timestamp: new Date().toISOString()\n        };\n    }\n    // Run comprehensive health check\n    async runComprehensiveHealthCheck() {\n        const startTime = Date.now();\n        const correlationId = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()?.correlationId;\n        // Generate correlation context for this health check\n        const healthCheckContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.generateContext(correlationId, undefined, undefined, undefined, {\n            operation: 'health_check',\n            type: 'comprehensive'\n        });\n        try {\n            const checkResults = {};\n            const checkPromises = DEFAULT_HEALTH_CHECKS.map(async (config)=>{\n                const result = await this.runHealthCheck(config);\n                checkResults[config.name] = result;\n                return result;\n            });\n            await Promise.allSettled(checkPromises);\n            // Calculate summary\n            const summary = this.calculateHealthSummary(checkResults);\n            // Determine overall status\n            let status = 'healthy';\n            if (summary.failedChecks > 0) {\n                status = 'unhealthy';\n            } else if (summary.warningChecks > 0 || summary.overallHealth < 90) {\n                status = 'degraded';\n            }\n            const result = {\n                status,\n                timestamp: new Date().toISOString(),\n                checks: checkResults,\n                summary,\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Add to history\n            this.healthHistory.push(result);\n            if (this.healthHistory.length > 100) {\n                this.healthHistory = this.healthHistory.slice(-100);\n            }\n            // Update metrics\n            this.updateMetrics(result);\n            // Log correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'info');\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            // Create error result\n            const errorResult = {\n                status: 'unhealthy',\n                timestamp: new Date().toISOString(),\n                checks: {},\n                summary: {\n                    overallHealth: 0,\n                    totalChecks: 0,\n                    passedChecks: 0,\n                    failedChecks: 1,\n                    warningChecks: 0,\n                    averageResponseTime: responseTime\n                },\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Log error with correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'error');\n            return errorResult;\n        } finally{\n            // Clear the health check context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.clearCurrentContext();\n        }\n    }\n    // Calculate health summary\n    calculateHealthSummary(checks) {\n        const checkArray = Object.values(checks);\n        const totalChecks = checkArray.length;\n        const passedChecks = checkArray.filter((c)=>c.status === 'pass').length;\n        const failedChecks = checkArray.filter((c)=>c.status === 'fail').length;\n        const warningChecks = checkArray.filter((c)=>c.status === 'warn').length;\n        const overallHealth = totalChecks > 0 ? passedChecks / totalChecks * 100 : 0;\n        const averageResponseTime = checkArray.length > 0 ? checkArray.reduce((sum, c)=>sum + c.responseTime, 0) / checkArray.length : 0;\n        return {\n            overallHealth: Math.round(overallHealth),\n            totalChecks,\n            passedChecks,\n            failedChecks,\n            warningChecks,\n            averageResponseTime: Math.round(averageResponseTime)\n        };\n    }\n    // Update metrics history\n    updateMetrics(healthResult) {\n        const metrics = {\n            overallScore: healthResult.summary.overallHealth,\n            errorRate: healthResult.summary.failedChecks / healthResult.summary.totalChecks,\n            responseTime: healthResult.summary.averageResponseTime,\n            uptime: healthResult.status === 'healthy' ? 100 : healthResult.status === 'degraded' ? 75 : 0,\n            lastCheck: healthResult.timestamp\n        };\n        this.metricsHistory.push(metrics);\n        if (this.metricsHistory.length > 1000) {\n            this.metricsHistory = this.metricsHistory.slice(-1000);\n        }\n    }\n    // Get health history\n    getHealthHistory() {\n        return [\n            ...this.healthHistory\n        ];\n    }\n    // Get metrics history\n    getMetricsHistory() {\n        return [\n            ...this.metricsHistory\n        ];\n    }\n    // Start monitoring\n    startMonitoring(intervalMs = 30000) {\n        if (this.isMonitoring) return;\n        this.isMonitoring = true;\n        this.monitoringInterval = setInterval(async ()=>{\n            try {\n                await this.runComprehensiveHealthCheck();\n            } catch (error) {\n                console.error('Health monitoring error:', error);\n            }\n        }, intervalMs);\n        console.log('Health monitoring started with interval:', intervalMs, 'ms');\n    }\n    // Stop monitoring\n    stopMonitoring() {\n        if (this.monitoringInterval) {\n            clearInterval(this.monitoringInterval);\n            this.monitoringInterval = null;\n        }\n        this.isMonitoring = false;\n        console.log('Health monitoring stopped');\n    }\n    // Get current health\n    getCurrentHealth() {\n        return this.healthHistory.length > 0 ? this.healthHistory[this.healthHistory.length - 1] : null;\n    }\n    // Check if monitoring is active\n    isMonitoringActive() {\n        return this.isMonitoring;\n    }\n    // Get monitoring status\n    getMonitoringStatus() {\n        return {\n            isActive: this.isMonitoring,\n            interval: this.monitoringInterval ? 30000 : null\n        };\n    }\n    constructor(){\n        this.healthHistory = [];\n        this.metricsHistory = [];\n        this.isMonitoring = false;\n        this.monitoringInterval = null;\n    }\n}\n// Export singleton instance\nconst healthMonitoring = new HealthMonitoringService();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2hlYWx0aC1tb25pdG9yaW5nLXNpbXBsZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4RTtBQTJEOUUsc0NBQXNDO0FBQ3RDLE1BQU1FLHdCQUE2QztJQUNqRDtRQUNFQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUNBLDBEQUEwRDtJQUMxRCxnRUFBZ0U7SUFDaEU7UUFDRUosTUFBTTtRQUNOQyxVQUFVSSxRQUFRQyxHQUFHLENBQUNDLDBCQUEwQixJQUFJO1FBQ3BETCxTQUFTO1FBQ1RNLGdCQUFnQjtRQUNoQkwsVUFBVTtRQUNWQyxTQUFTO1FBQ1RLLFFBQVE7SUFDVjtDQUNEO0FBRUQsNEJBQTRCO0FBQzVCLE1BQU1DO0lBTUosNEJBQTRCO0lBQzVCLE1BQU1DLGVBQWVDLE1BQXlCLEVBQThCO1FBQzFFLE1BQU1DLFlBQVlDLEtBQUtDLEdBQUc7UUFDMUIsTUFBTUMsZ0JBQWdCbkIsaUVBQW9CQSxDQUFDb0IsaUJBQWlCLElBQUlEO1FBRWhFLElBQUk7WUFDRixJQUFJRTtZQUVKLElBQUlOLE9BQU9YLFFBQVEsS0FBSyxZQUFZO2dCQUNsQyx3QkFBd0I7Z0JBQ3hCaUIsU0FBUyxNQUFNLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNQO1lBQzdDLE9BQU87Z0JBQ0wsMEJBQTBCO2dCQUMxQk0sU0FBUyxNQUFNLElBQUksQ0FBQ0Usc0JBQXNCLENBQUNSO1lBQzdDO1lBRUEsK0JBQStCO1lBQy9CLElBQUlJLGVBQWU7Z0JBQ2pCRSxPQUFPRixhQUFhLEdBQUdBO1lBQ3pCO1lBRUEsT0FBT0U7UUFDVCxFQUFFLE9BQU9HLE9BQU87WUFDZCxNQUFNQyxlQUFlUixLQUFLQyxHQUFHLEtBQUtGO1lBQ2xDLE9BQU87Z0JBQ0xVLFFBQVE7Z0JBQ1JEO2dCQUNBRCxPQUFPQSxpQkFBaUJHLFFBQVFILE1BQU1JLE9BQU8sR0FBR0MsT0FBT0w7Z0JBQ3ZETSxXQUFXLElBQUliLE9BQU9jLFdB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LGFBQWEsQ0FBQ0UsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM3RjtJQUVBLGdDQUFnQztJQUNoQ21DLHFCQUE4QjtRQUM1QixPQUFPLElBQUksQ0FBQ1IsWUFBWTtJQUMxQjtJQUVBLHdCQUF3QjtJQUN4QlMsc0JBQXNFO1FBQ3BFLE9BQU87WUFDTEMsVUFBVSxJQUFJLENBQUNWLFlBQVk7WUFDM0JXLFVBQVUsSUFBSSxDQUFDVixrQkFBa0IsR0FBRyxRQUFRO1FBQzlDO0lBQ0Y7O2FBL1VROUIsZ0JBQWdDLEVBQUU7YUFDbEN3QixpQkFBdUMsRUFBRTthQUN6Q0ssZUFBd0I7YUFDeEJDLHFCQUE0Qzs7QUE2VXREO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1XLG1CQUFtQixJQUFJL0csMEJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvbGliL2hlYWx0aC1tb25pdG9yaW5nLXNpbXBsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb3JyZWxhdGlvbklETWFuYWdlciwgZ2V0Q29ycmVsYXRpb25IZWFkZXJzIH0gZnJvbSAnLi9jb3JyZWxhdGlvbi1pZCdcblxuLy8gSGVhbHRoIGNoZWNrIGNvbmZpZ3VyYXRpb24gaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrQ29uZmlnIHtcbiAgbmFtZTogc3RyaW5nXG4gIGVuZHBvaW50OiBzdHJpbmdcbiAgdGltZW91dDogbnVtYmVyXG4gIGV4cGVjdGVkU3RhdHVzPzogbnVtYmVyXG4gIGNyaXRpY2FsOiBib29sZWFuXG4gIHJldHJpZXM6IG51bWJlclxuICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBtZXRob2Q/OiAnR0VUJyB8ICdIRUFEJyAvLyBBZGRlZCBtZXRob2QgZm9yIGJhY2tlbmQgY2hlY2tzXG59XG5cbi8vIEhlYWx0aCBjaGVjayByZXN1bHQgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrUmVzdWx0IHtcbiAgc3RhdHVzOiAncGFzcycgfCAnd2FybicgfCAnZmFpbCdcbiAgcmVzcG9uc2VUaW1lOiBudW1iZXJcbiAgZXJyb3I/OiBzdHJpbmdcbiAgZGV0YWlscz86IGFueVxuICB0aW1lc3RhbXA6IHN0cmluZ1xuICBjb3JyZWxhdGlvbklkPzogc3RyaW5nXG59XG5cbi8vIEhlYWx0aCBpbmRleCBtZXRyaWNzIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhJbmRleE1ldHJpY3Mge1xuICBvdmVyYWxsU2NvcmU6IG51bWJlclxuICBlcnJvclJhdGU6IG51bWJlclxuICByZXNwb25zZVRpbWU6IG51bWJlclxuICB1cHRpbWU6IG51bWJlclxuICBsYXN0Q2hlY2s6IHN0cmluZ1xufVxuXG4vLyBIZWFsdGggc3VtbWFyeSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoU3VtbWFyeSB7XG4gIG92ZXJhbGxIZWFsdGg6IG51bWJlclxuICB0b3RhbENoZWNrczogbnVtYmVyXG4gIHBhc3NlZENoZWNrczogbnVtYmVyXG4gIGZhaWxlZENoZWNrczogbnVtYmVyXG4gIHdhcm5pbmdDaGVja3M6IG51bWJlclxuICBhdmVyYWdlUmVzcG9uc2VUaW1lOiBudW1iZXJcbn1cblxuLy8gSGVhbHRoIHJlc3VsdCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoUmVzdWx0IHtcbiAgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeSdcbiAgdGltZXN0YW1wOiBzdHJpbmdcbiAgY2hlY2tzOiBSZWNvcmQ8c3RyaW5nLCBIZWFsdGhDaGVja1Jlc3VsdD5cbiAgc3VtbWFyeTogSGVhbHRoU3VtbWFyeVxuICBtZXRhZGF0YToge1xuICAgIHNlcnZpY2U6IHN0cmluZ1xuICAgIHJlZ2lvbjogc3RyaW5nXG4gICAgaW5zdGFuY2U6IHN0cmluZ1xuICAgIGJ1aWxkOiBzdHJpbmdcbiAgICBjb21taXQ6IHN0cmluZ1xuICAgIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmdcbiAgfVxufVxuXG4vLyBEZWZhdWx0IGhlYWx0aCBjaGVjayBjb25maWd1cmF0aW9uc1xuY29uc3QgREVGQVVMVF9IRUFMVEhfQ0hFQ0tTOiBIZWFsdGhDaGVja0NvbmZpZ1tdID0gW1xuICB7XG4gICAgbmFtZTogJ3N5c3RlbScsXG4gICAgZW5kcG9pbnQ6ICdpbnRlcm5hbCcsIC8vIFNwZWNpYWwgY2FzZSBmb3Igc3lzdGVtIGNoZWNrc1xuICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgY3JpdGljYWw6IGZhbHNlLFxuICAgIHJldHJpZXM6IDIsXG4gIH0sXG4gIC8vIFJlbW92ZSBmcm9udGVuZCBzZWxmLWNoZWNrIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3lcbiAgLy8gVGhlIGZyb250ZW5kIGhlYWx0aCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvdmVyYWxsIEFQSSByZXNwb25zZVxuICB7XG4gICAgbmFtZTogJ2JhY2tlbmQtYXBpJyxcbiAgICBlbmRwb2ludDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfSEVBTFRIX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9oZWFsdGgnLFxuICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAgZXhwZWN0ZWRTdGF0dXM6IDIwMCxcbiAgICBjcml0aWNhbDogdHJ1ZSxcbiAgICByZXRyaWVzOiAzLFxuICAgIG1ldGhvZDogJ0dFVCcsIC8vIFVzZSBHRVQgaW5zdGVhZCBvZiBIRUFEIGZvciBiYWNrZW5kXG4gIH0sXG5dXG5cbi8vIEhlYWx0aCBtb25pdG9yaW5nIHNlcnZpY2VcbmNsYXNzIEhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBoZWFsdGhIaXN0b3J5OiBIZWFsdGhSZXN1bHRbXSA9IFtdXG4gIHByaXZhdGUgbWV0cmljc0hpc3Rvcnk6IEhlYWx0aEluZGV4TWV0cmljc1tdID0gW11cbiAgcHJpdmF0ZSBpc01vbml0b3Jpbmc6IGJvb2xlYW4gPSBmYWxzZVxuICBwcml2YXRlIG1vbml0b3JpbmdJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuXG4gIC8vIFJ1biBhIHNpbmdsZSBoZWFsdGggY2hlY2tcbiAgYXN5bmMgcnVuSGVhbHRoQ2hlY2soY29uZmlnOiBIZWFsdGhDaGVja0NvbmZpZyk6IFByb21pc2U8SGVhbHRoQ2hlY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk/LmNvcnJlbGF0aW9uSWRcblxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzdWx0OiBIZWFsdGhDaGVja1Jlc3VsdFxuXG4gICAgICBpZiAoY29uZmlnLmVuZHBvaW50ID09PSAnaW50ZXJuYWwnKSB7XG4gICAgICAgIC8vIEludGVybmFsIHN5c3RlbSBjaGVja1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkludGVybmFsSGVhbHRoQ2hlY2soY29uZmlnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXh0ZXJuYWwgZW5kcG9pbnQgY2hlY2tcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5FeHRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZylcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNvcnJlbGF0aW9uIElEIHRvIHJlc3VsdFxuICAgICAgaWYgKGNvcnJlbGF0aW9uSWQpIHtcbiAgICAgICAgcmVzdWx0LmNvcnJlbGF0aW9uSWQgPSBjb3JyZWxhdGlvbklkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnZmFpbCcsXG4gICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSdW4gaW50ZXJuYWwgaGVhbHRoIGNoZWNrXG4gIHByaXZhdGUgYXN5bmMgcnVuSW50ZXJuYWxIZWFsdGhDaGVjayhjb25maWc6IEhlYWx0aENoZWNrQ29uZmlnKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgc3lzdGVtIHJlc291cmNlc1xuICAgICAgY29uc3Qgc3lzdGVtSW5mbyA9IGF3YWl0IHRoaXMuZ2V0U3lzdGVtSW5mbygpXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAncGFzcycsXG4gICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgZGV0YWlsczogc3lzdGVtSW5mbyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnZmFpbCcsXG4gICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSdW4gZXh0ZXJuYWwgaGVhbHRoIGNoZWNrXG4gIHByaXZhdGUgYXN5bmMgcnVuRXh0ZXJuYWxIZWFsdGhDaGVjayhjb25maWc6IEhlYWx0aENoZWNrQ29uZmlnKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsXG5cbiAgICAvLyBUcnkgd2l0aCByZXRyaWVzXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gY29uZmlnLnJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAuLi5nZXRDb3JyZWxhdGlvbkhlYWRlcnMoKSxcbiAgICAgICAgICAuLi5jb25maWcuaGVhZGVycyxcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdIZWFsdGgtTW9uaXRvci8xLjAnXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBjb25maWcudGltZW91dClcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGNvbmZpZy5lbmRwb2ludCwge1xuICAgICAgICAgIG1ldGhvZDogY29uZmlnLm1ldGhvZCB8fCAnSEVBRCcsIC8vIFVzZSBtZXRob2QgZnJvbSBjb25maWcgb3IgZGVmYXVsdCB0byBIRUFEXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG5cbiAgICAgICAgaWYgKGNvbmZpZy5leHBlY3RlZFN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMgIT09IGNvbmZpZy5leHBlY3RlZFN0YXR1cykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3RhdHVzICR7Y29uZmlnLmV4cGVjdGVkU3RhdHVzfSwgZ290ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIDwgNDAwID8gJ3Bhc3MnIDogcmVzcG9uc2Uuc3RhdHVzIDwgNTAwID8gJ3dhcm4nIDogJ2ZhaWwnLFxuICAgICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgYXR0ZW1wdCwgdGhyb3cgdGhlIGVycm9yXG4gICAgICAgIGlmIChhdHRlbXB0ID09PSBjb25maWcucmV0cmllcykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeSAoZXhwb25lbnRpYWwgYmFja29mZilcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucG93KDIsIGF0dGVtcHQpICogMTAwKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignSGVhbHRoIGNoZWNrIGZhaWxlZCBhZnRlciBhbGwgcmV0cmllcycpXG4gIH1cblxuICAvLyBHZXQgc3lzdGVtIGluZm9ybWF0aW9uXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3lzdGVtSW5mbygpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gU2VydmVyLXNpZGVcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYXRmb3JtOiAnc2VydmVyJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGllbnQtc2lkZVxuICAgIHJldHVybiB7XG4gICAgICBwbGF0Zm9ybTogJ2Jyb3dzZXInLFxuICAgICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbGFuZ3VhZ2U6IG5hdmlnYXRvci5sYW5ndWFnZSxcbiAgICAgIGNvb2tpZUVuYWJsZWQ6IG5hdmlnYXRvci5jb29raWVFbmFibGVkLFxuICAgICAgb25MaW5lOiBuYXZpZ2F0b3Iub25MaW5lLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9XG4gIH1cblxuICAvLyBSdW4gY29tcHJlaGVuc2l2ZSBoZWFsdGggY2hlY2tcbiAgYXN5bmMgcnVuQ29tcHJlaGVuc2l2ZUhlYWx0aENoZWNrKCk6IFByb21pc2U8SGVhbHRoUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSBjb3JyZWxhdGlvbklETWFuYWdlci5nZXRDdXJyZW50Q29udGV4dCgpPy5jb3JyZWxhdGlvbklkXG5cbiAgICAvLyBHZW5lcmF0ZSBjb3JyZWxhdGlvbiBjb250ZXh0IGZvciB0aGlzIGhlYWx0aCBjaGVja1xuICAgIGNvbnN0IGhlYWx0aENoZWNrQ29udGV4dCA9IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdlbmVyYXRlQ29udGV4dChcbiAgICAgIGNvcnJlbGF0aW9uSWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB7IG9wZXJhdGlvbjogJ2hlYWx0aF9jaGVjaycsIHR5cGU6ICdjb21wcmVoZW5zaXZlJyB9XG4gICAgKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNoZWNrUmVzdWx0czogUmVjb3JkPHN0cmluZywgSGVhbHRoQ2hlY2tSZXN1bHQ+ID0ge31cbiAgICAgIGNvbnN0IGNoZWNrUHJvbWlzZXMgPSBERUZBVUxUX0hFQUxUSF9DSEVDS1MubWFwKGFzeW5jIChjb25maWcpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5IZWFsdGhDaGVjayhjb25maWcpXG4gICAgICAgIGNoZWNrUmVzdWx0c1tjb25maWcubmFtZV0gPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNoZWNrUHJvbWlzZXMpXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdW1tYXJ5XG4gICAgICBjb25zdCBzdW1tYXJ5ID0gdGhpcy5jYWxjdWxhdGVIZWFsdGhTdW1tYXJ5KGNoZWNrUmVzdWx0cylcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIG92ZXJhbGwgc3RhdHVzXG4gICAgICBsZXQgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeScgPSAnaGVhbHRoeSdcbiAgICAgIGlmIChzdW1tYXJ5LmZhaWxlZENoZWNrcyA+IDApIHtcbiAgICAgICAgc3RhdHVzID0gJ3VuaGVhbHRoeSdcbiAgICAgIH0gZWxzZSBpZiAoc3VtbWFyeS53YXJuaW5nQ2hlY2tzID4gMCB8fCBzdW1tYXJ5Lm92ZXJhbGxIZWFsdGggPCA5MCkge1xuICAgICAgICBzdGF0dXMgPSAnZGVncmFkZWQnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogSGVhbHRoUmVzdWx0ID0ge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjaGVja3M6IGNoZWNrUmVzdWx0cyxcbiAgICAgICAgc3VtbWFyeSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBzZXJ2aWNlOiAnQUkgU2FhUyBGYWN0b3J5IC0gTmV4dC5qcyBGcm9udGVuZCcsXG4gICAgICAgICAgcmVnaW9uOiAnbG9jYWwnLFxuICAgICAgICAgIGluc3RhbmNlOiAnbG9jYWxob3N0JyxcbiAgICAgICAgICBidWlsZDogJ2xvY2FsJyxcbiAgICAgICAgICBjb21taXQ6ICdsb2NhbCcsXG4gICAgICAgICAgY29ycmVsYXRpb25JZDogaGVhbHRoQ2hlY2tDb250ZXh0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdG8gaGlzdG9yeVxuICAgICAgdGhpcy5oZWFsdGhIaXN0b3J5LnB1c2gocmVzdWx0KVxuICAgICAgaWYgKHRoaXMuaGVhbHRoSGlzdG9yeS5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgdGhpcy5oZWFsdGhIaXN0b3J5ID0gdGhpcy5oZWFsdGhIaXN0b3J5LnNsaWNlKC0xMDApXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBtZXRyaWNzXG4gICAgICB0aGlzLnVwZGF0ZU1ldHJpY3MocmVzdWx0KVxuXG4gICAgICAvLyBMb2cgY29ycmVsYXRpb24gY29udGV4dFxuICAgICAgY29ycmVsYXRpb25JRE1hbmFnZXIubG9nQ29udGV4dChoZWFsdGhDaGVja0NvbnRleHQsICdpbmZvJylcblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBlcnJvciByZXN1bHRcbiAgICAgIGNvbnN0IGVycm9yUmVzdWx0OiBIZWFsdGhSZXN1bHQgPSB7XG4gICAgICAgIHN0YXR1czogJ3VuaGVhbHRoeScsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjaGVja3M6IHt9LFxuICAgICAgICBzdW1tYXJ5OiB7XG4gICAgICAgICAgb3ZlcmFsbEhlYWx0aDogMCxcbiAgICAgICAgICB0b3RhbENoZWNrczogMCxcbiAgICAgICAgICBwYXNzZWRDaGVja3M6IDAsXG4gICAgICAgICAgZmFpbGVkQ2hlY2tzOiAxLFxuICAgICAgICAgIHdhcm5pbmdDaGVja3M6IDAsXG4gICAgICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogcmVzcG9uc2VUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgc2VydmljZTogJ0FJIFNhYVMgRmFjdG9yeSAtIE5leHQuanMgRnJvbnRlbmQnLFxuICAgICAgICAgIHJlZ2lvbjogJ2xvY2FsJyxcbiAgICAgICAgICBpbnN0YW5jZTogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgYnVpbGQ6ICdsb2NhbCcsXG4gICAgICAgICAgY29tbWl0OiAnbG9jYWwnLFxuICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGhlYWx0aENoZWNrQ29udGV4dC5jb3JyZWxhdGlvbklkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTG9nIGVycm9yIHdpdGggY29ycmVsYXRpb24gY29udGV4dFxuICAgICAgY29ycmVsYXRpb25JRE1hbmFnZXIubG9nQ29udGV4dChoZWFsdGhDaGVja0NvbnRleHQsICdlcnJvcicpXG4gICAgICBcbiAgICAgIHJldHVybiBlcnJvclJlc3VsdFxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBDbGVhciB0aGUgaGVhbHRoIGNoZWNrIGNvbnRleHRcbiAgICAgIGNvcnJlbGF0aW9uSURNYW5hZ2VyLmNsZWFyQ3VycmVudENvbnRleHQoKVxuICAgIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBoZWFsdGggc3VtbWFyeVxuICBwcml2YXRlIGNhbGN1bGF0ZUhlYWx0aFN1bW1hcnkoY2hlY2tzOiBSZWNvcmQ8c3RyaW5nLCBIZWFsdGhDaGVja1Jlc3VsdD4pOiBIZWFsdGhTdW1tYXJ5IHtcbiAgICBjb25zdCBjaGVja0FycmF5ID0gT2JqZWN0LnZhbHVlcyhjaGVja3MpXG4gICAgY29uc3QgdG90YWxDaGVja3MgPSBjaGVja0FycmF5Lmxlbmd0aFxuICAgIGNvbnN0IHBhc3NlZENoZWNrcyA9IGNoZWNrQXJyYXkuZmlsdGVyKGMgPT4gYy5zdGF0dXMgPT09ICdwYXNzJykubGVuZ3RoXG4gICAgY29uc3QgZmFpbGVkQ2hlY2tzID0gY2hlY2tBcnJheS5maWx0ZXIoYyA9PiBjLnN0YXR1cyA9PT0gJ2ZhaWwnKS5sZW5ndGhcbiAgICBjb25zdCB3YXJuaW5nQ2hlY2tzID0gY2hlY2tBcnJheS5maWx0ZXIoYyA9PiBjLnN0YXR1cyA9PT0gJ3dhcm4nKS5sZW5ndGhcblxuICAgIGNvbnN0IG92ZXJhbGxIZWFsdGggPSB0b3RhbENoZWNrcyA+IDAgPyAocGFzc2VkQ2hlY2tzIC8gdG90YWxDaGVja3MpICogMTAwIDogMFxuICAgIGNvbnN0IGF2ZXJhZ2VSZXNwb25zZVRpbWUgPSBjaGVja0FycmF5Lmxlbmd0aCA+IDAgXG4gICAgICA/IGNoZWNrQXJyYXkucmVkdWNlKChzdW0sIGMpID0+IHN1bSArIGMucmVzcG9uc2VUaW1lLCAwKSAvIGNoZWNrQXJyYXkubGVuZ3RoIFxuICAgICAgOiAwXG5cbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmFsbEhlYWx0aDogTWF0aC5yb3VuZChvdmVyYWxsSGVhbHRoKSxcbiAgICAgIHRvdGFsQ2hlY2tzLFxuICAgICAgcGFzc2VkQ2hlY2tzLFxuICAgICAgZmFpbGVkQ2hlY2tzLFxuICAgICAgd2FybmluZ0NoZWNrcyxcbiAgICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IE1hdGgucm91bmQoYXZlcmFnZVJlc3BvbnNlVGltZSlcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgbWV0cmljcyBoaXN0b3J5XG4gIHByaXZhdGUgdXBkYXRlTWV0cmljcyhoZWFsdGhSZXN1bHQ6IEhlYWx0aFJlc3VsdCk6IHZvaWQge1xuICAgIGNvbnN0IG1ldHJpY3M6IEhlYWx0aEluZGV4TWV0cmljcyA9IHtcbiAgICAgIG92ZXJhbGxTY29yZTogaGVhbHRoUmVzdWx0LnN1bW1hcnkub3ZlcmFsbEhlYWx0aCxcbiAgICAgIGVycm9yUmF0ZTogaGVhbHRoUmVzdWx0LnN1bW1hcnkuZmFpbGVkQ2hlY2tzIC8gaGVhbHRoUmVzdWx0LnN1bW1hcnkudG90YWxDaGVja3MsXG4gICAgICByZXNwb25zZVRpbWU6IGhlYWx0aFJlc3VsdC5zdW1tYXJ5LmF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gICAgICB1cHRpbWU6IGhlYWx0aFJlc3VsdC5zdGF0dXMgPT09ICdoZWFsdGh5JyA/IDEwMCA6IGhlYWx0aFJlc3VsdC5zdGF0dXMgPT09ICdkZWdyYWRlZCcgPyA3NSA6IDAsXG4gICAgICBsYXN0Q2hlY2s6IGhlYWx0aFJlc3VsdC50aW1lc3RhbXBcbiAgICB9XG5cbiAgICB0aGlzLm1ldHJpY3NIaXN0b3J5LnB1c2gobWV0cmljcylcbiAgICBpZiAodGhpcy5tZXRyaWNzSGlzdG9yeS5sZW5ndGggPiAxMDAwKSB7XG4gICAgICB0aGlzLm1ldHJpY3NIaXN0b3J5ID0gdGhpcy5tZXRyaWNzSGlzdG9yeS5zbGljZSgtMTAwMClcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgaGVhbHRoIGhpc3RvcnlcbiAgZ2V0SGVhbHRoSGlzdG9yeSgpOiBIZWFsdGhSZXN1bHRbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmhlYWx0aEhpc3RvcnldXG4gIH1cblxuICAvLyBHZXQgbWV0cmljcyBoaXN0b3J5XG4gIGdldE1ldHJpY3NIaXN0b3J5KCk6IEhlYWx0aEluZGV4TWV0cmljc1tdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubWV0cmljc0hpc3RvcnldXG4gIH1cblxuICAvLyBTdGFydCBtb25pdG9yaW5nXG4gIHN0YXJ0TW9uaXRvcmluZyhpbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzTW9uaXRvcmluZykgcmV0dXJuXG5cbiAgICB0aGlzLmlzTW9uaXRvcmluZyA9IHRydWVcbiAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ29tcHJlaGVuc2l2ZUhlYWx0aENoZWNrKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0hlYWx0aCBtb25pdG9yaW5nIGVycm9yOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0sIGludGVydmFsTXMpXG5cbiAgICBjb25zb2xlLmxvZygnSGVhbHRoIG1vbml0b3Jpbmcgc3RhcnRlZCB3aXRoIGludGVydmFsOicsIGludGVydmFsTXMsICdtcycpXG4gIH1cblxuICAvLyBTdG9wIG1vbml0b3JpbmdcbiAgc3RvcE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKVxuICAgICAgdGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuICAgIHRoaXMuaXNNb25pdG9yaW5nID0gZmFsc2VcbiAgICBjb25zb2xlLmxvZygnSGVhbHRoIG1vbml0b3Jpbmcgc3RvcHBlZCcpXG4gIH1cblxuICAvLyBHZXQgY3VycmVudCBoZWFsdGhcbiAgZ2V0Q3VycmVudEhlYWx0aCgpOiBIZWFsdGhSZXN1bHQgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5oZWFsdGhIaXN0b3J5Lmxlbmd0aCA+IDAgPyB0aGlzLmhlYWx0aEhpc3RvcnlbdGhpcy5oZWFsdGhIaXN0b3J5Lmxlbmd0aCAtIDFdIDogbnVsbFxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgbW9uaXRvcmluZyBpcyBhY3RpdmVcbiAgaXNNb25pdG9yaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzTW9uaXRvcmluZ1xuICB9XG5cbiAgLy8gR2V0IG1vbml0b3Jpbmcgc3RhdHVzXG4gIGdldE1vbml0b3JpbmdTdGF0dXMoKTogeyBpc0FjdGl2ZTogYm9vbGVhbjsgaW50ZXJ2YWw6IG51bWJlciB8IG51bGwgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmlzTW9uaXRvcmluZyxcbiAgICAgIGludGVydmFsOiB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA/IDMwMDAwIDogbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgaGVhbHRoTW9uaXRvcmluZyA9IG5ldyBIZWFsdGhNb25pdG9yaW5nU2VydmljZSgpXG5cbi8vIEV4cG9ydCB0eXBlc1xuZXhwb3J0IHR5cGUge1xuICBIZWFsdGhDaGVja0NvbmZpZyxcbiAgSGVhbHRoQ2hlY2tSZXN1bHQsXG4gIEhlYWx0aEluZGV4TWV0cmljcyxcbiAgSGVhbHRoU3VtbWFyeSxcbiAgSGVhbHRoUmVzdWx0XG59XG4iXSwibmFtZXMiOlsiY29ycmVsYXRpb25JRE1hbmFnZXIiLCJnZXRDb3JyZWxhdGlvbkhlYWRlcnMiLCJERUZBVUxUX0hFQUxUSF9DSEVDS1MiLCJuYW1lIiwiZW5kcG9pbnQiLCJ0aW1lb3V0IiwiY3JpdGljYWwiLCJyZXRyaWVzIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0hFQUxUSF9BUElfVVJMIiwiZXhwZWN0ZWRTdGF0dXMiLCJtZXRob2QiLCJIZWFsdGhNb25pdG9yaW5nU2VydmljZSIsInJ1bkhlYWx0aENoZWNrIiwiY29uZmlnIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImNvcnJlbGF0aW9uSWQiLCJnZXRDdXJyZW50Q29udGV4dCIsInJlc3VsdCIsInJ1bkludGVybmFsSGVhbHRoQ2hlY2siLCJydW5FeHRlcm5hbEhlYWx0aENoZWNrIiwiZXJyb3IiLCJyZXNwb25zZVRpbWUiLCJzdGF0dXMiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInN5c3RlbUluZm8iLCJnZXRTeXN0ZW1JbmZvIiwiZGV0YWlscyIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJoZWFkZXJzIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJzdGF0dXNUZXh0IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJNYXRoIiwicG93IiwicGxhdGZvcm0iLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsImNvb2tpZUVuYWJsZWQiLCJvbkxpbmUiLCJydW5Db21wcmVoZW5zaXZlSGVhbHRoQ2hlY2siLCJoZWFsdGhDaGVja0NvbnRleHQiLCJnZW5lcmF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJvcGVyYXRpb24iLCJ0eXBlIiwiY2hlY2tSZXN1bHRzIiwiY2hlY2tQcm9taXNlcyIsIm1hcCIsImFsbFNldHRsZWQiLCJzdW1tYXJ5IiwiY2FsY3VsYXRlSGVhbHRoU3VtbWFyeSIsImZhaWxlZENoZWNrcyIsIndhcm5pbmdDaGVja3MiLCJvdmVyYWxsSGVhbHRoIiwiY2hlY2tzIiwibWV0YWRhdGEiLCJzZXJ2aWNlIiwicmVnaW9uIiwiaW5zdGFuY2UiLCJidWlsZCIsImNvbW1pdCIsImhlYWx0aEhpc3RvcnkiLCJwdXNoIiwibGVuZ3RoIiwic2xpY2UiLCJ1cGRhdGVNZXRyaWNzIiwibG9nQ29udGV4dCIsImVycm9yUmVzdWx0IiwidG90YWxDaGVja3MiLCJwYXNzZWRDaGVja3MiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwiY2xlYXJDdXJyZW50Q29udGV4dCIsImNoZWNrQXJyYXkiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJjIiwicmVkdWNlIiwic3VtIiwicm91bmQiLCJoZWFsdGhSZXN1bHQiLCJtZXRyaWNzIiwib3ZlcmFsbFNjb3JlIiwiZXJyb3JSYXRlIiwidXB0aW1lIiwibGFzdENoZWNrIiwibWV0cmljc0hpc3RvcnkiLCJnZXRIZWFsdGhIaXN0b3J5IiwiZ2V0TWV0cmljc0hpc3RvcnkiLCJzdGFydE1vbml0b3JpbmciLCJpbnRlcnZhbE1zIiwiaXNNb25pdG9yaW5nIiwibW9uaXRvcmluZ0ludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjb25zb2xlIiwibG9nIiwic3RvcE1vbml0b3JpbmciLCJjbGVhckludGVydmFsIiwiZ2V0Q3VycmVudEhlYWx0aCIsImlzTW9uaXRvcmluZ0FjdGl2ZSIsImdldE1vbml0b3JpbmdTdGF0dXMiLCJpc0FjdGl2ZSIsImludGVydmFsIiwiaGVhbHRoTW9uaXRvcmluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/health-monitoring-simple.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/action-async-storage.external":
/*!*******************************************************************************!*\
  !*** external "next/dist/server/app-render/action-async-storage.external.js" ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/action-async-storage.external.js");

/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "./work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "next/dist/shared/lib/no-fallback-error.external":
/*!******************************************************************!*\
  !*** external "next/dist/shared/lib/no-fallback-error.external" ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/no-fallback-error.external");

/***/ }),

/***/ "next/dist/shared/lib/router/utils/app-paths":
/*!**************************************************************!*\
  !*** external "next/dist/shared/lib/router/utils/app-paths" ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/app-paths");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@opentelemetry","vendor-chunks/uuid"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Fhealth%2Froute&page=%2Fapi%2Fhealth%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fhealth%2Froute.ts&appDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fmacmini%2FDocuments%2FProjects%2FSaaS%20Factory%2Fui%2Fnextjs&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D&isGlobalNotFoundEnabled=!")));
module.exports = __webpack_exports__;

})();