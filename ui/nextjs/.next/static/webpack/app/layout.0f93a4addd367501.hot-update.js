"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"18075e4c479f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMTgwNzVlNGM0NzlmXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/health-monitoring-simple.ts":
/*!*********************************************!*\
  !*** ./src/lib/health-monitoring-simple.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   healthMonitoring: () => (/* binding */ healthMonitoring)\n/* harmony export */ });\n/* harmony import */ var _correlation_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./correlation-id */ \"(app-pages-browser)/./src/lib/correlation-id.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Default health check configurations\nconst DEFAULT_HEALTH_CHECKS = [\n    {\n        name: 'system',\n        endpoint: 'internal',\n        timeout: 5000,\n        critical: false,\n        retries: 2\n    },\n    {\n        name: 'frontend',\n        endpoint:  false ? 0 // Server-side: use full URL\n         : '/api/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3\n    },\n    {\n        name: 'backend-api',\n        endpoint: process.env.NEXT_PUBLIC_HEALTH_API_URL || 'http://localhost:8000/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3\n    }\n];\n// Health monitoring service\nclass HealthMonitoringService {\n    // Run a single health check\n    async runHealthCheck(config) {\n        var _correlationIDManager_getCurrentContext;\n        const startTime = Date.now();\n        const correlationId = (_correlationIDManager_getCurrentContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()) === null || _correlationIDManager_getCurrentContext === void 0 ? void 0 : _correlationIDManager_getCurrentContext.correlationId;\n        try {\n            let result;\n            if (config.endpoint === 'internal') {\n                // Internal system check\n                result = await this.runInternalHealthCheck(config);\n            } else {\n                // External endpoint check\n                result = await this.runExternalHealthCheck(config);\n            }\n            // Add correlation ID to result\n            if (correlationId) {\n                result.correlationId = correlationId;\n            }\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString(),\n                correlationId\n            };\n        }\n    }\n    // Run internal health check\n    async runInternalHealthCheck(config) {\n        const startTime = Date.now();\n        try {\n            // Check system resources\n            const systemInfo = await this.getSystemInfo();\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'pass',\n                responseTime,\n                details: systemInfo,\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Run external health check\n    async runExternalHealthCheck(config) {\n        const startTime = Date.now();\n        let lastError = null;\n        // Try with retries\n        for(let attempt = 1; attempt <= config.retries; attempt++){\n            try {\n                const headers = {\n                    ...(0,_correlation_id__WEBPACK_IMPORTED_MODULE_0__.getCorrelationHeaders)(),\n                    ...config.headers,\n                    'User-Agent': 'Health-Monitor/1.0'\n                };\n                const controller = new AbortController();\n                const timeoutId = setTimeout(()=>controller.abort(), config.timeout);\n                const response = await fetch(config.endpoint, {\n                    method: 'HEAD',\n                    headers,\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                const responseTime = Date.now() - startTime;\n                if (config.expectedStatus && response.status !== config.expectedStatus) {\n                    throw new Error(\"Expected status \".concat(config.expectedStatus, \", got \").concat(response.status));\n                }\n                return {\n                    status: response.status < 400 ? 'pass' : response.status < 500 ? 'warn' : 'fail',\n                    responseTime,\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText,\n                        headers: Object.fromEntries(response.headers.entries())\n                    },\n                    timestamp: new Date().toISOString()\n                };\n            } catch (error) {\n                lastError = error instanceof Error ? error : new Error(String(error));\n                // If this is the last attempt, throw the error\n                if (attempt === config.retries) {\n                    break;\n                }\n                // Wait before retry (exponential backoff)\n                await new Promise((resolve)=>setTimeout(resolve, Math.pow(2, attempt) * 100));\n            }\n        }\n        const responseTime = Date.now() - startTime;\n        throw lastError || new Error('Health check failed after all retries');\n    }\n    // Get system information\n    async getSystemInfo() {\n        if (false) {}\n        // Client-side\n        return {\n            platform: 'browser',\n            userAgent: navigator.userAgent,\n            language: navigator.language,\n            cookieEnabled: navigator.cookieEnabled,\n            onLine: navigator.onLine,\n            timestamp: new Date().toISOString()\n        };\n    }\n    // Run comprehensive health check\n    async runComprehensiveHealthCheck() {\n        var _correlationIDManager_getCurrentContext;\n        const startTime = Date.now();\n        const correlationId = (_correlationIDManager_getCurrentContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()) === null || _correlationIDManager_getCurrentContext === void 0 ? void 0 : _correlationIDManager_getCurrentContext.correlationId;\n        // Generate correlation context for this health check\n        const healthCheckContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.generateContext(correlationId, undefined, undefined, undefined, {\n            operation: 'health_check',\n            type: 'comprehensive'\n        });\n        try {\n            const checkResults = {};\n            const checkPromises = DEFAULT_HEALTH_CHECKS.map(async (config)=>{\n                const result = await this.runHealthCheck(config);\n                checkResults[config.name] = result;\n                return result;\n            });\n            await Promise.allSettled(checkPromises);\n            // Calculate summary\n            const summary = this.calculateHealthSummary(checkResults);\n            // Determine overall status\n            let status = 'healthy';\n            if (summary.failedChecks > 0) {\n                status = 'unhealthy';\n            } else if (summary.warningChecks > 0 || summary.overallHealth < 90) {\n                status = 'degraded';\n            }\n            const result = {\n                status,\n                timestamp: new Date().toISOString(),\n                checks: checkResults,\n                summary,\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Add to history\n            this.healthHistory.push(result);\n            if (this.healthHistory.length > 100) {\n                this.healthHistory = this.healthHistory.slice(-100);\n            }\n            // Update metrics\n            this.updateMetrics(result);\n            // Log correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'info');\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            // Create error result\n            const errorResult = {\n                status: 'unhealthy',\n                timestamp: new Date().toISOString(),\n                checks: {},\n                summary: {\n                    overallHealth: 0,\n                    totalChecks: 0,\n                    passedChecks: 0,\n                    failedChecks: 1,\n                    warningChecks: 0,\n                    averageResponseTime: responseTime\n                },\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Log error with correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'error');\n            return errorResult;\n        } finally{\n            // Clear the health check context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.clearCurrentContext();\n        }\n    }\n    // Calculate health summary\n    calculateHealthSummary(checks) {\n        const checkArray = Object.values(checks);\n        const totalChecks = checkArray.length;\n        const passedChecks = checkArray.filter((c)=>c.status === 'pass').length;\n        const failedChecks = checkArray.filter((c)=>c.status === 'fail').length;\n        const warningChecks = checkArray.filter((c)=>c.status === 'warn').length;\n        const overallHealth = totalChecks > 0 ? passedChecks / totalChecks * 100 : 0;\n        const averageResponseTime = checkArray.length > 0 ? checkArray.reduce((sum, c)=>sum + c.responseTime, 0) / checkArray.length : 0;\n        return {\n            overallHealth: Math.round(overallHealth),\n            totalChecks,\n            passedChecks,\n            failedChecks,\n            warningChecks,\n            averageResponseTime: Math.round(averageResponseTime)\n        };\n    }\n    // Update metrics history\n    updateMetrics(healthResult) {\n        const metrics = {\n            overallScore: healthResult.summary.overallHealth,\n            errorRate: healthResult.summary.failedChecks / healthResult.summary.totalChecks,\n            responseTime: healthResult.summary.averageResponseTime,\n            uptime: healthResult.status === 'healthy' ? 100 : healthResult.status === 'degraded' ? 75 : 0,\n            lastCheck: healthResult.timestamp\n        };\n        this.metricsHistory.push(metrics);\n        if (this.metricsHistory.length > 1000) {\n            this.metricsHistory = this.metricsHistory.slice(-1000);\n        }\n    }\n    // Get health history\n    getHealthHistory() {\n        return [\n            ...this.healthHistory\n        ];\n    }\n    // Get metrics history\n    getMetricsHistory() {\n        return [\n            ...this.metricsHistory\n        ];\n    }\n    // Start monitoring\n    startMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        if (this.isMonitoring) return;\n        this.isMonitoring = true;\n        this.monitoringInterval = setInterval(async ()=>{\n            try {\n                await this.runComprehensiveHealthCheck();\n            } catch (error) {\n                console.error('Health monitoring error:', error);\n            }\n        }, intervalMs);\n        console.log('Health monitoring started with interval:', intervalMs, 'ms');\n    }\n    // Stop monitoring\n    stopMonitoring() {\n        if (this.monitoringInterval) {\n            clearInterval(this.monitoringInterval);\n            this.monitoringInterval = null;\n        }\n        this.isMonitoring = false;\n        console.log('Health monitoring stopped');\n    }\n    // Get current health\n    getCurrentHealth() {\n        return this.healthHistory.length > 0 ? this.healthHistory[this.healthHistory.length - 1] : null;\n    }\n    // Check if monitoring is active\n    isMonitoringActive() {\n        return this.isMonitoring;\n    }\n    // Get monitoring status\n    getMonitoringStatus() {\n        return {\n            isActive: this.isMonitoring,\n            interval: this.monitoringInterval ? 30000 : null\n        };\n    }\n    constructor(){\n        this.healthHistory = [];\n        this.metricsHistory = [];\n        this.isMonitoring = false;\n        this.monitoringInterval = null;\n    }\n}\n// Export singleton instance\nconst healthMonitoring = new HealthMonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaGVhbHRoLW1vbml0b3Jpbmctc2ltcGxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RTtBQTBEOUUsc0NBQXNDO0FBQ3RDLE1BQU1FLHdCQUE2QztJQUNqRDtRQUNFQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUNBO1FBQ0VKLE1BQU07UUFDTkMsVUFBVSxNQUE2QixHQUNuQyxDQUFrQyxDQUFFLDRCQUE0QjtXQUNoRTtRQUNKQyxTQUFTO1FBQ1RHLGdCQUFnQjtRQUNoQkYsVUFBVTtRQUNWQyxTQUFTO0lBQ1g7SUFDQTtRQUNFSixNQUFNO1FBQ05DLFVBQVVLLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsMEJBQTBCLElBQUk7UUFDcEROLFNBQVM7UUFDVEcsZ0JBQWdCO1FBQ2hCRixVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtDQUNEO0FBRUQsNEJBQTRCO0FBQzVCLE1BQU1LO0lBTUosNEJBQTRCO0lBQzVCLE1BQU1DLGVBQWVDLE1BQXlCLEVBQThCO1lBRXBEZDtRQUR0QixNQUFNZSxZQUFZQyxLQUFLQyxHQUFHO1FBQzFCLE1BQU1DLGlCQUFnQmxCLDBDQUFBQSxpRUFBb0JBLENBQUNtQixpQkFBaUIsZ0JBQXRDbkIsOERBQUFBLHdDQUEwQ2tCLGFBQWE7UUFFN0UsSUFBSTtZQUNGLElBQUlFO1lBRUosSUFBSU4sT0FBT1YsUUFBUSxLQUFLLFlBQVk7Z0JBQ2xDLHdCQUF3QjtnQkFDeEJnQixTQUFTLE1BQU0sSUFBSSxDQUFDQyxzQkFBc0IsQ0FBQ1A7WUFDN0MsT0FBTztnQkFDTCwwQkFBMEI7Z0JBQzFCTSxTQUFTLE1BQU0sSUFBSSxDQUFDRSxzQkFBc0IsQ0FBQ1I7WUFDN0M7WUFFQSwrQkFBK0I7WUFDL0IsSUFBSUksZUFBZTtnQkFDakJFLE9BQU9GLGFBQWEsR0FBR0E7WUFDekI7WUFFQSxPQUFPRTtRQUNULEVBQUUsT0FBT0csT0FBTztZQUNk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bUJBQXdDO1FBQ3RDLE9BQU8sSUFBSSxDQUFDcEMsYUFBYSxDQUFDRSxNQUFNLEdBQUcsSUFBSSxJQUFJLENBQUNGLGFBQWEsQ0FBQyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0UsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUM3RjtJQUVBLGdDQUFnQztJQUNoQ21DLHFCQUE4QjtRQUM1QixPQUFPLElBQUksQ0FBQ1IsWUFBWTtJQUMxQjtJQUVBLHdCQUF3QjtJQUN4QlMsc0JBQXNFO1FBQ3BFLE9BQU87WUFDTEMsVUFBVSxJQUFJLENBQUNWLFlBQVk7WUFDM0JXLFVBQVUsSUFBSSxDQUFDVixrQkFBa0IsR0FBRyxRQUFRO1FBQzlDO0lBQ0Y7O2FBL1VROUIsZ0JBQWdDLEVBQUU7YUFDbEN3QixpQkFBdUMsRUFBRTthQUN6Q0ssZUFBd0I7YUFDeEJDLHFCQUE0Qzs7QUE2VXREO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU1XLG1CQUFtQixJQUFJaEgsMEJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvbGliL2hlYWx0aC1tb25pdG9yaW5nLXNpbXBsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb3JyZWxhdGlvbklETWFuYWdlciwgZ2V0Q29ycmVsYXRpb25IZWFkZXJzIH0gZnJvbSAnLi9jb3JyZWxhdGlvbi1pZCdcblxuLy8gSGVhbHRoIGNoZWNrIGNvbmZpZ3VyYXRpb24gaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrQ29uZmlnIHtcbiAgbmFtZTogc3RyaW5nXG4gIGVuZHBvaW50OiBzdHJpbmdcbiAgdGltZW91dDogbnVtYmVyXG4gIGV4cGVjdGVkU3RhdHVzPzogbnVtYmVyXG4gIGNyaXRpY2FsOiBib29sZWFuXG4gIHJldHJpZXM6IG51bWJlclxuICBoZWFkZXJzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxufVxuXG4vLyBIZWFsdGggY2hlY2sgcmVzdWx0IGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja1Jlc3VsdCB7XG4gIHN0YXR1czogJ3Bhc3MnIHwgJ3dhcm4nIHwgJ2ZhaWwnXG4gIHJlc3BvbnNlVGltZTogbnVtYmVyXG4gIGVycm9yPzogc3RyaW5nXG4gIGRldGFpbHM/OiBhbnlcbiAgdGltZXN0YW1wOiBzdHJpbmdcbiAgY29ycmVsYXRpb25JZD86IHN0cmluZ1xufVxuXG4vLyBIZWFsdGggaW5kZXggbWV0cmljcyBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoSW5kZXhNZXRyaWNzIHtcbiAgb3ZlcmFsbFNjb3JlOiBudW1iZXJcbiAgZXJyb3JSYXRlOiBudW1iZXJcbiAgcmVzcG9uc2VUaW1lOiBudW1iZXJcbiAgdXB0aW1lOiBudW1iZXJcbiAgbGFzdENoZWNrOiBzdHJpbmdcbn1cblxuLy8gSGVhbHRoIHN1bW1hcnkgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aFN1bW1hcnkge1xuICBvdmVyYWxsSGVhbHRoOiBudW1iZXJcbiAgdG90YWxDaGVja3M6IG51bWJlclxuICBwYXNzZWRDaGVja3M6IG51bWJlclxuICBmYWlsZWRDaGVja3M6IG51bWJlclxuICB3YXJuaW5nQ2hlY2tzOiBudW1iZXJcbiAgYXZlcmFnZVJlc3BvbnNlVGltZTogbnVtYmVyXG59XG5cbi8vIEhlYWx0aCByZXN1bHQgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aFJlc3VsdCB7XG4gIHN0YXR1czogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknXG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIGNoZWNrczogUmVjb3JkPHN0cmluZywgSGVhbHRoQ2hlY2tSZXN1bHQ+XG4gIHN1bW1hcnk6IEhlYWx0aFN1bW1hcnlcbiAgbWV0YWRhdGE6IHtcbiAgICBzZXJ2aWNlOiBzdHJpbmdcbiAgICByZWdpb246IHN0cmluZ1xuICAgIGluc3RhbmNlOiBzdHJpbmdcbiAgICBidWlsZDogc3RyaW5nXG4gICAgY29tbWl0OiBzdHJpbmdcbiAgICBjb3JyZWxhdGlvbklkPzogc3RyaW5nXG4gIH1cbn1cblxuLy8gRGVmYXVsdCBoZWFsdGggY2hlY2sgY29uZmlndXJhdGlvbnNcbmNvbnN0IERFRkFVTFRfSEVBTFRIX0NIRUNLUzogSGVhbHRoQ2hlY2tDb25maWdbXSA9IFtcbiAge1xuICAgIG5hbWU6ICdzeXN0ZW0nLFxuICAgIGVuZHBvaW50OiAnaW50ZXJuYWwnLCAvLyBTcGVjaWFsIGNhc2UgZm9yIHN5c3RlbSBjaGVja3NcbiAgICB0aW1lb3V0OiA1MDAwLFxuICAgIGNyaXRpY2FsOiBmYWxzZSxcbiAgICByZXRyaWVzOiAyLFxuICB9LFxuICB7XG4gICAgbmFtZTogJ2Zyb250ZW5kJyxcbiAgICBlbmRwb2ludDogdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgXG4gICAgICA/ICdodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL2hlYWx0aCcgIC8vIFNlcnZlci1zaWRlOiB1c2UgZnVsbCBVUkxcbiAgICAgIDogJy9hcGkvaGVhbHRoJywgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xpZW50LXNpZGU6IHVzZSByZWxhdGl2ZSBVUkxcbiAgICB0aW1lb3V0OiA1MDAwLFxuICAgIGV4cGVjdGVkU3RhdHVzOiAyMDAsXG4gICAgY3JpdGljYWw6IHRydWUsXG4gICAgcmV0cmllczogMyxcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdiYWNrZW5kLWFwaScsXG4gICAgZW5kcG9pbnQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0hFQUxUSF9BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAvaGVhbHRoJyxcbiAgICB0aW1lb3V0OiA1MDAwLFxuICAgIGV4cGVjdGVkU3RhdHVzOiAyMDAsXG4gICAgY3JpdGljYWw6IHRydWUsXG4gICAgcmV0cmllczogMyxcbiAgfSxcbl1cblxuLy8gSGVhbHRoIG1vbml0b3Jpbmcgc2VydmljZVxuY2xhc3MgSGVhbHRoTW9uaXRvcmluZ1NlcnZpY2Uge1xuICBwcml2YXRlIGhlYWx0aEhpc3Rvcnk6IEhlYWx0aFJlc3VsdFtdID0gW11cbiAgcHJpdmF0ZSBtZXRyaWNzSGlzdG9yeTogSGVhbHRoSW5kZXhNZXRyaWNzW10gPSBbXVxuICBwcml2YXRlIGlzTW9uaXRvcmluZzogYm9vbGVhbiA9IGZhbHNlXG4gIHByaXZhdGUgbW9uaXRvcmluZ0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG5cbiAgLy8gUnVuIGEgc2luZ2xlIGhlYWx0aCBjaGVja1xuICBhc3luYyBydW5IZWFsdGhDaGVjayhjb25maWc6IEhlYWx0aENoZWNrQ29uZmlnKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gY29ycmVsYXRpb25JRE1hbmFnZXIuZ2V0Q3VycmVudENvbnRleHQoKT8uY29ycmVsYXRpb25JZFxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXN1bHQ6IEhlYWx0aENoZWNrUmVzdWx0XG5cbiAgICAgIGlmIChjb25maWcuZW5kcG9pbnQgPT09ICdpbnRlcm5hbCcpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgc3lzdGVtIGNoZWNrXG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuSW50ZXJuYWxIZWFsdGhDaGVjayhjb25maWcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeHRlcm5hbCBlbmRwb2ludCBjaGVja1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkV4dGVybmFsSGVhbHRoQ2hlY2soY29uZmlnKVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY29ycmVsYXRpb24gSUQgdG8gcmVzdWx0XG4gICAgICBpZiAoY29ycmVsYXRpb25JZCkge1xuICAgICAgICByZXN1bHQuY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biBpbnRlcm5hbCBoZWFsdGggY2hlY2tcbiAgcHJpdmF0ZSBhc3luYyBydW5JbnRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZzogSGVhbHRoQ2hlY2tDb25maWcpOiBQcm9taXNlPEhlYWx0aENoZWNrUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBzeXN0ZW0gcmVzb3VyY2VzXG4gICAgICBjb25zdCBzeXN0ZW1JbmZvID0gYXdhaXQgdGhpcy5nZXRTeXN0ZW1JbmZvKClcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdwYXNzJyxcbiAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICBkZXRhaWxzOiBzeXN0ZW1JbmZvLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biBleHRlcm5hbCBoZWFsdGggY2hlY2tcbiAgcHJpdmF0ZSBhc3luYyBydW5FeHRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZzogSGVhbHRoQ2hlY2tDb25maWcpOiBQcm9taXNlPEhlYWx0aENoZWNrUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGxcblxuICAgIC8vIFRyeSB3aXRoIHJldHJpZXNcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBjb25maWcucmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgIC4uLmdldENvcnJlbGF0aW9uSGVhZGVycygpLFxuICAgICAgICAgIC4uLmNvbmZpZy5oZWFkZXJzLFxuICAgICAgICAgICdVc2VyLUFnZW50JzogJ0hlYWx0aC1Nb25pdG9yLzEuMCdcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIGNvbmZpZy50aW1lb3V0KVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY29uZmlnLmVuZHBvaW50LCB7XG4gICAgICAgICAgbWV0aG9kOiAnSEVBRCcsIC8vIFVzZSBIRUFEIGZvciBoZWFsdGggY2hlY2tzIHRvIG1pbmltaXplIGRhdGEgdHJhbnNmZXJcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSlcblxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcblxuICAgICAgICBpZiAoY29uZmlnLmV4cGVjdGVkU3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyAhPT0gY29uZmlnLmV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBzdGF0dXMgJHtjb25maWcuZXhwZWN0ZWRTdGF0dXN9LCBnb3QgJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgPCA0MDAgPyAncGFzcycgOiByZXNwb25zZS5zdGF0dXMgPCA1MDAgPyAnd2FybicgOiAnZmFpbCcsXG4gICAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgbGFzdCBhdHRlbXB0LCB0aHJvdyB0aGUgZXJyb3JcbiAgICAgICAgaWYgKGF0dGVtcHQgPT09IGNvbmZpZy5yZXRyaWVzKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5IChleHBvbmVudGlhbCBiYWNrb2ZmKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5wb3coMiwgYXR0ZW1wdCkgKiAxMDApKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IEVycm9yKCdIZWFsdGggY2hlY2sgZmFpbGVkIGFmdGVyIGFsbCByZXRyaWVzJylcbiAgfVxuXG4gIC8vIEdldCBzeXN0ZW0gaW5mb3JtYXRpb25cbiAgcHJpdmF0ZSBhc3luYyBnZXRTeXN0ZW1JbmZvKCk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBTZXJ2ZXItc2lkZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGxhdGZvcm06ICdzZXJ2ZXInLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsaWVudC1zaWRlXG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYXRmb3JtOiAnYnJvd3NlcicsXG4gICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBsYW5ndWFnZTogbmF2aWdhdG9yLmxhbmd1YWdlLFxuICAgICAgY29va2llRW5hYmxlZDogbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQsXG4gICAgICBvbkxpbmU6IG5hdmlnYXRvci5vbkxpbmUsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biBjb21wcmVoZW5zaXZlIGhlYWx0aCBjaGVja1xuICBhc3luYyBydW5Db21wcmVoZW5zaXZlSGVhbHRoQ2hlY2soKTogUHJvbWlzZTxIZWFsdGhSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk/LmNvcnJlbGF0aW9uSWRcblxuICAgIC8vIEdlbmVyYXRlIGNvcnJlbGF0aW9uIGNvbnRleHQgZm9yIHRoaXMgaGVhbHRoIGNoZWNrXG4gICAgY29uc3QgaGVhbHRoQ2hlY2tDb250ZXh0ID0gY29ycmVsYXRpb25JRE1hbmFnZXIuZ2VuZXJhdGVDb250ZXh0KFxuICAgICAgY29ycmVsYXRpb25JZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHsgb3BlcmF0aW9uOiAnaGVhbHRoX2NoZWNrJywgdHlwZTogJ2NvbXByZWhlbnNpdmUnIH1cbiAgICApXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2hlY2tSZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBIZWFsdGhDaGVja1Jlc3VsdD4gPSB7fVxuICAgICAgY29uc3QgY2hlY2tQcm9taXNlcyA9IERFRkFVTFRfSEVBTFRIX0NIRUNLUy5tYXAoYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkhlYWx0aENoZWNrKGNvbmZpZylcbiAgICAgICAgY2hlY2tSZXN1bHRzW2NvbmZpZy5uYW1lXSA9IHJlc3VsdFxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoY2hlY2tQcm9taXNlcylcblxuICAgICAgLy8gQ2FsY3VsYXRlIHN1bW1hcnlcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSB0aGlzLmNhbGN1bGF0ZUhlYWx0aFN1bW1hcnkoY2hlY2tSZXN1bHRzKVxuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgb3ZlcmFsbCBzdGF0dXNcbiAgICAgIGxldCBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5JyA9ICdoZWFsdGh5J1xuICAgICAgaWYgKHN1bW1hcnkuZmFpbGVkQ2hlY2tzID4gMCkge1xuICAgICAgICBzdGF0dXMgPSAndW5oZWFsdGh5J1xuICAgICAgfSBlbHNlIGlmIChzdW1tYXJ5Lndhcm5pbmdDaGVja3MgPiAwIHx8IHN1bW1hcnkub3ZlcmFsbEhlYWx0aCA8IDkwKSB7XG4gICAgICAgIHN0YXR1cyA9ICdkZWdyYWRlZCdcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0OiBIZWFsdGhSZXN1bHQgPSB7XG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNoZWNrczogY2hlY2tSZXN1bHRzLFxuICAgICAgICBzdW1tYXJ5LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHNlcnZpY2U6ICdBSSBTYWFTIEZhY3RvcnkgLSBOZXh0LmpzIEZyb250ZW5kJyxcbiAgICAgICAgICByZWdpb246ICdsb2NhbCcsXG4gICAgICAgICAgaW5zdGFuY2U6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgIGJ1aWxkOiAnbG9jYWwnLFxuICAgICAgICAgIGNvbW1pdDogJ2xvY2FsJyxcbiAgICAgICAgICBjb3JyZWxhdGlvbklkOiBoZWFsdGhDaGVja0NvbnRleHQuY29ycmVsYXRpb25JZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0byBoaXN0b3J5XG4gICAgICB0aGlzLmhlYWx0aEhpc3RvcnkucHVzaChyZXN1bHQpXG4gICAgICBpZiAodGhpcy5oZWFsdGhIaXN0b3J5Lmxlbmd0aCA+IDEwMCkge1xuICAgICAgICB0aGlzLmhlYWx0aEhpc3RvcnkgPSB0aGlzLmhlYWx0aEhpc3Rvcnkuc2xpY2UoLTEwMClcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIG1ldHJpY3NcbiAgICAgIHRoaXMudXBkYXRlTWV0cmljcyhyZXN1bHQpXG5cbiAgICAgIC8vIExvZyBjb3JyZWxhdGlvbiBjb250ZXh0XG4gICAgICBjb3JyZWxhdGlvbklETWFuYWdlci5sb2dDb250ZXh0KGhlYWx0aENoZWNrQ29udGV4dCwgJ2luZm8nKVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGVycm9yIHJlc3VsdFxuICAgICAgY29uc3QgZXJyb3JSZXN1bHQ6IEhlYWx0aFJlc3VsdCA9IHtcbiAgICAgICAgc3RhdHVzOiAndW5oZWFsdGh5JyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNoZWNrczoge30sXG4gICAgICAgIHN1bW1hcnk6IHtcbiAgICAgICAgICBvdmVyYWxsSGVhbHRoOiAwLFxuICAgICAgICAgIHRvdGFsQ2hlY2tzOiAwLFxuICAgICAgICAgIHBhc3NlZENoZWNrczogMCxcbiAgICAgICAgICBmYWlsZWRDaGVja3M6IDEsXG4gICAgICAgICAgd2FybmluZ0NoZWNrczogMCxcbiAgICAgICAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiByZXNwb25zZVRpbWVcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBzZXJ2aWNlOiAnQUkgU2FhUyBGYWN0b3J5IC0gTmV4dC5qcyBGcm9udGVuZCcsXG4gICAgICAgICAgcmVnaW9uOiAnbG9jYWwnLFxuICAgICAgICAgIGluc3RhbmNlOiAnbG9jYWxob3N0JyxcbiAgICAgICAgICBidWlsZDogJ2xvY2FsJyxcbiAgICAgICAgICBjb21taXQ6ICdsb2NhbCcsXG4gICAgICAgICAgY29ycmVsYXRpb25JZDogaGVhbHRoQ2hlY2tDb250ZXh0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2cgZXJyb3Igd2l0aCBjb3JyZWxhdGlvbiBjb250ZXh0XG4gICAgICBjb3JyZWxhdGlvbklETWFuYWdlci5sb2dDb250ZXh0KGhlYWx0aENoZWNrQ29udGV4dCwgJ2Vycm9yJylcbiAgICAgIFxuICAgICAgcmV0dXJuIGVycm9yUmVzdWx0XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHRoZSBoZWFsdGggY2hlY2sgY29udGV4dFxuICAgICAgY29ycmVsYXRpb25JRE1hbmFnZXIuY2xlYXJDdXJyZW50Q29udGV4dCgpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGhlYWx0aCBzdW1tYXJ5XG4gIHByaXZhdGUgY2FsY3VsYXRlSGVhbHRoU3VtbWFyeShjaGVja3M6IFJlY29yZDxzdHJpbmcsIEhlYWx0aENoZWNrUmVzdWx0Pik6IEhlYWx0aFN1bW1hcnkge1xuICAgIGNvbnN0IGNoZWNrQXJyYXkgPSBPYmplY3QudmFsdWVzKGNoZWNrcylcbiAgICBjb25zdCB0b3RhbENoZWNrcyA9IGNoZWNrQXJyYXkubGVuZ3RoXG4gICAgY29uc3QgcGFzc2VkQ2hlY2tzID0gY2hlY2tBcnJheS5maWx0ZXIoYyA9PiBjLnN0YXR1cyA9PT0gJ3Bhc3MnKS5sZW5ndGhcbiAgICBjb25zdCBmYWlsZWRDaGVja3MgPSBjaGVja0FycmF5LmZpbHRlcihjID0+IGMuc3RhdHVzID09PSAnZmFpbCcpLmxlbmd0aFxuICAgIGNvbnN0IHdhcm5pbmdDaGVja3MgPSBjaGVja0FycmF5LmZpbHRlcihjID0+IGMuc3RhdHVzID09PSAnd2FybicpLmxlbmd0aFxuXG4gICAgY29uc3Qgb3ZlcmFsbEhlYWx0aCA9IHRvdGFsQ2hlY2tzID4gMCA/IChwYXNzZWRDaGVja3MgLyB0b3RhbENoZWNrcykgKiAxMDAgOiAwXG4gICAgY29uc3QgYXZlcmFnZVJlc3BvbnNlVGltZSA9IGNoZWNrQXJyYXkubGVuZ3RoID4gMCBcbiAgICAgID8gY2hlY2tBcnJheS5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYy5yZXNwb25zZVRpbWUsIDApIC8gY2hlY2tBcnJheS5sZW5ndGggXG4gICAgICA6IDBcblxuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsSGVhbHRoOiBNYXRoLnJvdW5kKG92ZXJhbGxIZWFsdGgpLFxuICAgICAgdG90YWxDaGVja3MsXG4gICAgICBwYXNzZWRDaGVja3MsXG4gICAgICBmYWlsZWRDaGVja3MsXG4gICAgICB3YXJuaW5nQ2hlY2tzLFxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogTWF0aC5yb3VuZChhdmVyYWdlUmVzcG9uc2VUaW1lKVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBtZXRyaWNzIGhpc3RvcnlcbiAgcHJpdmF0ZSB1cGRhdGVNZXRyaWNzKGhlYWx0aFJlc3VsdDogSGVhbHRoUmVzdWx0KTogdm9pZCB7XG4gICAgY29uc3QgbWV0cmljczogSGVhbHRoSW5kZXhNZXRyaWNzID0ge1xuICAgICAgb3ZlcmFsbFNjb3JlOiBoZWFsdGhSZXN1bHQuc3VtbWFyeS5vdmVyYWxsSGVhbHRoLFxuICAgICAgZXJyb3JSYXRlOiBoZWFsdGhSZXN1bHQuc3VtbWFyeS5mYWlsZWRDaGVja3MgLyBoZWFsdGhSZXN1bHQuc3VtbWFyeS50b3RhbENoZWNrcyxcbiAgICAgIHJlc3BvbnNlVGltZTogaGVhbHRoUmVzdWx0LnN1bW1hcnkuYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgICAgIHVwdGltZTogaGVhbHRoUmVzdWx0LnN0YXR1cyA9PT0gJ2hlYWx0aHknID8gMTAwIDogaGVhbHRoUmVzdWx0LnN0YXR1cyA9PT0gJ2RlZ3JhZGVkJyA/IDc1IDogMCxcbiAgICAgIGxhc3RDaGVjazogaGVhbHRoUmVzdWx0LnRpbWVzdGFtcFxuICAgIH1cblxuICAgIHRoaXMubWV0cmljc0hpc3RvcnkucHVzaChtZXRyaWNzKVxuICAgIGlmICh0aGlzLm1ldHJpY3NIaXN0b3J5Lmxlbmd0aCA+IDEwMDApIHtcbiAgICAgIHRoaXMubWV0cmljc0hpc3RvcnkgPSB0aGlzLm1ldHJpY3NIaXN0b3J5LnNsaWNlKC0xMDAwKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBoZWFsdGggaGlzdG9yeVxuICBnZXRIZWFsdGhIaXN0b3J5KCk6IEhlYWx0aFJlc3VsdFtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuaGVhbHRoSGlzdG9yeV1cbiAgfVxuXG4gIC8vIEdldCBtZXRyaWNzIGhpc3RvcnlcbiAgZ2V0TWV0cmljc0hpc3RvcnkoKTogSGVhbHRoSW5kZXhNZXRyaWNzW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5tZXRyaWNzSGlzdG9yeV1cbiAgfVxuXG4gIC8vIFN0YXJ0IG1vbml0b3JpbmdcbiAgc3RhcnRNb25pdG9yaW5nKGludGVydmFsTXM6IG51bWJlciA9IDMwMDAwKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNNb25pdG9yaW5nKSByZXR1cm5cblxuICAgIHRoaXMuaXNNb25pdG9yaW5nID0gdHJ1ZVxuICAgIHRoaXMubW9uaXRvcmluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Db21wcmVoZW5zaXZlSGVhbHRoQ2hlY2soKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSGVhbHRoIG1vbml0b3JpbmcgZXJyb3I6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfSwgaW50ZXJ2YWxNcylcblxuICAgIGNvbnNvbGUubG9nKCdIZWFsdGggbW9uaXRvcmluZyBzdGFydGVkIHdpdGggaW50ZXJ2YWw6JywgaW50ZXJ2YWxNcywgJ21zJylcbiAgfVxuXG4gIC8vIFN0b3AgbW9uaXRvcmluZ1xuICBzdG9wTW9uaXRvcmluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpXG4gICAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5pc01vbml0b3JpbmcgPSBmYWxzZVxuICAgIGNvbnNvbGUubG9nKCdIZWFsdGggbW9uaXRvcmluZyBzdG9wcGVkJylcbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IGhlYWx0aFxuICBnZXRDdXJyZW50SGVhbHRoKCk6IEhlYWx0aFJlc3VsdCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmhlYWx0aEhpc3RvcnkubGVuZ3RoID4gMCA/IHRoaXMuaGVhbHRoSGlzdG9yeVt0aGlzLmhlYWx0aEhpc3RvcnkubGVuZ3RoIC0gMV0gOiBudWxsXG4gIH1cblxuICAvLyBDaGVjayBpZiBtb25pdG9yaW5nIGlzIGFjdGl2ZVxuICBpc01vbml0b3JpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNNb25pdG9yaW5nXG4gIH1cblxuICAvLyBHZXQgbW9uaXRvcmluZyBzdGF0dXNcbiAgZ2V0TW9uaXRvcmluZ1N0YXR1cygpOiB7IGlzQWN0aXZlOiBib29sZWFuOyBpbnRlcnZhbDogbnVtYmVyIHwgbnVsbCB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmU6IHRoaXMuaXNNb25pdG9yaW5nLFxuICAgICAgaW50ZXJ2YWw6IHRoaXMubW9uaXRvcmluZ0ludGVydmFsID8gMzAwMDAgOiBudWxsXG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBoZWFsdGhNb25pdG9yaW5nID0gbmV3IEhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlKClcblxuLy8gRXhwb3J0IHR5cGVzXG5leHBvcnQgdHlwZSB7XG4gIEhlYWx0aENoZWNrQ29uZmlnLFxuICBIZWFsdGhDaGVja1Jlc3VsdCxcbiAgSGVhbHRoSW5kZXhNZXRyaWNzLFxuICBIZWFsdGhTdW1tYXJ5LFxuICBIZWFsdGhSZXN1bHRcbn1cbiJdLCJuYW1lcyI6WyJjb3JyZWxhdGlvbklETWFuYWdlciIsImdldENvcnJlbGF0aW9uSGVhZGVycyIsIkRFRkFVTFRfSEVBTFRIX0NIRUNLUyIsIm5hbWUiLCJlbmRwb2ludCIsInRpbWVvdXQiLCJjcml0aWNhbCIsInJldHJpZXMiLCJleHBlY3RlZFN0YXR1cyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19IRUFMVEhfQVBJX1VSTCIsIkhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlIiwicnVuSGVhbHRoQ2hlY2siLCJjb25maWciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY29ycmVsYXRpb25JZCIsImdldEN1cnJlbnRDb250ZXh0IiwicmVzdWx0IiwicnVuSW50ZXJuYWxIZWFsdGhDaGVjayIsInJ1bkV4dGVybmFsSGVhbHRoQ2hlY2siLCJlcnJvciIsInJlc3BvbnNlVGltZSIsInN0YXR1cyIsIkVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwic3lzdGVtSW5mbyIsImdldFN5c3RlbUluZm8iLCJkZXRhaWxzIiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsImhlYWRlcnMiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsInN0YXR1c1RleHQiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIk1hdGgiLCJwb3ciLCJwbGF0Zm9ybSIsInVzZXJBZ2VudCIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwiY29va2llRW5hYmxlZCIsIm9uTGluZSIsInJ1bkNvbXByZWhlbnNpdmVIZWFsdGhDaGVjayIsImhlYWx0aENoZWNrQ29udGV4dCIsImdlbmVyYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsIm9wZXJhdGlvbiIsInR5cGUiLCJjaGVja1Jlc3VsdHMiLCJjaGVja1Byb21pc2VzIiwibWFwIiwiYWxsU2V0dGxlZCIsInN1bW1hcnkiLCJjYWxjdWxhdGVIZWFsdGhTdW1tYXJ5IiwiZmFpbGVkQ2hlY2tzIiwid2FybmluZ0NoZWNrcyIsIm92ZXJhbGxIZWFsdGgiLCJjaGVja3MiLCJtZXRhZGF0YSIsInNlcnZpY2UiLCJyZWdpb24iLCJpbnN0YW5jZSIsImJ1aWxkIiwiY29tbWl0IiwiaGVhbHRoSGlzdG9yeSIsInB1c2giLCJsZW5ndGgiLCJzbGljZSIsInVwZGF0ZU1ldHJpY3MiLCJsb2dDb250ZXh0IiwiZXJyb3JSZXN1bHQiLCJ0b3RhbENoZWNrcyIsInBhc3NlZENoZWNrcyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJjbGVhckN1cnJlbnRDb250ZXh0IiwiY2hlY2tBcnJheSIsInZhbHVlcyIsImZpbHRlciIsImMiLCJyZWR1Y2UiLCJzdW0iLCJyb3VuZCIsImhlYWx0aFJlc3VsdCIsIm1ldHJpY3MiLCJvdmVyYWxsU2NvcmUiLCJlcnJvclJhdGUiLCJ1cHRpbWUiLCJsYXN0Q2hlY2siLCJtZXRyaWNzSGlzdG9yeSIsImdldEhlYWx0aEhpc3RvcnkiLCJnZXRNZXRyaWNzSGlzdG9yeSIsInN0YXJ0TW9uaXRvcmluZyIsImludGVydmFsTXMiLCJpc01vbml0b3JpbmciLCJtb25pdG9yaW5nSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNvbnNvbGUiLCJsb2ciLCJzdG9wTW9uaXRvcmluZyIsImNsZWFySW50ZXJ2YWwiLCJnZXRDdXJyZW50SGVhbHRoIiwiaXNNb25pdG9yaW5nQWN0aXZlIiwiZ2V0TW9uaXRvcmluZ1N0YXR1cyIsImlzQWN0aXZlIiwiaW50ZXJ2YWwiLCJoZWFsdGhNb25pdG9yaW5nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/health-monitoring-simple.ts\n"));

/***/ })

});