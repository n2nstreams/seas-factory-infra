"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"40cb514dd78b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNDBjYjUxNGRkNzhiXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/providers/ObservabilityProvider.tsx":
/*!************************************************************!*\
  !*** ./src/components/providers/ObservabilityProvider.tsx ***!
  \************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ObservabilityProvider: () => (/* binding */ ObservabilityProvider),\n/* harmony export */   useAlertThresholds: () => (/* binding */ useAlertThresholds),\n/* harmony export */   useHealthMonitoring: () => (/* binding */ useHealthMonitoring),\n/* harmony export */   useObservabilityCorrelationID: () => (/* binding */ useObservabilityCorrelationID),\n/* harmony export */   useSystemStatus: () => (/* binding */ useSystemStatus)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/health-monitoring-simple */ \"(app-pages-browser)/./src/lib/health-monitoring-simple.ts\");\n/* harmony import */ var _lib_correlation_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/correlation-id */ \"(app-pages-browser)/./src/lib/correlation-id.ts\");\n/* harmony import */ var _lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/alert-thresholds */ \"(app-pages-browser)/./src/lib/alert-thresholds.ts\");\n/* __next_internal_client_entry_do_not_use__ ObservabilityProvider,useHealthMonitoring,useObservabilityCorrelationID,useAlertThresholds,useSystemStatus auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$();\n\n\n\n\n// Create observability context\nconst ObservabilityContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Observability provider component\nfunction ObservabilityProvider(param) {\n    let { children } = param;\n    _s();\n    // Health monitoring state\n    const [currentHealth, setCurrentHealth] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [healthHistory, setHealthHistory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [metricsHistory, setMetricsHistory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isMonitoring, setIsMonitoring] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Alert threshold state\n    const [alertThresholds, setAlertThresholds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [alertHistory, setAlertHistory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isAlertMonitoring, setIsAlertMonitoring] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // System status state\n    const [systemStatus, setSystemStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        health: 'healthy',\n        alerts: {\n            warning: 0,\n            critical: 0,\n            resolved: 0\n        },\n        uptime: 0,\n        lastUpdate: new Date().toISOString()\n    });\n    // Initialize correlation ID context for this provider\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ObservabilityProvider.useEffect\": ()=>{\n            const context = _lib_correlation_id__WEBPACK_IMPORTED_MODULE_3__.correlationIDManager.generateContext(undefined, undefined, undefined, undefined, {\n                operation: 'observability_provider_init',\n                component: 'ObservabilityProvider'\n            });\n            // Log the initialization\n            _lib_correlation_id__WEBPACK_IMPORTED_MODULE_3__.correlationIDManager.logContext(context, 'info');\n        }\n    }[\"ObservabilityProvider.useEffect\"], []);\n    // Initialize health monitoring\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ObservabilityProvider.useEffect\": ()=>{\n            const initializeHealthMonitoring = {\n                \"ObservabilityProvider.useEffect.initializeHealthMonitoring\": async ()=>{\n                    try {\n                        // Run initial health check\n                        await runHealthCheck();\n                        // Start monitoring\n                        startMonitoring();\n                    } catch (error) {\n                        console.error('Failed to initialize health monitoring:', error);\n                    }\n                }\n            }[\"ObservabilityProvider.useEffect.initializeHealthMonitoring\"];\n            initializeHealthMonitoring();\n            return ({\n                \"ObservabilityProvider.useEffect\": ()=>{\n                    stopMonitoring();\n                }\n            })[\"ObservabilityProvider.useEffect\"];\n        }\n    }[\"ObservabilityProvider.useEffect\"], []);\n    // Initialize alert thresholds\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ObservabilityProvider.useEffect\": ()=>{\n            const thresholds = _lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.getAllThresholds();\n            setAlertThresholds(thresholds);\n            // Start alert monitoring\n            startAlertMonitoring();\n            return ({\n                \"ObservabilityProvider.useEffect\": ()=>{\n                    stopAlertMonitoring();\n                }\n            })[\"ObservabilityProvider.useEffect\"];\n        }\n    }[\"ObservabilityProvider.useEffect\"], []);\n    // Update system status periodically\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ObservabilityProvider.useEffect\": ()=>{\n            const updateSystemStatus = {\n                \"ObservabilityProvider.useEffect.updateSystemStatus\": ()=>{\n                    const health = (currentHealth === null || currentHealth === void 0 ? void 0 : currentHealth.status) || 'healthy';\n                    const alerts = {\n                        warning: alertHistory.filter({\n                            \"ObservabilityProvider.useEffect.updateSystemStatus\": (a)=>a.status === 'warning'\n                        }[\"ObservabilityProvider.useEffect.updateSystemStatus\"]).length,\n                        critical: alertHistory.filter({\n                            \"ObservabilityProvider.useEffect.updateSystemStatus\": (a)=>a.status === 'critical'\n                        }[\"ObservabilityProvider.useEffect.updateSystemStatus\"]).length,\n                        resolved: alertHistory.filter({\n                            \"ObservabilityProvider.useEffect.updateSystemStatus\": (a)=>a.status === 'resolved'\n                        }[\"ObservabilityProvider.useEffect.updateSystemStatus\"]).length\n                    };\n                    const uptime = currentHealth ? Date.now() - new Date(currentHealth.timestamp).getTime() : 0;\n                    setSystemStatus({\n                        health,\n                        alerts,\n                        uptime,\n                        lastUpdate: new Date().toISOString()\n                    });\n                }\n            }[\"ObservabilityProvider.useEffect.updateSystemStatus\"];\n            const interval = setInterval(updateSystemStatus, 10000) // Update every 10 seconds\n            ;\n            updateSystemStatus(); // Initial update\n            return ({\n                \"ObservabilityProvider.useEffect\": ()=>clearInterval(interval)\n            })[\"ObservabilityProvider.useEffect\"];\n        }\n    }[\"ObservabilityProvider.useEffect\"], [\n        currentHealth,\n        alertHistory\n    ]);\n    // Health monitoring functions\n    const startMonitoring = ()=>{\n        _lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_2__.healthMonitoring.startMonitoring();\n        setIsMonitoring(true);\n    };\n    const stopMonitoring = ()=>{\n        _lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_2__.healthMonitoring.stopMonitoring();\n        setIsMonitoring(false);\n    };\n    const runHealthCheck = async ()=>{\n        try {\n            const result = await _lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_2__.healthMonitoring.runComprehensiveHealthCheck();\n            setCurrentHealth(result);\n            setHealthHistory(_lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_2__.healthMonitoring.getHealthHistory());\n            setMetricsHistory(_lib_health_monitoring_simple__WEBPACK_IMPORTED_MODULE_2__.healthMonitoring.getMetricsHistory());\n        } catch (error) {\n            console.error('Health check failed:', error);\n        }\n    };\n    // Alert monitoring functions\n    const startAlertMonitoring = ()=>{\n        _lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.startMonitoring();\n        setIsAlertMonitoring(true);\n        // Set up periodic alert history updates\n        const updateAlertHistory = ()=>{\n            setAlertHistory(_lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.getAlertHistory());\n        };\n        const interval = setInterval(updateAlertHistory, 5000) // Update every 5 seconds\n        ;\n        updateAlertHistory() // Initial update\n        ;\n        window.alertHistoryInterval = interval;\n    };\n    const stopAlertMonitoring = ()=>{\n        _lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.stopMonitoring();\n        setIsAlertMonitoring(false);\n        // Clear interval\n        if (window.alertHistoryInterval) {\n            clearInterval(window.alertHistoryInterval);\n        }\n    };\n    const updateThreshold = (name, updates)=>{\n        const success = _lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.updateThreshold(name, updates);\n        if (success) {\n            setAlertThresholds(_lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.getAllThresholds());\n        }\n        return success;\n    };\n    const addThreshold = (threshold)=>{\n        _lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.addThreshold(threshold);\n        setAlertThresholds(_lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.getAllThresholds());\n    };\n    const removeThreshold = (name)=>{\n        const success = _lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.removeThreshold(name);\n        if (success) {\n            setAlertThresholds(_lib_alert_thresholds__WEBPACK_IMPORTED_MODULE_4__.alertThresholdManager.getAllThresholds());\n        }\n        return success;\n    };\n    // Correlation ID functions\n    const generateCorrelationContext = (parentId, userId, tenantId, sessionId, metadata)=>{\n        _lib_correlation_id__WEBPACK_IMPORTED_MODULE_3__.correlationIDManager.generateContext(parentId, userId, tenantId, sessionId, metadata);\n    };\n    const getCorrelationHeaders = ()=>_lib_correlation_id__WEBPACK_IMPORTED_MODULE_3__.correlationIDManager.getHeaders();\n    // Get current correlation context\n    const currentContext = _lib_correlation_id__WEBPACK_IMPORTED_MODULE_3__.correlationIDManager.getCurrentContext();\n    // Context value\n    const contextValue = {\n        // Health monitoring\n        currentHealth,\n        healthHistory,\n        metricsHistory,\n        isMonitoring,\n        startMonitoring,\n        stopMonitoring,\n        runHealthCheck,\n        // Correlation ID tracking\n        correlationId: currentContext === null || currentContext === void 0 ? void 0 : currentContext.correlationId,\n        requestId: currentContext === null || currentContext === void 0 ? void 0 : currentContext.requestId,\n        spanId: currentContext === null || currentContext === void 0 ? void 0 : currentContext.spanId,\n        traceId: currentContext === null || currentContext === void 0 ? void 0 : currentContext.traceId,\n        generateCorrelationContext,\n        getCorrelationHeaders,\n        // Alert thresholds\n        alertThresholds,\n        alertHistory,\n        isAlertMonitoring,\n        startAlertMonitoring,\n        stopAlertMonitoring,\n        updateThreshold,\n        addThreshold,\n        removeThreshold,\n        // System status\n        systemStatus\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ObservabilityContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/macmini/Documents/Projects/SaaS Factory/ui/nextjs/src/components/providers/ObservabilityProvider.tsx\",\n        lineNumber: 273,\n        columnNumber: 5\n    }, this);\n}\n_s(ObservabilityProvider, \"JV24TfEYe5W8dFfUTNGuEEjxFAE=\");\n_c = ObservabilityProvider;\n// Hook to use observability context\nfunction useHealthMonitoring() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ObservabilityContext);\n    if (context === undefined) {\n        throw new Error('useHealthMonitoring must be used within an ObservabilityProvider');\n    }\n    return context;\n}\n_s1(useHealthMonitoring, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n// Hook to use correlation ID\nfunction useObservabilityCorrelationID() {\n    _s2();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ObservabilityContext);\n    if (context === undefined) {\n        throw new Error('useObservabilityCorrelationID must be used within an ObservabilityProvider');\n    }\n    return {\n        correlationId: context.correlationId,\n        requestId: context.requestId,\n        spanId: context.spanId,\n        traceId: context.traceId,\n        generateCorrelationContext: context.generateCorrelationContext,\n        getCorrelationHeaders: context.getCorrelationHeaders\n    };\n}\n_s2(useObservabilityCorrelationID, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n// Hook to use alert thresholds\nfunction useAlertThresholds() {\n    _s3();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ObservabilityContext);\n    if (context === undefined) {\n        throw new Error('useAlertThresholds must be used within an ObservabilityProvider');\n    }\n    return {\n        alertThresholds: context.alertThresholds,\n        alertHistory: context.alertHistory,\n        isAlertMonitoring: context.isAlertMonitoring,\n        startAlertMonitoring: context.startAlertMonitoring,\n        stopAlertMonitoring: context.stopAlertMonitoring,\n        updateThreshold: context.updateThreshold,\n        addThreshold: context.addThreshold,\n        removeThreshold: context.removeThreshold\n    };\n}\n_s3(useAlertThresholds, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n// Hook to use system status\nfunction useSystemStatus() {\n    _s4();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ObservabilityContext);\n    if (context === undefined) {\n        throw new Error('useSystemStatus must be used within an ObservabilityProvider');\n    }\n    return context.systemStatus;\n}\n_s4(useSystemStatus, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"ObservabilityProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3Byb3ZpZGVycy9PYnNlcnZhYmlsaXR5UHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFd0Y7QUFDcUI7QUFDaEM7QUFDdUI7QUFrRHBHLCtCQUErQjtBQUMvQixNQUFNUSxxQ0FBdUJQLG9EQUFhQSxDQUF1Q1E7QUFFakYsbUNBQW1DO0FBQzVCLFNBQVNDLHNCQUFzQixLQUFxQztRQUFyQyxFQUFFQyxRQUFRLEVBQTJCLEdBQXJDOztJQUNwQywwQkFBMEI7SUFDMUIsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR1YsK0NBQVFBLENBQXNCO0lBQ3hFLE1BQU0sQ0FBQ1csZUFBZUMsaUJBQWlCLEdBQUdaLCtDQUFRQSxDQUFpQixFQUFFO0lBQ3JFLE1BQU0sQ0FBQ2EsZ0JBQWdCQyxrQkFBa0IsR0FBR2QsK0NBQVFBLENBQXVCLEVBQUU7SUFDN0UsTUFBTSxDQUFDZSxjQUFjQyxnQkFBZ0IsR0FBR2hCLCtDQUFRQSxDQUFDO0lBRWpELHdCQUF3QjtJQUN4QixNQUFNLENBQUNpQixpQkFBaUJDLG1CQUFtQixHQUFHbEIsK0NBQVFBLENBQW1CLEVBQUU7SUFDM0UsTUFBTSxDQUFDbUIsY0FBY0MsZ0JBQWdCLEdBQUdwQiwrQ0FBUUEsQ0FBZSxFQUFFO0lBQ2pFLE1BQU0sQ0FBQ3FCLG1CQUFtQkMscUJBQXFCLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUUzRCxzQkFBc0I7SUFDdEIsTUFBTSxDQUFDdUIsY0FBY0MsZ0JBQWdCLEdBQUd4QiwrQ0FBUUEsQ0FBQztRQUMvQ3lCLFFBQVE7UUFDUkMsUUFBUTtZQUFFQyxTQUFTO1lBQUdDLFVBQVU7WUFBR0MsVUFBVTtRQUFFO1FBQy9DQyxRQUFRO1FBQ1JDLFlBQVksSUFBSUMsT0FBT0MsV0FBVztJQUNwQztJQUVBLHNEQUFzRDtJQUN0RGhDLGdEQUFTQTsyQ0FBQztZQUNSLE1BQU1pQyxVQUFVL0IscUZBQW9DLENBQ2xERyxX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QUM1QzBCLHNCQUFzQmIsUUFBUWEsb0JBQW9CO1FBQ2xEQyxxQkFBcUJkLFFBQVFjLG1CQUFtQjtRQUNoRG9CLGlCQUFpQmxDLFFBQVFrQyxlQUFlO1FBQ3hDSSxjQUFjdEMsUUFBUXNDLFlBQVk7UUFDbENFLGlCQUFpQnhDLFFBQVF3QyxlQUFlO0lBQzFDO0FBQ0Y7SUFmZ0JxQjtBQWlCaEIsNEJBQTRCO0FBQ3JCLFNBQVNDOztJQUNkLE1BQU05RCxVQUFVbkMsaURBQVVBLENBQUNNO0lBQzNCLElBQUk2QixZQUFZNUIsV0FBVztRQUN6QixNQUFNLElBQUl1RixNQUFNO0lBQ2xCO0lBQ0EsT0FBTzNELFFBQVFYLFlBQVk7QUFDN0I7SUFOZ0J5RSIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2NvbXBvbmVudHMvcHJvdmlkZXJzL09ic2VydmFiaWxpdHlQcm92aWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGhlYWx0aE1vbml0b3JpbmcsIHR5cGUgSGVhbHRoUmVzdWx0LCB0eXBlIEhlYWx0aEluZGV4TWV0cmljcyB9IGZyb20gJ0AvbGliL2hlYWx0aC1tb25pdG9yaW5nLXNpbXBsZSdcbmltcG9ydCB7IGNvcnJlbGF0aW9uSURNYW5hZ2VyLCB1c2VDb3JyZWxhdGlvbklEIH0gZnJvbSAnQC9saWIvY29ycmVsYXRpb24taWQnXG5pbXBvcnQgeyBhbGVydFRocmVzaG9sZE1hbmFnZXIsIHR5cGUgQWxlcnRUaHJlc2hvbGQsIHR5cGUgQWxlcnRFdmVudCB9IGZyb20gJ0AvbGliL2FsZXJ0LXRocmVzaG9sZHMnXG5cbi8vIE9ic2VydmFiaWxpdHkgY29udGV4dCBpbnRlcmZhY2VcbmludGVyZmFjZSBPYnNlcnZhYmlsaXR5Q29udGV4dFR5cGUge1xuICAvLyBIZWFsdGggbW9uaXRvcmluZ1xuICBjdXJyZW50SGVhbHRoOiBIZWFsdGhSZXN1bHQgfCBudWxsXG4gIGhlYWx0aEhpc3Rvcnk6IEhlYWx0aFJlc3VsdFtdXG4gIG1ldHJpY3NIaXN0b3J5OiBIZWFsdGhJbmRleE1ldHJpY3NbXVxuICBpc01vbml0b3Jpbmc6IGJvb2xlYW5cbiAgc3RhcnRNb25pdG9yaW5nOiAoKSA9PiB2b2lkXG4gIHN0b3BNb25pdG9yaW5nOiAoKSA9PiB2b2lkXG4gIHJ1bkhlYWx0aENoZWNrOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4gIFxuICAvLyBDb3JyZWxhdGlvbiBJRCB0cmFja2luZ1xuICBjb3JyZWxhdGlvbklkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgcmVxdWVzdElkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgc3BhbklkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgdHJhY2VJZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIGdlbmVyYXRlQ29ycmVsYXRpb25Db250ZXh0OiAoXG4gICAgcGFyZW50SWQ/OiBzdHJpbmcsXG4gICAgdXNlcklkPzogc3RyaW5nLFxuICAgIHRlbmFudElkPzogc3RyaW5nLFxuICAgIHNlc3Npb25JZD86IHN0cmluZyxcbiAgICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgKSA9PiB2b2lkXG4gIGdldENvcnJlbGF0aW9uSGVhZGVyczogKCkgPT4gUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICBcbiAgLy8gQWxlcnQgdGhyZXNob2xkc1xuICBhbGVydFRocmVzaG9sZHM6IEFsZXJ0VGhyZXNob2xkW11cbiAgYWxlcnRIaXN0b3J5OiBBbGVydEV2ZW50W11cbiAgaXNBbGVydE1vbml0b3Jpbmc6IGJvb2xlYW5cbiAgc3RhcnRBbGVydE1vbml0b3Jpbmc6ICgpID0+IHZvaWRcbiAgc3RvcEFsZXJ0TW9uaXRvcmluZzogKCkgPT4gdm9pZFxuICB1cGRhdGVUaHJlc2hvbGQ6IChuYW1lOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8QWxlcnRUaHJlc2hvbGQ+KSA9PiBib29sZWFuXG4gIGFkZFRocmVzaG9sZDogKHRocmVzaG9sZDogQWxlcnRUaHJlc2hvbGQpID0+IHZvaWRcbiAgcmVtb3ZlVGhyZXNob2xkOiAobmFtZTogc3RyaW5nKSA9PiBib29sZWFuXG4gIFxuICAvLyBTeXN0ZW0gc3RhdHVzXG4gIHN5c3RlbVN0YXR1czoge1xuICAgIGhlYWx0aDogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknXG4gICAgYWxlcnRzOiB7XG4gICAgICB3YXJuaW5nOiBudW1iZXJcbiAgICAgIGNyaXRpY2FsOiBudW1iZXJcbiAgICAgIHJlc29sdmVkOiBudW1iZXJcbiAgICB9XG4gICAgdXB0aW1lOiBudW1iZXJcbiAgICBsYXN0VXBkYXRlOiBzdHJpbmdcbiAgfVxufVxuXG4vLyBDcmVhdGUgb2JzZXJ2YWJpbGl0eSBjb250ZXh0XG5jb25zdCBPYnNlcnZhYmlsaXR5Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8T2JzZXJ2YWJpbGl0eUNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpXG5cbi8vIE9ic2VydmFiaWxpdHkgcHJvdmlkZXIgY29tcG9uZW50XG5leHBvcnQgZnVuY3Rpb24gT2JzZXJ2YWJpbGl0eVByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3ROb2RlIH0pIHtcbiAgLy8gSGVhbHRoIG1vbml0b3Jpbmcgc3RhdGVcbiAgY29uc3QgW2N1cnJlbnRIZWFsdGgsIHNldEN1cnJlbnRIZWFsdGhdID0gdXNlU3RhdGU8SGVhbHRoUmVzdWx0IHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2hlYWx0aEhpc3RvcnksIHNldEhlYWx0aEhpc3RvcnldID0gdXNlU3RhdGU8SGVhbHRoUmVzdWx0W10+KFtdKVxuICBjb25zdCBbbWV0cmljc0hpc3RvcnksIHNldE1ldHJpY3NIaXN0b3J5XSA9IHVzZVN0YXRlPEhlYWx0aEluZGV4TWV0cmljc1tdPihbXSlcbiAgY29uc3QgW2lzTW9uaXRvcmluZywgc2V0SXNNb25pdG9yaW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIC8vIEFsZXJ0IHRocmVzaG9sZCBzdGF0ZVxuICBjb25zdCBbYWxlcnRUaHJlc2hvbGRzLCBzZXRBbGVydFRocmVzaG9sZHNdID0gdXNlU3RhdGU8QWxlcnRUaHJlc2hvbGRbXT4oW10pXG4gIGNvbnN0IFthbGVydEhpc3RvcnksIHNldEFsZXJ0SGlzdG9yeV0gPSB1c2VTdGF0ZTxBbGVydEV2ZW50W10+KFtdKVxuICBjb25zdCBbaXNBbGVydE1vbml0b3JpbmcsIHNldElzQWxlcnRNb25pdG9yaW5nXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIC8vIFN5c3RlbSBzdGF0dXMgc3RhdGVcbiAgY29uc3QgW3N5c3RlbVN0YXR1cywgc2V0U3lzdGVtU3RhdHVzXSA9IHVzZVN0YXRlKHtcbiAgICBoZWFsdGg6ICdoZWFsdGh5JyBhcyBjb25zdCxcbiAgICBhbGVydHM6IHsgd2FybmluZzogMCwgY3JpdGljYWw6IDAsIHJlc29sdmVkOiAwIH0sXG4gICAgdXB0aW1lOiAwLFxuICAgIGxhc3RVcGRhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICB9KVxuXG4gIC8vIEluaXRpYWxpemUgY29ycmVsYXRpb24gSUQgY29udGV4dCBmb3IgdGhpcyBwcm92aWRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjb3JyZWxhdGlvbklETWFuYWdlci5nZW5lcmF0ZUNvbnRleHQoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB7IG9wZXJhdGlvbjogJ29ic2VydmFiaWxpdHlfcHJvdmlkZXJfaW5pdCcsIGNvbXBvbmVudDogJ09ic2VydmFiaWxpdHlQcm92aWRlcicgfVxuICAgIClcbiAgICBcbiAgICAvLyBMb2cgdGhlIGluaXRpYWxpemF0aW9uXG4gICAgY29ycmVsYXRpb25JRE1hbmFnZXIubG9nQ29udGV4dChjb250ZXh0LCAnaW5mbycpXG4gIH0sIFtdKVxuXG4gIC8vIEluaXRpYWxpemUgaGVhbHRoIG1vbml0b3JpbmdcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsaXplSGVhbHRoTW9uaXRvcmluZyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFJ1biBpbml0aWFsIGhlYWx0aCBjaGVja1xuICAgICAgICBhd2FpdCBydW5IZWFsdGhDaGVjaygpXG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCBtb25pdG9yaW5nXG4gICAgICAgIHN0YXJ0TW9uaXRvcmluZygpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBoZWFsdGggbW9uaXRvcmluZzonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0aWFsaXplSGVhbHRoTW9uaXRvcmluZygpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RvcE1vbml0b3JpbmcoKVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gSW5pdGlhbGl6ZSBhbGVydCB0aHJlc2hvbGRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdGhyZXNob2xkcyA9IGFsZXJ0VGhyZXNob2xkTWFuYWdlci5nZXRBbGxUaHJlc2hvbGRzKClcbiAgICBzZXRBbGVydFRocmVzaG9sZHModGhyZXNob2xkcylcbiAgICBcbiAgICAvLyBTdGFydCBhbGVydCBtb25pdG9yaW5nXG4gICAgc3RhcnRBbGVydE1vbml0b3JpbmcoKVxuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdG9wQWxlcnRNb25pdG9yaW5nKClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8vIFVwZGF0ZSBzeXN0ZW0gc3RhdHVzIHBlcmlvZGljYWxseVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZVN5c3RlbVN0YXR1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGhlYWx0aCA9IGN1cnJlbnRIZWFsdGg/LnN0YXR1cyB8fCAnaGVhbHRoeSdcbiAgICAgIGNvbnN0IGFsZXJ0cyA9IHtcbiAgICAgICAgd2FybmluZzogYWxlcnRIaXN0b3J5LmZpbHRlcihhID0+IGEuc3RhdHVzID09PSAnd2FybmluZycpLmxlbmd0aCxcbiAgICAgICAgY3JpdGljYWw6IGFsZXJ0SGlzdG9yeS5maWx0ZXIoYSA9PiBhLnN0YXR1cyA9PT0gJ2NyaXRpY2FsJykubGVuZ3RoLFxuICAgICAgICByZXNvbHZlZDogYWxlcnRIaXN0b3J5LmZpbHRlcihhID0+IGEuc3RhdHVzID09PSAncmVzb2x2ZWQnKS5sZW5ndGhcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVwdGltZSA9IGN1cnJlbnRIZWFsdGggPyBEYXRlLm5vdygpIC0gbmV3IERhdGUoY3VycmVudEhlYWx0aC50aW1lc3RhbXApLmdldFRpbWUoKSA6IDBcbiAgICAgIFxuICAgICAgc2V0U3lzdGVtU3RhdHVzKHtcbiAgICAgICAgaGVhbHRoLFxuICAgICAgICBhbGVydHMsXG4gICAgICAgIHVwdGltZSxcbiAgICAgICAgbGFzdFVwZGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwodXBkYXRlU3lzdGVtU3RhdHVzLCAxMDAwMCkgLy8gVXBkYXRlIGV2ZXJ5IDEwIHNlY29uZHNcbiAgICB1cGRhdGVTeXN0ZW1TdGF0dXMoKSAvLyBJbml0aWFsIHVwZGF0ZVxuXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gIH0sIFtjdXJyZW50SGVhbHRoLCBhbGVydEhpc3RvcnldKVxuXG4gIC8vIEhlYWx0aCBtb25pdG9yaW5nIGZ1bmN0aW9uc1xuICBjb25zdCBzdGFydE1vbml0b3JpbmcgPSAoKSA9PiB7XG4gICAgaGVhbHRoTW9uaXRvcmluZy5zdGFydE1vbml0b3JpbmcoKVxuICAgIHNldElzTW9uaXRvcmluZyh0cnVlKVxuICB9XG5cbiAgY29uc3Qgc3RvcE1vbml0b3JpbmcgPSAoKSA9PiB7XG4gICAgaGVhbHRoTW9uaXRvcmluZy5zdG9wTW9uaXRvcmluZygpXG4gICAgc2V0SXNNb25pdG9yaW5nKGZhbHNlKVxuICB9XG5cbiAgY29uc3QgcnVuSGVhbHRoQ2hlY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhlYWx0aE1vbml0b3JpbmcucnVuQ29tcHJlaGVuc2l2ZUhlYWx0aENoZWNrKClcbiAgICAgIHNldEN1cnJlbnRIZWFsdGgocmVzdWx0KVxuICAgICAgc2V0SGVhbHRoSGlzdG9yeShoZWFsdGhNb25pdG9yaW5nLmdldEhlYWx0aEhpc3RvcnkoKSlcbiAgICAgIHNldE1ldHJpY3NIaXN0b3J5KGhlYWx0aE1vbml0b3JpbmcuZ2V0TWV0cmljc0hpc3RvcnkoKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignSGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBBbGVydCBtb25pdG9yaW5nIGZ1bmN0aW9uc1xuICBjb25zdCBzdGFydEFsZXJ0TW9uaXRvcmluZyA9ICgpID0+IHtcbiAgICBhbGVydFRocmVzaG9sZE1hbmFnZXIuc3RhcnRNb25pdG9yaW5nKClcbiAgICBzZXRJc0FsZXJ0TW9uaXRvcmluZyh0cnVlKVxuICAgIFxuICAgIC8vIFNldCB1cCBwZXJpb2RpYyBhbGVydCBoaXN0b3J5IHVwZGF0ZXNcbiAgICBjb25zdCB1cGRhdGVBbGVydEhpc3RvcnkgPSAoKSA9PiB7XG4gICAgICBzZXRBbGVydEhpc3RvcnkoYWxlcnRUaHJlc2hvbGRNYW5hZ2VyLmdldEFsZXJ0SGlzdG9yeSgpKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKHVwZGF0ZUFsZXJ0SGlzdG9yeSwgNTAwMCkgLy8gVXBkYXRlIGV2ZXJ5IDUgc2Vjb25kc1xuICAgIHVwZGF0ZUFsZXJ0SGlzdG9yeSgpIC8vIEluaXRpYWwgdXBkYXRlXG4gICAgXG4gICAgLy8gU3RvcmUgaW50ZXJ2YWwgZm9yIGNsZWFudXBcbiAgICA7KHdpbmRvdyBhcyBhbnkpLmFsZXJ0SGlzdG9yeUludGVydmFsID0gaW50ZXJ2YWxcbiAgfVxuXG4gIGNvbnN0IHN0b3BBbGVydE1vbml0b3JpbmcgPSAoKSA9PiB7XG4gICAgYWxlcnRUaHJlc2hvbGRNYW5hZ2VyLnN0b3BNb25pdG9yaW5nKClcbiAgICBzZXRJc0FsZXJ0TW9uaXRvcmluZyhmYWxzZSlcbiAgICBcbiAgICAvLyBDbGVhciBpbnRlcnZhbFxuICAgIGlmICgod2luZG93IGFzIGFueSkuYWxlcnRIaXN0b3J5SW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoKHdpbmRvdyBhcyBhbnkpLmFsZXJ0SGlzdG9yeUludGVydmFsKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZVRocmVzaG9sZCA9IChuYW1lOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8QWxlcnRUaHJlc2hvbGQ+KTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3Qgc3VjY2VzcyA9IGFsZXJ0VGhyZXNob2xkTWFuYWdlci51cGRhdGVUaHJlc2hvbGQobmFtZSwgdXBkYXRlcylcbiAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgc2V0QWxlcnRUaHJlc2hvbGRzKGFsZXJ0VGhyZXNob2xkTWFuYWdlci5nZXRBbGxUaHJlc2hvbGRzKCkpXG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzXG4gIH1cblxuICBjb25zdCBhZGRUaHJlc2hvbGQgPSAodGhyZXNob2xkOiBBbGVydFRocmVzaG9sZCkgPT4ge1xuICAgIGFsZXJ0VGhyZXNob2xkTWFuYWdlci5hZGRUaHJlc2hvbGQodGhyZXNob2xkKVxuICAgIHNldEFsZXJ0VGhyZXNob2xkcyhhbGVydFRocmVzaG9sZE1hbmFnZXIuZ2V0QWxsVGhyZXNob2xkcygpKVxuICB9XG5cbiAgY29uc3QgcmVtb3ZlVGhyZXNob2xkID0gKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhbGVydFRocmVzaG9sZE1hbmFnZXIucmVtb3ZlVGhyZXNob2xkKG5hbWUpXG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHNldEFsZXJ0VGhyZXNob2xkcyhhbGVydFRocmVzaG9sZE1hbmFnZXIuZ2V0QWxsVGhyZXNob2xkcygpKVxuICAgIH1cbiAgICByZXR1cm4gc3VjY2Vzc1xuICB9XG5cbiAgLy8gQ29ycmVsYXRpb24gSUQgZnVuY3Rpb25zXG4gIGNvbnN0IGdlbmVyYXRlQ29ycmVsYXRpb25Db250ZXh0ID0gKFxuICAgIHBhcmVudElkPzogc3RyaW5nLFxuICAgIHVzZXJJZD86IHN0cmluZyxcbiAgICB0ZW5hbnRJZD86IHN0cmluZyxcbiAgICBzZXNzaW9uSWQ/OiBzdHJpbmcsXG4gICAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICkgPT4ge1xuICAgIGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdlbmVyYXRlQ29udGV4dChwYXJlbnRJZCwgdXNlcklkLCB0ZW5hbnRJZCwgc2Vzc2lvbklkLCBtZXRhZGF0YSlcbiAgfVxuXG4gIGNvbnN0IGdldENvcnJlbGF0aW9uSGVhZGVycyA9ICgpID0+IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEhlYWRlcnMoKVxuXG4gIC8vIEdldCBjdXJyZW50IGNvcnJlbGF0aW9uIGNvbnRleHRcbiAgY29uc3QgY3VycmVudENvbnRleHQgPSBjb3JyZWxhdGlvbklETWFuYWdlci5nZXRDdXJyZW50Q29udGV4dCgpXG5cbiAgLy8gQ29udGV4dCB2YWx1ZVxuICBjb25zdCBjb250ZXh0VmFsdWU6IE9ic2VydmFiaWxpdHlDb250ZXh0VHlwZSA9IHtcbiAgICAvLyBIZWFsdGggbW9uaXRvcmluZ1xuICAgIGN1cnJlbnRIZWFsdGgsXG4gICAgaGVhbHRoSGlzdG9yeSxcbiAgICBtZXRyaWNzSGlzdG9yeSxcbiAgICBpc01vbml0b3JpbmcsXG4gICAgc3RhcnRNb25pdG9yaW5nLFxuICAgIHN0b3BNb25pdG9yaW5nLFxuICAgIHJ1bkhlYWx0aENoZWNrLFxuICAgIFxuICAgIC8vIENvcnJlbGF0aW9uIElEIHRyYWNraW5nXG4gICAgY29ycmVsYXRpb25JZDogY3VycmVudENvbnRleHQ/LmNvcnJlbGF0aW9uSWQsXG4gICAgcmVxdWVzdElkOiBjdXJyZW50Q29udGV4dD8ucmVxdWVzdElkLFxuICAgIHNwYW5JZDogY3VycmVudENvbnRleHQ/LnNwYW5JZCxcbiAgICB0cmFjZUlkOiBjdXJyZW50Q29udGV4dD8udHJhY2VJZCxcbiAgICBnZW5lcmF0ZUNvcnJlbGF0aW9uQ29udGV4dCxcbiAgICBnZXRDb3JyZWxhdGlvbkhlYWRlcnMsXG4gICAgXG4gICAgLy8gQWxlcnQgdGhyZXNob2xkc1xuICAgIGFsZXJ0VGhyZXNob2xkcyxcbiAgICBhbGVydEhpc3RvcnksXG4gICAgaXNBbGVydE1vbml0b3JpbmcsXG4gICAgc3RhcnRBbGVydE1vbml0b3JpbmcsXG4gICAgc3RvcEFsZXJ0TW9uaXRvcmluZyxcbiAgICB1cGRhdGVUaHJlc2hvbGQsXG4gICAgYWRkVGhyZXNob2xkLFxuICAgIHJlbW92ZVRocmVzaG9sZCxcbiAgICBcbiAgICAvLyBTeXN0ZW0gc3RhdHVzXG4gICAgc3lzdGVtU3RhdHVzXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxPYnNlcnZhYmlsaXR5Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L09ic2VydmFiaWxpdHlDb250ZXh0LlByb3ZpZGVyPlxuICApXG59XG5cbi8vIEhvb2sgdG8gdXNlIG9ic2VydmFiaWxpdHkgY29udGV4dFxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhlYWx0aE1vbml0b3JpbmcoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE9ic2VydmFiaWxpdHlDb250ZXh0KVxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VIZWFsdGhNb25pdG9yaW5nIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gT2JzZXJ2YWJpbGl0eVByb3ZpZGVyJylcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuXG4vLyBIb29rIHRvIHVzZSBjb3JyZWxhdGlvbiBJRFxuZXhwb3J0IGZ1bmN0aW9uIHVzZU9ic2VydmFiaWxpdHlDb3JyZWxhdGlvbklEKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChPYnNlcnZhYmlsaXR5Q29udGV4dClcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlT2JzZXJ2YWJpbGl0eUNvcnJlbGF0aW9uSUQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBPYnNlcnZhYmlsaXR5UHJvdmlkZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgY29ycmVsYXRpb25JZDogY29udGV4dC5jb3JyZWxhdGlvbklkLFxuICAgIHJlcXVlc3RJZDogY29udGV4dC5yZXF1ZXN0SWQsXG4gICAgc3BhbklkOiBjb250ZXh0LnNwYW5JZCxcbiAgICB0cmFjZUlkOiBjb250ZXh0LnRyYWNlSWQsXG4gICAgZ2VuZXJhdGVDb3JyZWxhdGlvbkNvbnRleHQ6IGNvbnRleHQuZ2VuZXJhdGVDb3JyZWxhdGlvbkNvbnRleHQsXG4gICAgZ2V0Q29ycmVsYXRpb25IZWFkZXJzOiBjb250ZXh0LmdldENvcnJlbGF0aW9uSGVhZGVyc1xuICB9XG59XG5cbi8vIEhvb2sgdG8gdXNlIGFsZXJ0IHRocmVzaG9sZHNcbmV4cG9ydCBmdW5jdGlvbiB1c2VBbGVydFRocmVzaG9sZHMoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE9ic2VydmFiaWxpdHlDb250ZXh0KVxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VBbGVydFRocmVzaG9sZHMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBPYnNlcnZhYmlsaXR5UHJvdmlkZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgYWxlcnRUaHJlc2hvbGRzOiBjb250ZXh0LmFsZXJ0VGhyZXNob2xkcyxcbiAgICBhbGVydEhpc3Rvcnk6IGNvbnRleHQuYWxlcnRIaXN0b3J5LFxuICAgIGlzQWxlcnRNb25pdG9yaW5nOiBjb250ZXh0LmlzQWxlcnRNb25pdG9yaW5nLFxuICAgIHN0YXJ0QWxlcnRNb25pdG9yaW5nOiBjb250ZXh0LnN0YXJ0QWxlcnRNb25pdG9yaW5nLFxuICAgIHN0b3BBbGVydE1vbml0b3Jpbmc6IGNvbnRleHQuc3RvcEFsZXJ0TW9uaXRvcmluZyxcbiAgICB1cGRhdGVUaHJlc2hvbGQ6IGNvbnRleHQudXBkYXRlVGhyZXNob2xkLFxuICAgIGFkZFRocmVzaG9sZDogY29udGV4dC5hZGRUaHJlc2hvbGQsXG4gICAgcmVtb3ZlVGhyZXNob2xkOiBjb250ZXh0LnJlbW92ZVRocmVzaG9sZFxuICB9XG59XG5cbi8vIEhvb2sgdG8gdXNlIHN5c3RlbSBzdGF0dXNcbmV4cG9ydCBmdW5jdGlvbiB1c2VTeXN0ZW1TdGF0dXMoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE9ic2VydmFiaWxpdHlDb250ZXh0KVxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VTeXN0ZW1TdGF0dXMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhbiBPYnNlcnZhYmlsaXR5UHJvdmlkZXInKVxuICB9XG4gIHJldHVybiBjb250ZXh0LnN5c3RlbVN0YXR1c1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImhlYWx0aE1vbml0b3JpbmciLCJjb3JyZWxhdGlvbklETWFuYWdlciIsImFsZXJ0VGhyZXNob2xkTWFuYWdlciIsIk9ic2VydmFiaWxpdHlDb250ZXh0IiwidW5kZWZpbmVkIiwiT2JzZXJ2YWJpbGl0eVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJjdXJyZW50SGVhbHRoIiwic2V0Q3VycmVudEhlYWx0aCIsImhlYWx0aEhpc3RvcnkiLCJzZXRIZWFsdGhIaXN0b3J5IiwibWV0cmljc0hpc3RvcnkiLCJzZXRNZXRyaWNzSGlzdG9yeSIsImlzTW9uaXRvcmluZyIsInNldElzTW9uaXRvcmluZyIsImFsZXJ0VGhyZXNob2xkcyIsInNldEFsZXJ0VGhyZXNob2xkcyIsImFsZXJ0SGlzdG9yeSIsInNldEFsZXJ0SGlzdG9yeSIsImlzQWxlcnRNb25pdG9yaW5nIiwic2V0SXNBbGVydE1vbml0b3JpbmciLCJzeXN0ZW1TdGF0dXMiLCJzZXRTeXN0ZW1TdGF0dXMiLCJoZWFsdGgiLCJhbGVydHMiLCJ3YXJuaW5nIiwiY3JpdGljYWwiLCJyZXNvbHZlZCIsInVwdGltZSIsImxhc3RVcGRhdGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJjb250ZXh0IiwiZ2VuZXJhdGVDb250ZXh0Iiwib3BlcmF0aW9uIiwiY29tcG9uZW50IiwibG9nQ29udGV4dCIsImluaXRpYWxpemVIZWFsdGhNb25pdG9yaW5nIiwicnVuSGVhbHRoQ2hlY2siLCJzdGFydE1vbml0b3JpbmciLCJlcnJvciIsImNvbnNvbGUiLCJzdG9wTW9uaXRvcmluZyIsInRocmVzaG9sZHMiLCJnZXRBbGxUaHJlc2hvbGRzIiwic3RhcnRBbGVydE1vbml0b3JpbmciLCJzdG9wQWxlcnRNb25pdG9yaW5nIiwidXBkYXRlU3lzdGVtU3RhdHVzIiwic3RhdHVzIiwiZmlsdGVyIiwiYSIsImxlbmd0aCIsIm5vdyIsInRpbWVzdGFtcCIsImdldFRpbWUiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInJlc3VsdCIsInJ1bkNvbXByZWhlbnNpdmVIZWFsdGhDaGVjayIsImdldEhlYWx0aEhpc3RvcnkiLCJnZXRNZXRyaWNzSGlzdG9yeSIsInVwZGF0ZUFsZXJ0SGlzdG9yeSIsImdldEFsZXJ0SGlzdG9yeSIsIndpbmRvdyIsImFsZXJ0SGlzdG9yeUludGVydmFsIiwidXBkYXRlVGhyZXNob2xkIiwibmFtZSIsInVwZGF0ZXMiLCJzdWNjZXNzIiwiYWRkVGhyZXNob2xkIiwidGhyZXNob2xkIiwicmVtb3ZlVGhyZXNob2xkIiwiZ2VuZXJhdGVDb3JyZWxhdGlvbkNvbnRleHQiLCJwYXJlbnRJZCIsInVzZXJJZCIsInRlbmFudElkIiwic2Vzc2lvbklkIiwibWV0YWRhdGEiLCJnZXRDb3JyZWxhdGlvbkhlYWRlcnMiLCJnZXRIZWFkZXJzIiwiY3VycmVudENvbnRleHQiLCJnZXRDdXJyZW50Q29udGV4dCIsImNvbnRleHRWYWx1ZSIsImNvcnJlbGF0aW9uSWQiLCJyZXF1ZXN0SWQiLCJzcGFuSWQiLCJ0cmFjZUlkIiwiUHJvdmlkZXIiLCJ2YWx1ZSIsInVzZUhlYWx0aE1vbml0b3JpbmciLCJFcnJvciIsInVzZU9ic2VydmFiaWxpdHlDb3JyZWxhdGlvbklEIiwidXNlQWxlcnRUaHJlc2hvbGRzIiwidXNlU3lzdGVtU3RhdHVzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/providers/ObservabilityProvider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/alert-thresholds.ts":
/*!*************************************!*\
  !*** ./src/lib/alert-thresholds.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AlertThresholdManager: () => (/* binding */ AlertThresholdManager),\n/* harmony export */   alertThresholdManager: () => (/* binding */ alertThresholdManager)\n/* harmony export */ });\n/* harmony import */ var _correlation_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./correlation-id */ \"(app-pages-browser)/./src/lib/correlation-id.ts\");\n\n// Alert threshold manager\nclass AlertThresholdManager {\n    static getInstance() {\n        if (!AlertThresholdManager.instance) {\n            AlertThresholdManager.instance = new AlertThresholdManager();\n        }\n        return AlertThresholdManager.instance;\n    }\n    // Initialize default production thresholds\n    initializeDefaultThresholds() {\n        const defaultThresholds = [\n            // Performance thresholds\n            {\n                name: 'Error Rate Warning',\n                metric: 'error_rate',\n                warning: 2.0,\n                critical: 5.0,\n                enabled: true,\n                description: 'System error rate threshold',\n                category: 'performance',\n                severity: 'medium',\n                cooldown: 300,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        5.0,\n                        10.0,\n                        15.0\n                    ],\n                    contacts: [\n                        'dev-team',\n                        'oncall',\n                        'management'\n                    ]\n                }\n            },\n            {\n                name: 'Response Time Warning',\n                metric: 'response_time',\n                warning: 500,\n                critical: 2000,\n                enabled: true,\n                description: 'API response time threshold',\n                category: 'performance',\n                severity: 'medium',\n                cooldown: 300,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        2000,\n                        5000,\n                        10000\n                    ],\n                    contacts: [\n                        'dev-team',\n                        'oncall'\n                    ]\n                }\n            },\n            {\n                name: 'CPU Usage Warning',\n                metric: 'cpu_usage',\n                warning: 70.0,\n                critical: 85.0,\n                enabled: true,\n                description: 'CPU utilization threshold',\n                category: 'performance',\n                severity: 'high',\n                cooldown: 180,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        85.0,\n                        90.0,\n                        95.0\n                    ],\n                    contacts: [\n                        'ops-team',\n                        'oncall',\n                        'management'\n                    ]\n                }\n            },\n            {\n                name: 'Memory Usage Warning',\n                metric: 'memory_usage',\n                warning: 80.0,\n                critical: 90.0,\n                enabled: true,\n                description: 'Memory utilization threshold',\n                category: 'performance',\n                severity: 'high',\n                cooldown: 180,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        90.0,\n                        95.0,\n                        98.0\n                    ],\n                    contacts: [\n                        'ops-team',\n                        'oncall',\n                        'management'\n                    ]\n                }\n            },\n            {\n                name: 'Disk Usage Warning',\n                metric: 'disk_usage',\n                warning: 75.0,\n                critical: 85.0,\n                enabled: true,\n                description: 'Disk space utilization threshold',\n                category: 'performance',\n                severity: 'medium',\n                cooldown: 600,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        85.0,\n                        90.0,\n                        95.0\n                    ],\n                    contacts: [\n                        'ops-team',\n                        'oncall'\n                    ]\n                }\n            },\n            // Availability thresholds\n            {\n                name: 'Uptime Warning',\n                metric: 'uptime',\n                warning: 99.0,\n                critical: 95.0,\n                enabled: true,\n                description: 'System uptime threshold',\n                category: 'availability',\n                severity: 'critical',\n                cooldown: 60,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        95.0,\n                        90.0,\n                        80.0\n                    ],\n                    contacts: [\n                        'oncall',\n                        'management',\n                        'executive'\n                    ]\n                }\n            },\n            {\n                name: 'Health Check Failure',\n                metric: 'health_check_failure',\n                warning: 1,\n                critical: 3,\n                enabled: true,\n                description: 'Health check failure threshold',\n                category: 'availability',\n                severity: 'high',\n                cooldown: 120,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        3,\n                        5,\n                        10\n                    ],\n                    contacts: [\n                        'dev-team',\n                        'oncall',\n                        'management'\n                    ]\n                }\n            },\n            // Security thresholds\n            {\n                name: 'Failed Login Attempts',\n                metric: 'failed_logins',\n                warning: 10,\n                critical: 50,\n                enabled: true,\n                description: 'Failed authentication attempts threshold',\n                category: 'security',\n                severity: 'high',\n                cooldown: 300,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        50,\n                        100,\n                        200\n                    ],\n                    contacts: [\n                        'security-team',\n                        'oncall',\n                        'management'\n                    ]\n                }\n            },\n            {\n                name: 'API Rate Limit Exceeded',\n                metric: 'rate_limit_exceeded',\n                warning: 100,\n                critical: 1000,\n                enabled: true,\n                description: 'API rate limit violation threshold',\n                category: 'security',\n                severity: 'medium',\n                cooldown: 180,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        1000,\n                        5000,\n                        10000\n                    ],\n                    contacts: [\n                        'security-team',\n                        'dev-team'\n                    ]\n                }\n            },\n            // Business thresholds\n            {\n                name: 'Transaction Failure Rate',\n                metric: 'transaction_failure_rate',\n                warning: 1.0,\n                critical: 5.0,\n                enabled: true,\n                description: 'Business transaction failure threshold',\n                category: 'business',\n                severity: 'critical',\n                cooldown: 60,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        5.0,\n                        10.0,\n                        20.0\n                    ],\n                    contacts: [\n                        'business-team',\n                        'management',\n                        'executive'\n                    ]\n                }\n            },\n            {\n                name: 'Revenue Impact',\n                metric: 'revenue_impact',\n                warning: 1000,\n                critical: 10000,\n                enabled: true,\n                description: 'Revenue impact threshold',\n                category: 'business',\n                severity: 'critical',\n                cooldown: 300,\n                escalation: {\n                    enabled: true,\n                    levels: [\n                        10000,\n                        50000,\n                        100000\n                    ],\n                    contacts: [\n                        'business-team',\n                        'executive',\n                        'board'\n                    ]\n                }\n            }\n        ];\n        defaultThresholds.forEach((threshold)=>{\n            this.thresholds.set(threshold.name, threshold);\n        });\n    }\n    // Add or update a threshold\n    addThreshold(threshold) {\n        this.thresholds.set(threshold.name, threshold);\n        this.logThresholdChange('added', threshold);\n    }\n    // Remove a threshold\n    removeThreshold(name) {\n        const threshold = this.thresholds.get(name);\n        if (threshold) {\n            this.thresholds.delete(name);\n            this.logThresholdChange('removed', threshold);\n            return true;\n        }\n        return false;\n    }\n    // Get all thresholds\n    getAllThresholds() {\n        return Array.from(this.thresholds.values());\n    }\n    // Get threshold by name\n    getThreshold(name) {\n        return this.thresholds.get(name);\n    }\n    // Update threshold values\n    updateThreshold(name, updates) {\n        const threshold = this.thresholds.get(name);\n        if (threshold) {\n            const updatedThreshold = {\n                ...threshold,\n                ...updates\n            };\n            this.thresholds.set(name, updatedThreshold);\n            this.logThresholdChange('updated', updatedThreshold);\n            return true;\n        }\n        return false;\n    }\n    // Check if a metric value triggers an alert\n    checkThreshold(metric, value) {\n        const triggeredAlerts = [];\n        const now = Date.now();\n        for (const threshold of this.thresholds.values()){\n            if (!threshold.enabled || threshold.metric !== metric) continue;\n            // Check cooldown\n            if (threshold.lastTriggered && now - threshold.lastTriggered < threshold.cooldown * 1000) {\n                continue;\n            }\n            let status = null;\n            if (value >= threshold.critical) {\n                status = 'critical';\n            } else if (value >= threshold.warning) {\n                status = 'warning';\n            } else if (threshold.lastTriggered) {\n                // Check if we should resolve the alert\n                status = 'resolved';\n            }\n            if (status) {\n                var _correlationIDManager_getCurrentContext;\n                const alertEvent = {\n                    id: \"\".concat(threshold.name, \"_\").concat(now),\n                    threshold,\n                    value,\n                    status,\n                    timestamp: now,\n                    correlationId: (_correlationIDManager_getCurrentContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()) === null || _correlationIDManager_getCurrentContext === void 0 ? void 0 : _correlationIDManager_getCurrentContext.correlationId,\n                    metadata: {\n                        metric,\n                        value,\n                        threshold: {\n                            warning: threshold.warning,\n                            critical: threshold.critical\n                        },\n                        category: threshold.category,\n                        severity: threshold.severity\n                    }\n                };\n                triggeredAlerts.push(alertEvent);\n                // Update last triggered time for warning/critical alerts\n                if (status !== 'resolved') {\n                    threshold.lastTriggered = now;\n                    this.thresholds.set(threshold.name, threshold);\n                }\n                // Log the alert\n                this.logAlert(alertEvent);\n            }\n        }\n        return triggeredAlerts;\n    }\n    // Start monitoring thresholds\n    startMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        if (this.isMonitoring) return;\n        this.isMonitoring = true;\n        this.monitoringInterval = setInterval(()=>{\n            this.runThresholdChecks();\n        }, intervalMs);\n        console.log('Alert threshold monitoring started with interval:', intervalMs, 'ms');\n    }\n    // Stop monitoring thresholds\n    stopMonitoring() {\n        if (this.monitoringInterval) {\n            clearInterval(this.monitoringInterval);\n            this.monitoringInterval = null;\n        }\n        this.isMonitoring = false;\n        console.log('Alert threshold monitoring stopped');\n    }\n    // Run threshold checks (placeholder for actual metric collection)\n    async runThresholdChecks() {\n        // This would typically collect metrics from various sources\n        // For now, we'll just log that monitoring is active\n        const activeThresholds = this.getAllThresholds().filter((t)=>t.enabled);\n        if (activeThresholds.length > 0) {\n            console.log(\"Monitoring \".concat(activeThresholds.length, \" active thresholds\"));\n        }\n    }\n    // Get alert history\n    getAlertHistory() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;\n        return this.alertHistory.slice(-limit);\n    }\n    // Clear alert history\n    clearAlertHistory() {\n        this.alertHistory = [];\n    }\n    // Get alerts by status\n    getAlertsByStatus(status) {\n        return this.alertHistory.filter((alert)=>alert.status === status);\n    }\n    // Get alerts by category\n    getAlertsByCategory(category) {\n        return this.alertHistory.filter((alert)=>alert.threshold.category === category);\n    }\n    // Get alerts by severity\n    getAlertsBySeverity(severity) {\n        return this.alertHistory.filter((alert)=>alert.threshold.severity === severity);\n    }\n    // Log threshold changes\n    logThresholdChange(action, threshold) {\n        const context = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext();\n        if (context) {\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(context, 'info');\n        }\n        console.log(\"\\uD83D\\uDD14 Alert threshold \".concat(action, \":\"), {\n            name: threshold.name,\n            metric: threshold.metric,\n            warning: threshold.warning,\n            critical: threshold.critical,\n            category: threshold.category,\n            severity: threshold.severity,\n            correlationId: context === null || context === void 0 ? void 0 : context.correlationId\n        });\n    }\n    // Log alerts\n    logAlert(alert) {\n        // Add to history\n        this.alertHistory.push(alert);\n        if (this.alertHistory.length > 1000) {\n            this.alertHistory = this.alertHistory.slice(-1000);\n        }\n        // Log the alert\n        const emoji = alert.status === 'critical' ? '' : alert.status === 'warning' ? '' : '';\n        console.log(\"\".concat(emoji, \" Alert triggered:\"), {\n            name: alert.threshold.name,\n            status: alert.status,\n            value: alert.value,\n            threshold: alert.threshold,\n            timestamp: new Date(alert.timestamp).toISOString(),\n            correlationId: alert.correlationId\n        });\n        // TODO: Send alerts to external systems (Slack, PagerDuty, etc.)\n        this.sendExternalAlert(alert);\n    }\n    // Send external alert (placeholder)\n    async sendExternalAlert(alert) {\n        // This would integrate with external alerting systems\n        // For now, we'll just log that we would send it\n        console.log(\"\\uD83D\\uDCE4 Would send external alert for: \".concat(alert.threshold.name));\n    }\n    // Get monitoring status\n    getMonitoringStatus() {\n        return {\n            isActive: this.isMonitoring,\n            interval: this.monitoringInterval ? 30000 : null,\n            thresholdCount: this.thresholds.size\n        };\n    }\n    // Export thresholds to JSON\n    exportThresholds() {\n        return JSON.stringify(Array.from(this.thresholds.values()), null, 2);\n    }\n    // Import thresholds from JSON\n    importThresholds(jsonData) {\n        try {\n            const thresholds = JSON.parse(jsonData);\n            this.thresholds.clear();\n            thresholds.forEach((threshold)=>{\n                this.thresholds.set(threshold.name, threshold);\n            });\n            console.log(\"Imported \".concat(thresholds.length, \" thresholds\"));\n            return true;\n        } catch (error) {\n            console.error('Failed to import thresholds:', error);\n            return false;\n        }\n    }\n    constructor(){\n        this.thresholds = new Map();\n        this.alertHistory = [];\n        this.isMonitoring = false;\n        this.monitoringInterval = null;\n        this.initializeDefaultThresholds();\n    }\n}\n// Export singleton instance\nconst alertThresholdManager = AlertThresholdManager.getInstance();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWxlcnQtdGhyZXNob2xkcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFnQ3ZELDBCQUEwQjtBQUNuQixNQUFNQztJQU9YLE9BQU9DLGNBQXFDO1FBQzFDLElBQUksQ0FBQ0Qsc0JBQXNCRSxRQUFRLEVBQUU7WUFDbkNGLHNCQUFzQkUsUUFBUSxHQUFHLElBQUlGO1FBQ3ZDO1FBQ0EsT0FBT0Esc0JBQXNCRSxRQUFRO0lBQ3ZDO0lBTUEsMkNBQTJDO0lBQ25DQyw4QkFBb0M7UUFDMUMsTUFBTUMsb0JBQXNDO1lBQzFDLHlCQUF5QjtZQUN6QjtnQkFDRUMsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEMsVUFBVTtnQkFDVkMsU0FBUztnQkFDVEMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsWUFBWTtvQkFDVkwsU0FBUztvQkFDVE0sUUFBUTt3QkFBQzt3QkFBSzt3QkFBTTtxQkFBSztvQkFDekJDLFVBQVU7d0JBQUM7d0JBQVk7d0JBQVU7cUJBQWE7Z0JBQ2hEO1lBQ0Y7WUFDQTtnQkFDRVgsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEMsVUFBVTtnQkFDVkMsU0FBUztnQkFDVEMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsWUFBWTtvQkFDVkwsU0FBUztvQkFDVE0sUUFBUTt3QkFBQzt3QkFBTTt3QkFBTTtxQkFBTTtvQkFDM0JDLFVBQVU7d0JBQUM7d0JBQVk7cUJBQVM7Z0JBQ2xDO1lBQ0Y7WUFDQTtnQkFDRVgsTUFBTTtnQkFDTkMsUUFBUTtnQkFDUkMsU0FBUztnQkFDVEMsVUFBVTtnQkFDVkMsU0FBUztnQkFDVEMsYUFBYTtnQkFDYkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsVUFBVTtnQkFDVkMsWUFBWTtvQkFDVkwsU0FBUztvQkFDVE0sUUFBUTt3QkFBQzt3QkFBTTt3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LElBQUk7UUFDdEM7SUFDRjtJQUVBLDRCQUE0QjtJQUM1QkMsbUJBQTJCO1FBQ3pCLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQzFELE1BQU1DLElBQUksQ0FBQyxJQUFJLENBQUNULFVBQVUsQ0FBQ1UsTUFBTSxLQUFLLE1BQU07SUFDcEU7SUFFQSw4QkFBOEI7SUFDOUJ5RCxpQkFBaUJDLFFBQWdCLEVBQVc7UUFDMUMsSUFBSTtZQUNGLE1BQU1wRSxhQUFhaUUsS0FBS0ksS0FBSyxDQUFDRDtZQUM5QixJQUFJLENBQUNwRSxVQUFVLENBQUNzRSxLQUFLO1lBQ3JCdEUsV0FBV0YsT0FBTyxDQUFDQyxDQUFBQTtnQkFDakIsSUFBSSxDQUFDQyxVQUFVLENBQUNDLEdBQUcsQ0FBQ0YsVUFBVWIsSUFBSSxFQUFFYTtZQUN0QztZQUNBcUMsUUFBUUMsR0FBRyxDQUFDLFlBQThCLE9BQWxCckMsV0FBVzJDLE1BQU0sRUFBQztZQUMxQyxPQUFPO1FBQ1QsRUFBRSxPQUFPNEIsT0FBTztZQUNkbkMsUUFBUW1DLEtBQUssQ0FBQyxnQ0FBZ0NBO1lBQzlDLE9BQU87UUFDVDtJQUNGO0lBaGJBLGFBQWM7YUFaTnZFLGFBQTBDLElBQUl3RTthQUM5QzFCLGVBQTZCLEVBQUU7YUFDL0JkLGVBQXdCO2FBQ3hCQyxxQkFBNEM7UUFVbEQsSUFBSSxDQUFDakQsMkJBQTJCO0lBQ2xDO0FBK2FGO0FBRUEsNEJBQTRCO0FBQ3JCLE1BQU15Rix3QkFBd0I1RixzQkFBc0JDLFdBQVcsR0FBRSIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2xpYi9hbGVydC10aHJlc2hvbGRzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcnJlbGF0aW9uSURNYW5hZ2VyIH0gZnJvbSAnLi9jb3JyZWxhdGlvbi1pZCdcblxuLy8gQWxlcnQgdGhyZXNob2xkIGNvbmZpZ3VyYXRpb24gaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEFsZXJ0VGhyZXNob2xkIHtcbiAgbmFtZTogc3RyaW5nXG4gIG1ldHJpYzogc3RyaW5nXG4gIHdhcm5pbmc6IG51bWJlclxuICBjcml0aWNhbDogbnVtYmVyXG4gIGVuYWJsZWQ6IGJvb2xlYW5cbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyB8ICdhdmFpbGFiaWxpdHknIHwgJ3NlY3VyaXR5JyB8ICdidXNpbmVzcydcbiAgc2V2ZXJpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnXG4gIGNvb2xkb3duOiBudW1iZXIgLy8gc2Vjb25kcyBiZXR3ZWVuIGFsZXJ0c1xuICBsYXN0VHJpZ2dlcmVkPzogbnVtYmVyXG4gIGVzY2FsYXRpb24/OiB7XG4gICAgZW5hYmxlZDogYm9vbGVhblxuICAgIGxldmVsczogbnVtYmVyW11cbiAgICBjb250YWN0czogc3RyaW5nW11cbiAgfVxufVxuXG4vLyBBbGVydCBldmVudCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQWxlcnRFdmVudCB7XG4gIGlkOiBzdHJpbmdcbiAgdGhyZXNob2xkOiBBbGVydFRocmVzaG9sZFxuICB2YWx1ZTogbnVtYmVyXG4gIHN0YXR1czogJ3dhcm5pbmcnIHwgJ2NyaXRpY2FsJyB8ICdyZXNvbHZlZCdcbiAgdGltZXN0YW1wOiBudW1iZXJcbiAgY29ycmVsYXRpb25JZD86IHN0cmluZ1xuICBtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG4vLyBBbGVydCB0aHJlc2hvbGQgbWFuYWdlclxuZXhwb3J0IGNsYXNzIEFsZXJ0VGhyZXNob2xkTWFuYWdlciB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBBbGVydFRocmVzaG9sZE1hbmFnZXJcbiAgcHJpdmF0ZSB0aHJlc2hvbGRzOiBNYXA8c3RyaW5nLCBBbGVydFRocmVzaG9sZD4gPSBuZXcgTWFwKClcbiAgcHJpdmF0ZSBhbGVydEhpc3Rvcnk6IEFsZXJ0RXZlbnRbXSA9IFtdXG4gIHByaXZhdGUgaXNNb25pdG9yaW5nOiBib29sZWFuID0gZmFsc2VcbiAgcHJpdmF0ZSBtb25pdG9yaW5nSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGxcblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogQWxlcnRUaHJlc2hvbGRNYW5hZ2VyIHtcbiAgICBpZiAoIUFsZXJ0VGhyZXNob2xkTWFuYWdlci5pbnN0YW5jZSkge1xuICAgICAgQWxlcnRUaHJlc2hvbGRNYW5hZ2VyLmluc3RhbmNlID0gbmV3IEFsZXJ0VGhyZXNob2xkTWFuYWdlcigpXG4gICAgfVxuICAgIHJldHVybiBBbGVydFRocmVzaG9sZE1hbmFnZXIuaW5zdGFuY2VcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZURlZmF1bHRUaHJlc2hvbGRzKClcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgZGVmYXVsdCBwcm9kdWN0aW9uIHRocmVzaG9sZHNcbiAgcHJpdmF0ZSBpbml0aWFsaXplRGVmYXVsdFRocmVzaG9sZHMoKTogdm9pZCB7XG4gICAgY29uc3QgZGVmYXVsdFRocmVzaG9sZHM6IEFsZXJ0VGhyZXNob2xkW10gPSBbXG4gICAgICAvLyBQZXJmb3JtYW5jZSB0aHJlc2hvbGRzXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdFcnJvciBSYXRlIFdhcm5pbmcnLFxuICAgICAgICBtZXRyaWM6ICdlcnJvcl9yYXRlJyxcbiAgICAgICAgd2FybmluZzogMi4wLCAvLyAyJSBlcnJvciByYXRlXG4gICAgICAgIGNyaXRpY2FsOiA1LjAsIC8vIDUlIGVycm9yIHJhdGVcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdTeXN0ZW0gZXJyb3IgcmF0ZSB0aHJlc2hvbGQnLFxuICAgICAgICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICBjb29sZG93bjogMzAwLCAvLyA1IG1pbnV0ZXNcbiAgICAgICAgZXNjYWxhdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWxzOiBbNS4wLCAxMC4wLCAxNS4wXSxcbiAgICAgICAgICBjb250YWN0czogWydkZXYtdGVhbScsICdvbmNhbGwnLCAnbWFuYWdlbWVudCddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdSZXNwb25zZSBUaW1lIFdhcm5pbmcnLFxuICAgICAgICBtZXRyaWM6ICdyZXNwb25zZV90aW1lJyxcbiAgICAgICAgd2FybmluZzogNTAwLCAvLyA1MDBtc1xuICAgICAgICBjcml0aWNhbDogMjAwMCwgLy8gMiBzZWNvbmRzXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQVBJIHJlc3BvbnNlIHRpbWUgdGhyZXNob2xkJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdwZXJmb3JtYW5jZScsXG4gICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcbiAgICAgICAgY29vbGRvd246IDMwMCxcbiAgICAgICAgZXNjYWxhdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWxzOiBbMjAwMCwgNTAwMCwgMTAwMDBdLFxuICAgICAgICAgIGNvbnRhY3RzOiBbJ2Rldi10ZWFtJywgJ29uY2FsbCddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdDUFUgVXNhZ2UgV2FybmluZycsXG4gICAgICAgIG1ldHJpYzogJ2NwdV91c2FnZScsXG4gICAgICAgIHdhcm5pbmc6IDcwLjAsIC8vIDcwJVxuICAgICAgICBjcml0aWNhbDogODUuMCwgLy8gODUlXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQ1BVIHV0aWxpemF0aW9uIHRocmVzaG9sZCcsXG4gICAgICAgIGNhdGVnb3J5OiAncGVyZm9ybWFuY2UnLFxuICAgICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgICBjb29sZG93bjogMTgwLCAvLyAzIG1pbnV0ZXNcbiAgICAgICAgZXNjYWxhdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWxzOiBbODUuMCwgOTAuMCwgOTUuMF0sXG4gICAgICAgICAgY29udGFjdHM6IFsnb3BzLXRlYW0nLCAnb25jYWxsJywgJ21hbmFnZW1lbnQnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnTWVtb3J5IFVzYWdlIFdhcm5pbmcnLFxuICAgICAgICBtZXRyaWM6ICdtZW1vcnlfdXNhZ2UnLFxuICAgICAgICB3YXJuaW5nOiA4MC4wLCAvLyA4MCVcbiAgICAgICAgY3JpdGljYWw6IDkwLjAsIC8vIDkwJVxuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ01lbW9yeSB1dGlsaXphdGlvbiB0aHJlc2hvbGQnLFxuICAgICAgICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdoaWdoJyxcbiAgICAgICAgY29vbGRvd246IDE4MCxcbiAgICAgICAgZXNjYWxhdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWxzOiBbOTAuMCwgOTUuMCwgOTguMF0sXG4gICAgICAgICAgY29udGFjdHM6IFsnb3BzLXRlYW0nLCAnb25jYWxsJywgJ21hbmFnZW1lbnQnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnRGlzayBVc2FnZSBXYXJuaW5nJyxcbiAgICAgICAgbWV0cmljOiAnZGlza191c2FnZScsXG4gICAgICAgIHdhcm5pbmc6IDc1LjAsIC8vIDc1JVxuICAgICAgICBjcml0aWNhbDogODUuMCwgLy8gODUlXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRGlzayBzcGFjZSB1dGlsaXphdGlvbiB0aHJlc2hvbGQnLFxuICAgICAgICBjYXRlZ29yeTogJ3BlcmZvcm1hbmNlJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxuICAgICAgICBjb29sZG93bjogNjAwLCAvLyAxMCBtaW51dGVzXG4gICAgICAgIGVzY2FsYXRpb246IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGxldmVsczogWzg1LjAsIDkwLjAsIDk1LjBdLFxuICAgICAgICAgIGNvbnRhY3RzOiBbJ29wcy10ZWFtJywgJ29uY2FsbCddXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIEF2YWlsYWJpbGl0eSB0aHJlc2hvbGRzXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdVcHRpbWUgV2FybmluZycsXG4gICAgICAgIG1ldHJpYzogJ3VwdGltZScsXG4gICAgICAgIHdhcm5pbmc6IDk5LjAsIC8vIDk5JVxuICAgICAgICBjcml0aWNhbDogOTUuMCwgLy8gOTUlXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnU3lzdGVtIHVwdGltZSB0aHJlc2hvbGQnLFxuICAgICAgICBjYXRlZ29yeTogJ2F2YWlsYWJpbGl0eScsXG4gICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnLFxuICAgICAgICBjb29sZG93bjogNjAsIC8vIDEgbWludXRlXG4gICAgICAgIGVzY2FsYXRpb246IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGxldmVsczogWzk1LjAsIDkwLjAsIDgwLjBdLFxuICAgICAgICAgIGNvbnRhY3RzOiBbJ29uY2FsbCcsICdtYW5hZ2VtZW50JywgJ2V4ZWN1dGl2ZSddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdIZWFsdGggQ2hlY2sgRmFpbHVyZScsXG4gICAgICAgIG1ldHJpYzogJ2hlYWx0aF9jaGVja19mYWlsdXJlJyxcbiAgICAgICAgd2FybmluZzogMSwgLy8gMSBmYWlsdXJlXG4gICAgICAgIGNyaXRpY2FsOiAzLCAvLyAzIGZhaWx1cmVzXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnSGVhbHRoIGNoZWNrIGZhaWx1cmUgdGhyZXNob2xkJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdhdmFpbGFiaWxpdHknLFxuICAgICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgICBjb29sZG93bjogMTIwLCAvLyAyIG1pbnV0ZXNcbiAgICAgICAgZXNjYWxhdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWxzOiBbMywgNSwgMTBdLFxuICAgICAgICAgIGNvbnRhY3RzOiBbJ2Rldi10ZWFtJywgJ29uY2FsbCcsICdtYW5hZ2VtZW50J11cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gU2VjdXJpdHkgdGhyZXNob2xkc1xuICAgICAge1xuICAgICAgICBuYW1lOiAnRmFpbGVkIExvZ2luIEF0dGVtcHRzJyxcbiAgICAgICAgbWV0cmljOiAnZmFpbGVkX2xvZ2lucycsXG4gICAgICAgIHdhcm5pbmc6IDEwLCAvLyAxMCBhdHRlbXB0c1xuICAgICAgICBjcml0aWNhbDogNTAsIC8vIDUwIGF0dGVtcHRzXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnRmFpbGVkIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHRzIHRocmVzaG9sZCcsXG4gICAgICAgIGNhdGVnb3J5OiAnc2VjdXJpdHknLFxuICAgICAgICBzZXZlcml0eTogJ2hpZ2gnLFxuICAgICAgICBjb29sZG93bjogMzAwLFxuICAgICAgICBlc2NhbGF0aW9uOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBsZXZlbHM6IFs1MCwgMTAwLCAyMDBdLFxuICAgICAgICAgIGNvbnRhY3RzOiBbJ3NlY3VyaXR5LXRlYW0nLCAnb25jYWxsJywgJ21hbmFnZW1lbnQnXVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnQVBJIFJhdGUgTGltaXQgRXhjZWVkZWQnLFxuICAgICAgICBtZXRyaWM6ICdyYXRlX2xpbWl0X2V4Y2VlZGVkJyxcbiAgICAgICAgd2FybmluZzogMTAwLCAvLyAxMDAgcmVxdWVzdHNcbiAgICAgICAgY3JpdGljYWw6IDEwMDAsIC8vIDEwMDAgcmVxdWVzdHNcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdBUEkgcmF0ZSBsaW1pdCB2aW9sYXRpb24gdGhyZXNob2xkJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdzZWN1cml0eScsXG4gICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcbiAgICAgICAgY29vbGRvd246IDE4MCxcbiAgICAgICAgZXNjYWxhdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWxzOiBbMTAwMCwgNTAwMCwgMTAwMDBdLFxuICAgICAgICAgIGNvbnRhY3RzOiBbJ3NlY3VyaXR5LXRlYW0nLCAnZGV2LXRlYW0nXVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBCdXNpbmVzcyB0aHJlc2hvbGRzXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdUcmFuc2FjdGlvbiBGYWlsdXJlIFJhdGUnLFxuICAgICAgICBtZXRyaWM6ICd0cmFuc2FjdGlvbl9mYWlsdXJlX3JhdGUnLFxuICAgICAgICB3YXJuaW5nOiAxLjAsIC8vIDElXG4gICAgICAgIGNyaXRpY2FsOiA1LjAsIC8vIDUlXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnQnVzaW5lc3MgdHJhbnNhY3Rpb24gZmFpbHVyZSB0aHJlc2hvbGQnLFxuICAgICAgICBjYXRlZ29yeTogJ2J1c2luZXNzJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgIGNvb2xkb3duOiA2MCxcbiAgICAgICAgZXNjYWxhdGlvbjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgbGV2ZWxzOiBbNS4wLCAxMC4wLCAyMC4wXSxcbiAgICAgICAgICBjb250YWN0czogWydidXNpbmVzcy10ZWFtJywgJ21hbmFnZW1lbnQnLCAnZXhlY3V0aXZlJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1JldmVudWUgSW1wYWN0JyxcbiAgICAgICAgbWV0cmljOiAncmV2ZW51ZV9pbXBhY3QnLFxuICAgICAgICB3YXJuaW5nOiAxMDAwLCAvLyAkMTAwMFxuICAgICAgICBjcml0aWNhbDogMTAwMDAsIC8vICQxMCwwMDBcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgZGVzY3JpcHRpb246ICdSZXZlbnVlIGltcGFjdCB0aHJlc2hvbGQnLFxuICAgICAgICBjYXRlZ29yeTogJ2J1c2luZXNzJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdjcml0aWNhbCcsXG4gICAgICAgIGNvb2xkb3duOiAzMDAsXG4gICAgICAgIGVzY2FsYXRpb246IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIGxldmVsczogWzEwMDAwLCA1MDAwMCwgMTAwMDAwXSxcbiAgICAgICAgICBjb250YWN0czogWydidXNpbmVzcy10ZWFtJywgJ2V4ZWN1dGl2ZScsICdib2FyZCddXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG5cbiAgICBkZWZhdWx0VGhyZXNob2xkcy5mb3JFYWNoKHRocmVzaG9sZCA9PiB7XG4gICAgICB0aGlzLnRocmVzaG9sZHMuc2V0KHRocmVzaG9sZC5uYW1lLCB0aHJlc2hvbGQpXG4gICAgfSlcbiAgfVxuXG4gIC8vIEFkZCBvciB1cGRhdGUgYSB0aHJlc2hvbGRcbiAgYWRkVGhyZXNob2xkKHRocmVzaG9sZDogQWxlcnRUaHJlc2hvbGQpOiB2b2lkIHtcbiAgICB0aGlzLnRocmVzaG9sZHMuc2V0KHRocmVzaG9sZC5uYW1lLCB0aHJlc2hvbGQpXG4gICAgdGhpcy5sb2dUaHJlc2hvbGRDaGFuZ2UoJ2FkZGVkJywgdGhyZXNob2xkKVxuICB9XG5cbiAgLy8gUmVtb3ZlIGEgdGhyZXNob2xkXG4gIHJlbW92ZVRocmVzaG9sZChuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZHMuZ2V0KG5hbWUpXG4gICAgaWYgKHRocmVzaG9sZCkge1xuICAgICAgdGhpcy50aHJlc2hvbGRzLmRlbGV0ZShuYW1lKVxuICAgICAgdGhpcy5sb2dUaHJlc2hvbGRDaGFuZ2UoJ3JlbW92ZWQnLCB0aHJlc2hvbGQpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIEdldCBhbGwgdGhyZXNob2xkc1xuICBnZXRBbGxUaHJlc2hvbGRzKCk6IEFsZXJ0VGhyZXNob2xkW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudGhyZXNob2xkcy52YWx1ZXMoKSlcbiAgfVxuXG4gIC8vIEdldCB0aHJlc2hvbGQgYnkgbmFtZVxuICBnZXRUaHJlc2hvbGQobmFtZTogc3RyaW5nKTogQWxlcnRUaHJlc2hvbGQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnRocmVzaG9sZHMuZ2V0KG5hbWUpXG4gIH1cblxuICAvLyBVcGRhdGUgdGhyZXNob2xkIHZhbHVlc1xuICB1cGRhdGVUaHJlc2hvbGQobmFtZTogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPEFsZXJ0VGhyZXNob2xkPik6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkcy5nZXQobmFtZSlcbiAgICBpZiAodGhyZXNob2xkKSB7XG4gICAgICBjb25zdCB1cGRhdGVkVGhyZXNob2xkID0geyAuLi50aHJlc2hvbGQsIC4uLnVwZGF0ZXMgfVxuICAgICAgdGhpcy50aHJlc2hvbGRzLnNldChuYW1lLCB1cGRhdGVkVGhyZXNob2xkKVxuICAgICAgdGhpcy5sb2dUaHJlc2hvbGRDaGFuZ2UoJ3VwZGF0ZWQnLCB1cGRhdGVkVGhyZXNob2xkKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBDaGVjayBpZiBhIG1ldHJpYyB2YWx1ZSB0cmlnZ2VycyBhbiBhbGVydFxuICBjaGVja1RocmVzaG9sZChtZXRyaWM6IHN0cmluZywgdmFsdWU6IG51bWJlcik6IEFsZXJ0RXZlbnRbXSB7XG4gICAgY29uc3QgdHJpZ2dlcmVkQWxlcnRzOiBBbGVydEV2ZW50W10gPSBbXVxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KClcblxuICAgIGZvciAoY29uc3QgdGhyZXNob2xkIG9mIHRoaXMudGhyZXNob2xkcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKCF0aHJlc2hvbGQuZW5hYmxlZCB8fCB0aHJlc2hvbGQubWV0cmljICE9PSBtZXRyaWMpIGNvbnRpbnVlXG5cbiAgICAgIC8vIENoZWNrIGNvb2xkb3duXG4gICAgICBpZiAodGhyZXNob2xkLmxhc3RUcmlnZ2VyZWQgJiYgXG4gICAgICAgICAgKG5vdyAtIHRocmVzaG9sZC5sYXN0VHJpZ2dlcmVkKSA8ICh0aHJlc2hvbGQuY29vbGRvd24gKiAxMDAwKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBsZXQgc3RhdHVzOiAnd2FybmluZycgfCAnY3JpdGljYWwnIHwgJ3Jlc29sdmVkJyB8IG51bGwgPSBudWxsXG5cbiAgICAgIGlmICh2YWx1ZSA+PSB0aHJlc2hvbGQuY3JpdGljYWwpIHtcbiAgICAgICAgc3RhdHVzID0gJ2NyaXRpY2FsJ1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+PSB0aHJlc2hvbGQud2FybmluZykge1xuICAgICAgICBzdGF0dXMgPSAnd2FybmluZydcbiAgICAgIH0gZWxzZSBpZiAodGhyZXNob2xkLmxhc3RUcmlnZ2VyZWQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJlc29sdmUgdGhlIGFsZXJ0XG4gICAgICAgIHN0YXR1cyA9ICdyZXNvbHZlZCdcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBjb25zdCBhbGVydEV2ZW50OiBBbGVydEV2ZW50ID0ge1xuICAgICAgICAgIGlkOiBgJHt0aHJlc2hvbGQubmFtZX1fJHtub3d9YCxcbiAgICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIHRpbWVzdGFtcDogbm93LFxuICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk/LmNvcnJlbGF0aW9uSWQsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIG1ldHJpYyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgdGhyZXNob2xkOiB7XG4gICAgICAgICAgICAgIHdhcm5pbmc6IHRocmVzaG9sZC53YXJuaW5nLFxuICAgICAgICAgICAgICBjcml0aWNhbDogdGhyZXNob2xkLmNyaXRpY2FsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnk6IHRocmVzaG9sZC5jYXRlZ29yeSxcbiAgICAgICAgICAgIHNldmVyaXR5OiB0aHJlc2hvbGQuc2V2ZXJpdHlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0cmlnZ2VyZWRBbGVydHMucHVzaChhbGVydEV2ZW50KVxuXG4gICAgICAgIC8vIFVwZGF0ZSBsYXN0IHRyaWdnZXJlZCB0aW1lIGZvciB3YXJuaW5nL2NyaXRpY2FsIGFsZXJ0c1xuICAgICAgICBpZiAoc3RhdHVzICE9PSAncmVzb2x2ZWQnKSB7XG4gICAgICAgICAgdGhyZXNob2xkLmxhc3RUcmlnZ2VyZWQgPSBub3dcbiAgICAgICAgICB0aGlzLnRocmVzaG9sZHMuc2V0KHRocmVzaG9sZC5uYW1lLCB0aHJlc2hvbGQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2cgdGhlIGFsZXJ0XG4gICAgICAgIHRoaXMubG9nQWxlcnQoYWxlcnRFdmVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJpZ2dlcmVkQWxlcnRzXG4gIH1cblxuICAvLyBTdGFydCBtb25pdG9yaW5nIHRocmVzaG9sZHNcbiAgc3RhcnRNb25pdG9yaW5nKGludGVydmFsTXM6IG51bWJlciA9IDMwMDAwKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNNb25pdG9yaW5nKSByZXR1cm5cblxuICAgIHRoaXMuaXNNb25pdG9yaW5nID0gdHJ1ZVxuICAgIHRoaXMubW9uaXRvcmluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5ydW5UaHJlc2hvbGRDaGVja3MoKVxuICAgIH0sIGludGVydmFsTXMpXG5cbiAgICBjb25zb2xlLmxvZygnQWxlcnQgdGhyZXNob2xkIG1vbml0b3Jpbmcgc3RhcnRlZCB3aXRoIGludGVydmFsOicsIGludGVydmFsTXMsICdtcycpXG4gIH1cblxuICAvLyBTdG9wIG1vbml0b3JpbmcgdGhyZXNob2xkc1xuICBzdG9wTW9uaXRvcmluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpXG4gICAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5pc01vbml0b3JpbmcgPSBmYWxzZVxuICAgIGNvbnNvbGUubG9nKCdBbGVydCB0aHJlc2hvbGQgbW9uaXRvcmluZyBzdG9wcGVkJylcbiAgfVxuXG4gIC8vIFJ1biB0aHJlc2hvbGQgY2hlY2tzIChwbGFjZWhvbGRlciBmb3IgYWN0dWFsIG1ldHJpYyBjb2xsZWN0aW9uKVxuICBwcml2YXRlIGFzeW5jIHJ1blRocmVzaG9sZENoZWNrcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBUaGlzIHdvdWxkIHR5cGljYWxseSBjb2xsZWN0IG1ldHJpY3MgZnJvbSB2YXJpb3VzIHNvdXJjZXNcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IGxvZyB0aGF0IG1vbml0b3JpbmcgaXMgYWN0aXZlXG4gICAgY29uc3QgYWN0aXZlVGhyZXNob2xkcyA9IHRoaXMuZ2V0QWxsVGhyZXNob2xkcygpLmZpbHRlcih0ID0+IHQuZW5hYmxlZClcbiAgICBpZiAoYWN0aXZlVGhyZXNob2xkcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgTW9uaXRvcmluZyAke2FjdGl2ZVRocmVzaG9sZHMubGVuZ3RofSBhY3RpdmUgdGhyZXNob2xkc2ApXG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGFsZXJ0IGhpc3RvcnlcbiAgZ2V0QWxlcnRIaXN0b3J5KGxpbWl0OiBudW1iZXIgPSAxMDApOiBBbGVydEV2ZW50W10ge1xuICAgIHJldHVybiB0aGlzLmFsZXJ0SGlzdG9yeS5zbGljZSgtbGltaXQpXG4gIH1cblxuICAvLyBDbGVhciBhbGVydCBoaXN0b3J5XG4gIGNsZWFyQWxlcnRIaXN0b3J5KCk6IHZvaWQge1xuICAgIHRoaXMuYWxlcnRIaXN0b3J5ID0gW11cbiAgfVxuXG4gIC8vIEdldCBhbGVydHMgYnkgc3RhdHVzXG4gIGdldEFsZXJ0c0J5U3RhdHVzKHN0YXR1czogJ3dhcm5pbmcnIHwgJ2NyaXRpY2FsJyB8ICdyZXNvbHZlZCcpOiBBbGVydEV2ZW50W10ge1xuICAgIHJldHVybiB0aGlzLmFsZXJ0SGlzdG9yeS5maWx0ZXIoYWxlcnQgPT4gYWxlcnQuc3RhdHVzID09PSBzdGF0dXMpXG4gIH1cblxuICAvLyBHZXQgYWxlcnRzIGJ5IGNhdGVnb3J5XG4gIGdldEFsZXJ0c0J5Q2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZyk6IEFsZXJ0RXZlbnRbXSB7XG4gICAgcmV0dXJuIHRoaXMuYWxlcnRIaXN0b3J5LmZpbHRlcihhbGVydCA9PiBhbGVydC50aHJlc2hvbGQuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KVxuICB9XG5cbiAgLy8gR2V0IGFsZXJ0cyBieSBzZXZlcml0eVxuICBnZXRBbGVydHNCeVNldmVyaXR5KHNldmVyaXR5OiBzdHJpbmcpOiBBbGVydEV2ZW50W10ge1xuICAgIHJldHVybiB0aGlzLmFsZXJ0SGlzdG9yeS5maWx0ZXIoYWxlcnQgPT4gYWxlcnQudGhyZXNob2xkLnNldmVyaXR5ID09PSBzZXZlcml0eSlcbiAgfVxuXG4gIC8vIExvZyB0aHJlc2hvbGQgY2hhbmdlc1xuICBwcml2YXRlIGxvZ1RocmVzaG9sZENoYW5nZShhY3Rpb246IHN0cmluZywgdGhyZXNob2xkOiBBbGVydFRocmVzaG9sZCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbnRleHQgPSBjb3JyZWxhdGlvbklETWFuYWdlci5nZXRDdXJyZW50Q29udGV4dCgpXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGNvcnJlbGF0aW9uSURNYW5hZ2VyLmxvZ0NvbnRleHQoY29udGV4dCwgJ2luZm8nKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGDwn5SUIEFsZXJ0IHRocmVzaG9sZCAke2FjdGlvbn06YCwge1xuICAgICAgbmFtZTogdGhyZXNob2xkLm5hbWUsXG4gICAgICBtZXRyaWM6IHRocmVzaG9sZC5tZXRyaWMsXG4gICAgICB3YXJuaW5nOiB0aHJlc2hvbGQud2FybmluZyxcbiAgICAgIGNyaXRpY2FsOiB0aHJlc2hvbGQuY3JpdGljYWwsXG4gICAgICBjYXRlZ29yeTogdGhyZXNob2xkLmNhdGVnb3J5LFxuICAgICAgc2V2ZXJpdHk6IHRocmVzaG9sZC5zZXZlcml0eSxcbiAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvbnRleHQ/LmNvcnJlbGF0aW9uSWRcbiAgICB9KVxuICB9XG5cbiAgLy8gTG9nIGFsZXJ0c1xuICBwcml2YXRlIGxvZ0FsZXJ0KGFsZXJ0OiBBbGVydEV2ZW50KTogdm9pZCB7XG4gICAgLy8gQWRkIHRvIGhpc3RvcnlcbiAgICB0aGlzLmFsZXJ0SGlzdG9yeS5wdXNoKGFsZXJ0KVxuICAgIGlmICh0aGlzLmFsZXJ0SGlzdG9yeS5sZW5ndGggPiAxMDAwKSB7XG4gICAgICB0aGlzLmFsZXJ0SGlzdG9yeSA9IHRoaXMuYWxlcnRIaXN0b3J5LnNsaWNlKC0xMDAwKVxuICAgIH1cblxuICAgIC8vIExvZyB0aGUgYWxlcnRcbiAgICBjb25zdCBlbW9qaSA9IGFsZXJ0LnN0YXR1cyA9PT0gJ2NyaXRpY2FsJyA/ICfwn5qoJyA6IFxuICAgICAgICAgICAgICAgICAgYWxlcnQuc3RhdHVzID09PSAnd2FybmluZycgPyAn4pqg77iPJyA6ICfinIUnXG4gICAgXG4gICAgY29uc29sZS5sb2coYCR7ZW1vaml9IEFsZXJ0IHRyaWdnZXJlZDpgLCB7XG4gICAgICBuYW1lOiBhbGVydC50aHJlc2hvbGQubmFtZSxcbiAgICAgIHN0YXR1czogYWxlcnQuc3RhdHVzLFxuICAgICAgdmFsdWU6IGFsZXJ0LnZhbHVlLFxuICAgICAgdGhyZXNob2xkOiBhbGVydC50aHJlc2hvbGQsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKGFsZXJ0LnRpbWVzdGFtcCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGNvcnJlbGF0aW9uSWQ6IGFsZXJ0LmNvcnJlbGF0aW9uSWRcbiAgICB9KVxuXG4gICAgLy8gVE9ETzogU2VuZCBhbGVydHMgdG8gZXh0ZXJuYWwgc3lzdGVtcyAoU2xhY2ssIFBhZ2VyRHV0eSwgZXRjLilcbiAgICB0aGlzLnNlbmRFeHRlcm5hbEFsZXJ0KGFsZXJ0KVxuICB9XG5cbiAgLy8gU2VuZCBleHRlcm5hbCBhbGVydCAocGxhY2Vob2xkZXIpXG4gIHByaXZhdGUgYXN5bmMgc2VuZEV4dGVybmFsQWxlcnQoYWxlcnQ6IEFsZXJ0RXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBUaGlzIHdvdWxkIGludGVncmF0ZSB3aXRoIGV4dGVybmFsIGFsZXJ0aW5nIHN5c3RlbXNcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IGxvZyB0aGF0IHdlIHdvdWxkIHNlbmQgaXRcbiAgICBjb25zb2xlLmxvZyhg8J+TpCBXb3VsZCBzZW5kIGV4dGVybmFsIGFsZXJ0IGZvcjogJHthbGVydC50aHJlc2hvbGQubmFtZX1gKVxuICB9XG5cbiAgLy8gR2V0IG1vbml0b3Jpbmcgc3RhdHVzXG4gIGdldE1vbml0b3JpbmdTdGF0dXMoKTogeyBpc0FjdGl2ZTogYm9vbGVhbjsgaW50ZXJ2YWw6IG51bWJlciB8IG51bGw7IHRocmVzaG9sZENvdW50OiBudW1iZXIgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmlzTW9uaXRvcmluZyxcbiAgICAgIGludGVydmFsOiB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA/IDMwMDAwIDogbnVsbCxcbiAgICAgIHRocmVzaG9sZENvdW50OiB0aGlzLnRocmVzaG9sZHMuc2l6ZVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4cG9ydCB0aHJlc2hvbGRzIHRvIEpTT05cbiAgZXhwb3J0VGhyZXNob2xkcygpOiBzdHJpbmcge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKHRoaXMudGhyZXNob2xkcy52YWx1ZXMoKSksIG51bGwsIDIpXG4gIH1cblxuICAvLyBJbXBvcnQgdGhyZXNob2xkcyBmcm9tIEpTT05cbiAgaW1wb3J0VGhyZXNob2xkcyhqc29uRGF0YTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRocmVzaG9sZHMgPSBKU09OLnBhcnNlKGpzb25EYXRhKSBhcyBBbGVydFRocmVzaG9sZFtdXG4gICAgICB0aGlzLnRocmVzaG9sZHMuY2xlYXIoKVxuICAgICAgdGhyZXNob2xkcy5mb3JFYWNoKHRocmVzaG9sZCA9PiB7XG4gICAgICAgIHRoaXMudGhyZXNob2xkcy5zZXQodGhyZXNob2xkLm5hbWUsIHRocmVzaG9sZClcbiAgICAgIH0pXG4gICAgICBjb25zb2xlLmxvZyhgSW1wb3J0ZWQgJHt0aHJlc2hvbGRzLmxlbmd0aH0gdGhyZXNob2xkc2ApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW1wb3J0IHRocmVzaG9sZHM6JywgZXJyb3IpXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGFsZXJ0VGhyZXNob2xkTWFuYWdlciA9IEFsZXJ0VGhyZXNob2xkTWFuYWdlci5nZXRJbnN0YW5jZSgpXG5cbi8vIEV4cG9ydCB0eXBlc1xuZXhwb3J0IHR5cGUgeyBBbGVydFRocmVzaG9sZCwgQWxlcnRFdmVudCB9XG4iXSwibmFtZXMiOlsiY29ycmVsYXRpb25JRE1hbmFnZXIiLCJBbGVydFRocmVzaG9sZE1hbmFnZXIiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwiaW5pdGlhbGl6ZURlZmF1bHRUaHJlc2hvbGRzIiwiZGVmYXVsdFRocmVzaG9sZHMiLCJuYW1lIiwibWV0cmljIiwid2FybmluZyIsImNyaXRpY2FsIiwiZW5hYmxlZCIsImRlc2NyaXB0aW9uIiwiY2F0ZWdvcnkiLCJzZXZlcml0eSIsImNvb2xkb3duIiwiZXNjYWxhdGlvbiIsImxldmVscyIsImNvbnRhY3RzIiwiZm9yRWFjaCIsInRocmVzaG9sZCIsInRocmVzaG9sZHMiLCJzZXQiLCJhZGRUaHJlc2hvbGQiLCJsb2dUaHJlc2hvbGRDaGFuZ2UiLCJyZW1vdmVUaHJlc2hvbGQiLCJnZXQiLCJkZWxldGUiLCJnZXRBbGxUaHJlc2hvbGRzIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiZ2V0VGhyZXNob2xkIiwidXBkYXRlVGhyZXNob2xkIiwidXBkYXRlcyIsInVwZGF0ZWRUaHJlc2hvbGQiLCJjaGVja1RocmVzaG9sZCIsInZhbHVlIiwidHJpZ2dlcmVkQWxlcnRzIiwibm93IiwiRGF0ZSIsImxhc3RUcmlnZ2VyZWQiLCJzdGF0dXMiLCJhbGVydEV2ZW50IiwiaWQiLCJ0aW1lc3RhbXAiLCJjb3JyZWxhdGlvbklkIiwiZ2V0Q3VycmVudENvbnRleHQiLCJtZXRhZGF0YSIsInB1c2giLCJsb2dBbGVydCIsInN0YXJ0TW9uaXRvcmluZyIsImludGVydmFsTXMiLCJpc01vbml0b3JpbmciLCJtb25pdG9yaW5nSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInJ1blRocmVzaG9sZENoZWNrcyIsImNvbnNvbGUiLCJsb2ciLCJzdG9wTW9uaXRvcmluZyIsImNsZWFySW50ZXJ2YWwiLCJhY3RpdmVUaHJlc2hvbGRzIiwiZmlsdGVyIiwidCIsImxlbmd0aCIsImdldEFsZXJ0SGlzdG9yeSIsImxpbWl0IiwiYWxlcnRIaXN0b3J5Iiwic2xpY2UiLCJjbGVhckFsZXJ0SGlzdG9yeSIsImdldEFsZXJ0c0J5U3RhdHVzIiwiYWxlcnQiLCJnZXRBbGVydHNCeUNhdGVnb3J5IiwiZ2V0QWxlcnRzQnlTZXZlcml0eSIsImFjdGlvbiIsImNvbnRleHQiLCJsb2dDb250ZXh0IiwiZW1vamkiLCJ0b0lTT1N0cmluZyIsInNlbmRFeHRlcm5hbEFsZXJ0IiwiZ2V0TW9uaXRvcmluZ1N0YXR1cyIsImlzQWN0aXZlIiwiaW50ZXJ2YWwiLCJ0aHJlc2hvbGRDb3VudCIsInNpemUiLCJleHBvcnRUaHJlc2hvbGRzIiwiSlNPTiIsInN0cmluZ2lmeSIsImltcG9ydFRocmVzaG9sZHMiLCJqc29uRGF0YSIsInBhcnNlIiwiY2xlYXIiLCJlcnJvciIsIk1hcCIsImFsZXJ0VGhyZXNob2xkTWFuYWdlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/alert-thresholds.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/correlation-id.ts":
/*!***********************************!*\
  !*** ./src/lib/correlation-id.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCorrelationId: () => (/* binding */ addCorrelationId),\n/* harmony export */   correlationAwareFetch: () => (/* binding */ correlationAwareFetch),\n/* harmony export */   correlationManager: () => (/* binding */ correlationManager),\n/* harmony export */   createCorrelationAwareFetch: () => (/* binding */ createCorrelationAwareFetch),\n/* harmony export */   createCorrelationContext: () => (/* binding */ createCorrelationContext),\n/* harmony export */   createFetchOptionsWithCorrelation: () => (/* binding */ createFetchOptionsWithCorrelation),\n/* harmony export */   createHeadersWithCorrelation: () => (/* binding */ createHeadersWithCorrelation),\n/* harmony export */   extractCorrelationId: () => (/* binding */ extractCorrelationId),\n/* harmony export */   generateCorrelationId: () => (/* binding */ generateCorrelationId),\n/* harmony export */   generateSpanId: () => (/* binding */ generateSpanId),\n/* harmony export */   generateTraceId: () => (/* binding */ generateTraceId),\n/* harmony export */   logWithCorrelation: () => (/* binding */ logWithCorrelation),\n/* harmony export */   withCorrelationContext: () => (/* binding */ withCorrelationContext)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Correlation ID service for request tracing and observability\n// Configuration\nconst CORRELATION_ID_HEADER = process.env.NEXT_PUBLIC_CORRELATION_ID_HEADER || 'X-Correlation-ID';\nconst CORRELATION_ID_LENGTH = parseInt(process.env.NEXT_PUBLIC_CORRELATION_ID_LENGTH || '16', 10);\n// Generate a unique correlation ID\nfunction generateCorrelationId() {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    for(let i = 0; i < CORRELATION_ID_LENGTH; i++){\n        result += chars.charAt(Math.floor(Math.random() * chars.length));\n    }\n    return result;\n}\n// Generate a trace ID (longer, more unique identifier)\nfunction generateTraceId() {\n    return generateCorrelationId() + generateCorrelationId();\n}\n// Generate a span ID (shorter identifier for individual operations)\nfunction generateSpanId() {\n    return generateCorrelationId().substring(0, 8);\n}\n// Create a new correlation context\nfunction createCorrelationContext(parentContext) {\n    let metadata = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const now = new Date().toISOString();\n    return {\n        id: (parentContext === null || parentContext === void 0 ? void 0 : parentContext.id) || generateCorrelationId(),\n        parentId: parentContext === null || parentContext === void 0 ? void 0 : parentContext.parentId,\n        traceId: (parentContext === null || parentContext === void 0 ? void 0 : parentContext.traceId) || generateTraceId(),\n        spanId: generateSpanId(),\n        userId: parentContext === null || parentContext === void 0 ? void 0 : parentContext.userId,\n        sessionId: parentContext === null || parentContext === void 0 ? void 0 : parentContext.sessionId,\n        requestId: (parentContext === null || parentContext === void 0 ? void 0 : parentContext.requestId) || generateCorrelationId(),\n        timestamp: now,\n        metadata: {\n            ...parentContext === null || parentContext === void 0 ? void 0 : parentContext.metadata,\n            ...metadata,\n            created_at: now\n        }\n    };\n}\n// Extract correlation ID from headers\nfunction extractCorrelationId(headers) {\n    if (headers instanceof Headers) {\n        return headers.get(CORRELATION_ID_HEADER) || null;\n    }\n    return headers[CORRELATION_ID_HEADER] || null;\n}\n// Add correlation ID to headers\nfunction addCorrelationId(headers, correlationId) {\n    if (headers instanceof Headers) {\n        headers.set(CORRELATION_ID_HEADER, correlationId);\n    } else {\n        headers[CORRELATION_ID_HEADER] = correlationId;\n    }\n}\n// Create headers with correlation ID\nfunction createHeadersWithCorrelation(correlationId) {\n    let additionalHeaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return {\n        [CORRELATION_ID_HEADER]: correlationId,\n        'Content-Type': 'application/json',\n        ...additionalHeaders\n    };\n}\n// Create fetch options with correlation ID\nfunction createFetchOptionsWithCorrelation(correlationId) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    return {\n        ...options,\n        headers: {\n            ...createHeadersWithCorrelation(correlationId),\n            ...options.headers\n        }\n    };\n}\n// Correlation context manager for React components\nclass CorrelationContextManager {\n    // Set the current correlation context\n    setContext(context) {\n        this.currentContext = context;\n        this.notifyListeners();\n    }\n    // Get the current correlation context\n    getContext() {\n        return this.currentContext;\n    }\n    // Create a child context\n    createChildContext() {\n        let metadata = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        if (!this.currentContext) {\n            return createCorrelationContext({}, metadata);\n        }\n        return createCorrelationContext(this.currentContext, {\n            ...metadata,\n            parent_correlation_id: this.currentContext.id\n        });\n    }\n    // Update the current context with additional metadata\n    updateContext(metadata) {\n        if (this.currentContext) {\n            this.currentContext.metadata = {\n                ...this.currentContext.metadata,\n                ...metadata,\n                updated_at: new Date().toISOString()\n            };\n            this.notifyListeners();\n        }\n    }\n    // Clear the current context\n    clearContext() {\n        this.currentContext = null;\n        this.notifyListeners();\n    }\n    // Subscribe to context changes\n    subscribe(listener) {\n        this.listeners.add(listener);\n        return ()=>{\n            this.listeners.delete(listener);\n        };\n    }\n    // Notify all listeners of context changes\n    notifyListeners() {\n        this.listeners.forEach((listener)=>{\n            try {\n                listener(this.currentContext);\n            } catch (error) {\n                console.error('Error in correlation context listener:', error);\n            }\n        });\n    }\n    // Extract correlation ID from headers\n    extractFromHeaders(headers) {\n        const correlationId = headers['x-correlation-id'] || headers['X-Correlation-ID'];\n        if (!correlationId) return null;\n        const context = this.getContext(correlationId);\n        if (context) {\n            this.setCurrentContext(context);\n            return context;\n        }\n        // Create new context from headers, preserving the incoming correlation ID\n        const newContext = {\n            correlationId: correlationId,\n            requestId: headers['x-request-id'] || headers['X-Request-ID'] || uuidv4(),\n            parentId: headers['x-parent-id'] || headers['X-Parent-ID'] || undefined,\n            spanId: headers['x-span-id'] || headers['X-Span-ID'] || uuidv4(),\n            traceId: headers['x-trace-id'] || headers['X-Trace-ID'] || correlationId,\n            userId: headers['x-user-id'] || headers['X-User-ID'] || undefined,\n            tenantId: headers['x-tenant-id'] || headers['X-Tenant-ID'] || undefined,\n            sessionId: headers['x-session-id'] || headers['X-Session-ID'] || undefined,\n            timestamp: parseInt(headers['x-timestamp'] || headers['X-Timestamp'] || Date.now().toString()),\n            metadata: {\n                service: headers['x-service'] || headers['X-Service'] || 'unknown',\n                version: process.env.NEXT_PUBLIC_APP_VERSION || '1.0.0',\n                environment: \"development\" || 0\n            }\n        };\n        this.setCurrentContext(newContext);\n        return newContext;\n    }\n    constructor(){\n        this.currentContext = null;\n        this.listeners = new Set();\n    }\n}\n// Export singleton instance\nconst correlationManager = new CorrelationContextManager();\n// Utility function to log with correlation context\nfunction logWithCorrelation(level, message, data) {\n    const context = correlationManager.getContext();\n    const logData = {\n        message,\n        data,\n        correlation_id: context === null || context === void 0 ? void 0 : context.id,\n        trace_id: context === null || context === void 0 ? void 0 : context.traceId,\n        span_id: context === null || context === void 0 ? void 0 : context.spanId,\n        timestamp: new Date().toISOString()\n    };\n    switch(level){\n        case 'info':\n            console.info('', logData);\n            break;\n        case 'warn':\n            console.warn('', logData);\n            break;\n        case 'error':\n            console.error('', logData);\n            break;\n        case 'debug':\n            console.debug('', logData);\n            break;\n    }\n}\n// Utility function to create a correlation-aware fetch wrapper\nfunction createCorrelationAwareFetch() {\n    return async (input, init)=>{\n        const context = correlationManager.getContext();\n        if (context) {\n            const options = createFetchOptionsWithCorrelation(context.id, init);\n            // Log the request\n            logWithCorrelation('info', 'API Request', {\n                url: typeof input === 'string' ? input : input.toString(),\n                method: options.method || 'GET',\n                correlation_id: context.id\n            });\n            try {\n                const response = await fetch(input, options);\n                // Log the response\n                logWithCorrelation('info', 'API Response', {\n                    url: typeof input === 'string' ? input : input.toString(),\n                    status: response.status,\n                    statusText: response.statusText,\n                    correlation_id: context.id\n                });\n                return response;\n            } catch (error) {\n                // Log the error\n                logWithCorrelation('error', 'API Request Failed', {\n                    url: typeof input === 'string' ? input : input.toString(),\n                    error: error instanceof Error ? error.message : String(error),\n                    correlation_id: context.id\n                });\n                throw error;\n            }\n        }\n        // Fallback to regular fetch if no correlation context\n        return fetch(input, init);\n    };\n}\n// Export the correlation-aware fetch function\nconst correlationAwareFetch = createCorrelationAwareFetch();\n// Utility function to wrap async operations with correlation context\nfunction withCorrelationContext(operation) {\n    let metadata = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const childContext = correlationManager.createChildContext(metadata);\n    correlationManager.setContext(childContext);\n    return operation().finally(()=>{\n        // Restore parent context if it exists\n        if (childContext.parentId) {\n            const parentContext = correlationManager.getContext();\n            if (parentContext && parentContext.id === childContext.parentId) {\n                correlationManager.setContext(parentContext);\n            }\n        }\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29ycmVsYXRpb24taWQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrREFBK0Q7QUFFL0QsZ0JBQWdCO0FBQ2hCLE1BQU1BLHdCQUF3QkMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxpQ0FBaUMsSUFBSTtBQUMvRSxNQUFNQyx3QkFBd0JDLFNBQVNKLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0ksaUNBQWlDLElBQUksTUFBTTtBQWU5RixtQ0FBbUM7QUFDNUIsU0FBU0M7SUFDZCxNQUFNQyxRQUFRO0lBQ2QsSUFBSUMsU0FBUztJQUNiLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTix1QkFBdUJNLElBQUs7UUFDOUNELFVBQVVELE1BQU1HLE1BQU0sQ0FBQ0MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUtOLE1BQU1PLE1BQU07SUFDaEU7SUFDQSxPQUFPTjtBQUNUO0FBRUEsdURBQXVEO0FBQ2hELFNBQVNPO0lBQ2QsT0FBT1QsMEJBQTBCQTtBQUNuQztBQUVBLG9FQUFvRTtBQUM3RCxTQUFTVTtJQUNkLE9BQU9WLHdCQUF3QlcsU0FBUyxDQUFDLEdBQUc7QUFDOUM7QUFFQSxtQ0FBbUM7QUFDNUIsU0FBU0MseUJBQ2RDLGFBQTJDO1FBQzNDQyxXQUFBQSxpRUFBZ0MsQ0FBQztJQUVqQyxNQUFNQyxNQUFNLElBQUlDLE9BQU9DLFdBQVc7SUFFbEMsT0FBTztRQUNMQyxJQUFJTCxDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVLLEVBQUUsS0FBSWxCO1FBQ3pCbUIsUUFBUSxFQUFFTiwwQkFBQUEsb0NBQUFBLGNBQWVNLFFBQVE7UUFDakNDLFNBQVNQLENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZU8sT0FBTyxLQUFJWDtRQUNuQ1ksUUFBUVg7UUFDUlksTUFBTSxFQUFFVCwwQkFBQUEsb0NBQUFBLGNBQWVTLE1BQU07UUFDN0JDLFNBQVMsRUFBRVYsMEJBQUFBLG9DQUFBQSxjQUFl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YUFBYTVFLFFBQVEsRUFBRTtnQkFDL0RrRCxtQkFBbUI5QixVQUFVLENBQUMxQjtZQUNoQztRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2xpYi9jb3JyZWxhdGlvbi1pZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3JyZWxhdGlvbiBJRCBzZXJ2aWNlIGZvciByZXF1ZXN0IHRyYWNpbmcgYW5kIG9ic2VydmFiaWxpdHlcblxuLy8gQ29uZmlndXJhdGlvblxuY29uc3QgQ09SUkVMQVRJT05fSURfSEVBREVSID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ09SUkVMQVRJT05fSURfSEVBREVSIHx8ICdYLUNvcnJlbGF0aW9uLUlEJ1xuY29uc3QgQ09SUkVMQVRJT05fSURfTEVOR1RIID0gcGFyc2VJbnQocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ09SUkVMQVRJT05fSURfTEVOR1RIIHx8ICcxNicsIDEwKVxuXG4vLyBDb3JyZWxhdGlvbiBJRCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQ29ycmVsYXRpb25Db250ZXh0IHtcbiAgaWQ6IHN0cmluZ1xuICBwYXJlbnRJZD86IHN0cmluZ1xuICB0cmFjZUlkPzogc3RyaW5nXG4gIHNwYW5JZD86IHN0cmluZ1xuICB1c2VySWQ/OiBzdHJpbmdcbiAgc2Vzc2lvbklkPzogc3RyaW5nXG4gIHJlcXVlc3RJZD86IHN0cmluZ1xuICB0aW1lc3RhbXA6IHN0cmluZ1xuICBtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55PlxufVxuXG4vLyBHZW5lcmF0ZSBhIHVuaXF1ZSBjb3JyZWxhdGlvbiBJRFxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ29ycmVsYXRpb25JZCgpOiBzdHJpbmcge1xuICBjb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSdcbiAgbGV0IHJlc3VsdCA9ICcnXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgQ09SUkVMQVRJT05fSURfTEVOR1RIOyBpKyspIHtcbiAgICByZXN1bHQgKz0gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBHZW5lcmF0ZSBhIHRyYWNlIElEIChsb25nZXIsIG1vcmUgdW5pcXVlIGlkZW50aWZpZXIpXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVUcmFjZUlkKCk6IHN0cmluZyB7XG4gIHJldHVybiBnZW5lcmF0ZUNvcnJlbGF0aW9uSWQoKSArIGdlbmVyYXRlQ29ycmVsYXRpb25JZCgpXG59XG5cbi8vIEdlbmVyYXRlIGEgc3BhbiBJRCAoc2hvcnRlciBpZGVudGlmaWVyIGZvciBpbmRpdmlkdWFsIG9wZXJhdGlvbnMpXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTcGFuSWQoKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdlbmVyYXRlQ29ycmVsYXRpb25JZCgpLnN1YnN0cmluZygwLCA4KVxufVxuXG4vLyBDcmVhdGUgYSBuZXcgY29ycmVsYXRpb24gY29udGV4dFxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvcnJlbGF0aW9uQ29udGV4dChcbiAgcGFyZW50Q29udGV4dD86IFBhcnRpYWw8Q29ycmVsYXRpb25Db250ZXh0PixcbiAgbWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuKTogQ29ycmVsYXRpb25Db250ZXh0IHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIFxuICByZXR1cm4ge1xuICAgIGlkOiBwYXJlbnRDb250ZXh0Py5pZCB8fCBnZW5lcmF0ZUNvcnJlbGF0aW9uSWQoKSxcbiAgICBwYXJlbnRJZDogcGFyZW50Q29udGV4dD8ucGFyZW50SWQsXG4gICAgdHJhY2VJZDogcGFyZW50Q29udGV4dD8udHJhY2VJZCB8fCBnZW5lcmF0ZVRyYWNlSWQoKSxcbiAgICBzcGFuSWQ6IGdlbmVyYXRlU3BhbklkKCksXG4gICAgdXNlcklkOiBwYXJlbnRDb250ZXh0Py51c2VySWQsXG4gICAgc2Vzc2lvbklkOiBwYXJlbnRDb250ZXh0Py5zZXNzaW9uSWQsXG4gICAgcmVxdWVzdElkOiBwYXJlbnRDb250ZXh0Py5yZXF1ZXN0SWQgfHwgZ2VuZXJhdGVDb3JyZWxhdGlvbklkKCksXG4gICAgdGltZXN0YW1wOiBub3csXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIC4uLnBhcmVudENvbnRleHQ/Lm1ldGFkYXRhLFxuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICBjcmVhdGVkX2F0OiBub3csXG4gICAgfSxcbiAgfVxufVxuXG4vLyBFeHRyYWN0IGNvcnJlbGF0aW9uIElEIGZyb20gaGVhZGVyc1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RDb3JyZWxhdGlvbklkKGhlYWRlcnM6IEhlYWRlcnMgfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIHJldHVybiBoZWFkZXJzLmdldChDT1JSRUxBVElPTl9JRF9IRUFERVIpIHx8IG51bGxcbiAgfVxuICByZXR1cm4gaGVhZGVyc1tDT1JSRUxBVElPTl9JRF9IRUFERVJdIHx8IG51bGxcbn1cblxuLy8gQWRkIGNvcnJlbGF0aW9uIElEIHRvIGhlYWRlcnNcbmV4cG9ydCBmdW5jdGlvbiBhZGRDb3JyZWxhdGlvbklkKFxuICBoZWFkZXJzOiBIZWFkZXJzIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPixcbiAgY29ycmVsYXRpb25JZDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5zZXQoQ09SUkVMQVRJT05fSURfSEVBREVSLCBjb3JyZWxhdGlvbklkKVxuICB9IGVsc2Uge1xuICAgIGhlYWRlcnNbQ09SUkVMQVRJT05fSURfSEVBREVSXSA9IGNvcnJlbGF0aW9uSWRcbiAgfVxufVxuXG4vLyBDcmVhdGUgaGVhZGVycyB3aXRoIGNvcnJlbGF0aW9uIElEXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGVhZGVyc1dpdGhDb3JyZWxhdGlvbihcbiAgY29ycmVsYXRpb25JZDogc3RyaW5nLFxuICBhZGRpdGlvbmFsSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9XG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgcmV0dXJuIHtcbiAgICBbQ09SUkVMQVRJT05fSURfSEVBREVSXTogY29ycmVsYXRpb25JZCxcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIC4uLmFkZGl0aW9uYWxIZWFkZXJzLFxuICB9XG59XG5cbi8vIENyZWF0ZSBmZXRjaCBvcHRpb25zIHdpdGggY29ycmVsYXRpb24gSURcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnNXaXRoQ29ycmVsYXRpb24oXG4gIGNvcnJlbGF0aW9uSWQ6IHN0cmluZyxcbiAgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7fVxuKTogUmVxdWVzdEluaXQge1xuICByZXR1cm4ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgaGVhZGVyczoge1xuICAgICAgLi4uY3JlYXRlSGVhZGVyc1dpdGhDb3JyZWxhdGlvbihjb3JyZWxhdGlvbklkKSxcbiAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICB9LFxuICB9XG59XG5cbi8vIENvcnJlbGF0aW9uIGNvbnRleHQgbWFuYWdlciBmb3IgUmVhY3QgY29tcG9uZW50c1xuY2xhc3MgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlciB7XG4gIHByaXZhdGUgY3VycmVudENvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgbGlzdGVuZXJzOiBTZXQ8KGNvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dCB8IG51bGwpID0+IHZvaWQ+ID0gbmV3IFNldCgpXG5cbiAgLy8gU2V0IHRoZSBjdXJyZW50IGNvcnJlbGF0aW9uIGNvbnRleHRcbiAgc2V0Q29udGV4dChjb250ZXh0OiBDb3JyZWxhdGlvbkNvbnRleHQpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gY29udGV4dFxuICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldCB0aGUgY3VycmVudCBjb3JyZWxhdGlvbiBjb250ZXh0XG4gIGdldENvbnRleHQoKTogQ29ycmVsYXRpb25Db250ZXh0IHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvbnRleHRcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGNoaWxkIGNvbnRleHRcbiAgY3JlYXRlQ2hpbGRDb250ZXh0KG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBDb3JyZWxhdGlvbkNvbnRleHQge1xuICAgIGlmICghdGhpcy5jdXJyZW50Q29udGV4dCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvcnJlbGF0aW9uQ29udGV4dCh7fSwgbWV0YWRhdGEpXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjcmVhdGVDb3JyZWxhdGlvbkNvbnRleHQodGhpcy5jdXJyZW50Q29udGV4dCwge1xuICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICBwYXJlbnRfY29ycmVsYXRpb25faWQ6IHRoaXMuY3VycmVudENvbnRleHQuaWQsXG4gICAgfSlcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBjb250ZXh0IHdpdGggYWRkaXRpb25hbCBtZXRhZGF0YVxuICB1cGRhdGVDb250ZXh0KG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudENvbnRleHQpIHtcbiAgICAgIHRoaXMuY3VycmVudENvbnRleHQubWV0YWRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMuY3VycmVudENvbnRleHQubWV0YWRhdGEsXG4gICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9XG4gICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgY29udGV4dFxuICBjbGVhckNvbnRleHQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Q29udGV4dCA9IG51bGxcbiAgICB0aGlzLm5vdGlmeUxpc3RlbmVycygpXG4gIH1cblxuICAvLyBTdWJzY3JpYmUgdG8gY29udGV4dCBjaGFuZ2VzXG4gIHN1YnNjcmliZShsaXN0ZW5lcjogKGNvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dCB8IG51bGwpID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQobGlzdGVuZXIpXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcilcbiAgICB9XG4gIH1cblxuICAvLyBOb3RpZnkgYWxsIGxpc3RlbmVycyBvZiBjb250ZXh0IGNoYW5nZXNcbiAgcHJpdmF0ZSBub3RpZnlMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lcih0aGlzLmN1cnJlbnRDb250ZXh0KVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY29ycmVsYXRpb24gY29udGV4dCBsaXN0ZW5lcjonLCBlcnJvcilcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gRXh0cmFjdCBjb3JyZWxhdGlvbiBJRCBmcm9tIGhlYWRlcnNcbiAgZXh0cmFjdEZyb21IZWFkZXJzKGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBDb3JyZWxhdGlvbkNvbnRleHQgfCBudWxsIHtcbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gaGVhZGVyc1sneC1jb3JyZWxhdGlvbi1pZCddIHx8IGhlYWRlcnNbJ1gtQ29ycmVsYXRpb24tSUQnXVxuICAgIGlmICghY29ycmVsYXRpb25JZCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoY29ycmVsYXRpb25JZClcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50Q29udGV4dChjb250ZXh0KVxuICAgICAgcmV0dXJuIGNvbnRleHRcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IGNvbnRleHQgZnJvbSBoZWFkZXJzLCBwcmVzZXJ2aW5nIHRoZSBpbmNvbWluZyBjb3JyZWxhdGlvbiBJRFxuICAgIGNvbnN0IG5ld0NvbnRleHQ6IENvcnJlbGF0aW9uQ29udGV4dCA9IHtcbiAgICAgIGNvcnJlbGF0aW9uSWQ6IGNvcnJlbGF0aW9uSWQsIC8vIFVzZSB0aGUgaW5jb21pbmcgY29ycmVsYXRpb24gSURcbiAgICAgIHJlcXVlc3RJZDogaGVhZGVyc1sneC1yZXF1ZXN0LWlkJ10gfHwgaGVhZGVyc1snWC1SZXF1ZXN0LUlEJ10gfHwgdXVpZHY0KCksXG4gICAgICBwYXJlbnRJZDogaGVhZGVyc1sneC1wYXJlbnQtaWQnXSB8fCBoZWFkZXJzWydYLVBhcmVudC1JRCddIHx8IHVuZGVmaW5lZCxcbiAgICAgIHNwYW5JZDogaGVhZGVyc1sneC1zcGFuLWlkJ10gfHwgaGVhZGVyc1snWC1TcGFuLUlEJ10gfHwgdXVpZHY0KCksXG4gICAgICB0cmFjZUlkOiBoZWFkZXJzWyd4LXRyYWNlLWlkJ10gfHwgaGVhZGVyc1snWC1UcmFjZS1JRCddIHx8IGNvcnJlbGF0aW9uSWQsXG4gICAgICB1c2VySWQ6IGhlYWRlcnNbJ3gtdXNlci1pZCddIHx8IGhlYWRlcnNbJ1gtVXNlci1JRCddIHx8IHVuZGVmaW5lZCxcbiAgICAgIHRlbmFudElkOiBoZWFkZXJzWyd4LXRlbmFudC1pZCddIHx8IGhlYWRlcnNbJ1gtVGVuYW50LUlEJ10gfHwgdW5kZWZpbmVkLFxuICAgICAgc2Vzc2lvbklkOiBoZWFkZXJzWyd4LXNlc3Npb24taWQnXSB8fCBoZWFkZXJzWydYLVNlc3Npb24tSUQnXSB8fCB1bmRlZmluZWQsXG4gICAgICB0aW1lc3RhbXA6IHBhcnNlSW50KGhlYWRlcnNbJ3gtdGltZXN0YW1wJ10gfHwgaGVhZGVyc1snWC1UaW1lc3RhbXAnXSB8fCBEYXRlLm5vdygpLnRvU3RyaW5nKCkpLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgc2VydmljZTogaGVhZGVyc1sneC1zZXJ2aWNlJ10gfHwgaGVhZGVyc1snWC1TZXJ2aWNlJ10gfHwgJ3Vua25vd24nLFxuICAgICAgICB2ZXJzaW9uOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUFBfVkVSU0lPTiB8fCAnMS4wLjAnLFxuICAgICAgICBlbnZpcm9ubWVudDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50J1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0Q3VycmVudENvbnRleHQobmV3Q29udGV4dClcbiAgICByZXR1cm4gbmV3Q29udGV4dFxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBjb3JyZWxhdGlvbk1hbmFnZXIgPSBuZXcgQ29ycmVsYXRpb25Db250ZXh0TWFuYWdlcigpXG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gbG9nIHdpdGggY29ycmVsYXRpb24gY29udGV4dFxuZXhwb3J0IGZ1bmN0aW9uIGxvZ1dpdGhDb3JyZWxhdGlvbihcbiAgbGV2ZWw6ICdpbmZvJyB8ICd3YXJuJyB8ICdlcnJvcicgfCAnZGVidWcnLFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIGRhdGE/OiBhbnlcbik6IHZvaWQge1xuICBjb25zdCBjb250ZXh0ID0gY29ycmVsYXRpb25NYW5hZ2VyLmdldENvbnRleHQoKVxuICBjb25zdCBsb2dEYXRhID0ge1xuICAgIG1lc3NhZ2UsXG4gICAgZGF0YSxcbiAgICBjb3JyZWxhdGlvbl9pZDogY29udGV4dD8uaWQsXG4gICAgdHJhY2VfaWQ6IGNvbnRleHQ/LnRyYWNlSWQsXG4gICAgc3Bhbl9pZDogY29udGV4dD8uc3BhbklkLFxuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICB9XG5cbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgY29uc29sZS5pbmZvKCfwn5OKJywgbG9nRGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnd2Fybic6XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jycsIGxvZ0RhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCcsIGxvZ0RhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2RlYnVnJzpcbiAgICAgIGNvbnNvbGUuZGVidWcoJ/CflI0nLCBsb2dEYXRhKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGNvcnJlbGF0aW9uLWF3YXJlIGZldGNoIHdyYXBwZXJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb3JyZWxhdGlvbkF3YXJlRmV0Y2goKTogdHlwZW9mIGZldGNoIHtcbiAgcmV0dXJuIGFzeW5jIChpbnB1dDogUmVxdWVzdEluZm8gfCBVUkwsIGluaXQ/OiBSZXF1ZXN0SW5pdCk6IFByb21pc2U8UmVzcG9uc2U+ID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gY29ycmVsYXRpb25NYW5hZ2VyLmdldENvbnRleHQoKVxuICAgIFxuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gY3JlYXRlRmV0Y2hPcHRpb25zV2l0aENvcnJlbGF0aW9uKGNvbnRleHQuaWQsIGluaXQpXG4gICAgICBcbiAgICAgIC8vIExvZyB0aGUgcmVxdWVzdFxuICAgICAgbG9nV2l0aENvcnJlbGF0aW9uKCdpbmZvJywgJ0FQSSBSZXF1ZXN0Jywge1xuICAgICAgICB1cmw6IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IGlucHV0LnRvU3RyaW5nKCksXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIGNvcnJlbGF0aW9uX2lkOiBjb250ZXh0LmlkLFxuICAgICAgfSlcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbnB1dCwgb3B0aW9ucylcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyB0aGUgcmVzcG9uc2VcbiAgICAgICAgbG9nV2l0aENvcnJlbGF0aW9uKCdpbmZvJywgJ0FQSSBSZXNwb25zZScsIHtcbiAgICAgICAgICB1cmw6IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IGlucHV0LnRvU3RyaW5nKCksXG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICBjb3JyZWxhdGlvbl9pZDogY29udGV4dC5pZCxcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXNwb25zZVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gTG9nIHRoZSBlcnJvclxuICAgICAgICBsb2dXaXRoQ29ycmVsYXRpb24oJ2Vycm9yJywgJ0FQSSBSZXF1ZXN0IEZhaWxlZCcsIHtcbiAgICAgICAgICB1cmw6IHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IGlucHV0LnRvU3RyaW5nKCksXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICBjb3JyZWxhdGlvbl9pZDogY29udGV4dC5pZCxcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIHJlZ3VsYXIgZmV0Y2ggaWYgbm8gY29ycmVsYXRpb24gY29udGV4dFxuICAgIHJldHVybiBmZXRjaChpbnB1dCwgaW5pdClcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIGNvcnJlbGF0aW9uLWF3YXJlIGZldGNoIGZ1bmN0aW9uXG5leHBvcnQgY29uc3QgY29ycmVsYXRpb25Bd2FyZUZldGNoID0gY3JlYXRlQ29ycmVsYXRpb25Bd2FyZUZldGNoKClcblxuLy8gVXRpbGl0eSBmdW5jdGlvbiB0byB3cmFwIGFzeW5jIG9wZXJhdGlvbnMgd2l0aCBjb3JyZWxhdGlvbiBjb250ZXh0XG5leHBvcnQgZnVuY3Rpb24gd2l0aENvcnJlbGF0aW9uQ29udGV4dDxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgY2hpbGRDb250ZXh0ID0gY29ycmVsYXRpb25NYW5hZ2VyLmNyZWF0ZUNoaWxkQ29udGV4dChtZXRhZGF0YSlcbiAgY29ycmVsYXRpb25NYW5hZ2VyLnNldENvbnRleHQoY2hpbGRDb250ZXh0KVxuICBcbiAgcmV0dXJuIG9wZXJhdGlvbigpLmZpbmFsbHkoKCkgPT4ge1xuICAgIC8vIFJlc3RvcmUgcGFyZW50IGNvbnRleHQgaWYgaXQgZXhpc3RzXG4gICAgaWYgKGNoaWxkQ29udGV4dC5wYXJlbnRJZCkge1xuICAgICAgY29uc3QgcGFyZW50Q29udGV4dCA9IGNvcnJlbGF0aW9uTWFuYWdlci5nZXRDb250ZXh0KClcbiAgICAgIGlmIChwYXJlbnRDb250ZXh0ICYmIHBhcmVudENvbnRleHQuaWQgPT09IGNoaWxkQ29udGV4dC5wYXJlbnRJZCkge1xuICAgICAgICBjb3JyZWxhdGlvbk1hbmFnZXIuc2V0Q29udGV4dChwYXJlbnRDb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuLy8gRXhwb3J0IHR5cGVzIGZvciBleHRlcm5hbCB1c2VcbmV4cG9ydCB0eXBlIHsgQ29ycmVsYXRpb25Db250ZXh0IH1cbiJdLCJuYW1lcyI6WyJDT1JSRUxBVElPTl9JRF9IRUFERVIiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ09SUkVMQVRJT05fSURfSEVBREVSIiwiQ09SUkVMQVRJT05fSURfTEVOR1RIIiwicGFyc2VJbnQiLCJORVhUX1BVQkxJQ19DT1JSRUxBVElPTl9JRF9MRU5HVEgiLCJnZW5lcmF0ZUNvcnJlbGF0aW9uSWQiLCJjaGFycyIsInJlc3VsdCIsImkiLCJjaGFyQXQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJnZW5lcmF0ZVRyYWNlSWQiLCJnZW5lcmF0ZVNwYW5JZCIsInN1YnN0cmluZyIsImNyZWF0ZUNvcnJlbGF0aW9uQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJtZXRhZGF0YSIsIm5vdyIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImlkIiwicGFyZW50SWQiLCJ0cmFjZUlkIiwic3BhbklkIiwidXNlcklkIiwic2Vzc2lvbklkIiwicmVxdWVzdElkIiwidGltZXN0YW1wIiwiY3JlYXRlZF9hdCIsImV4dHJhY3RDb3JyZWxhdGlvbklkIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJnZXQiLCJhZGRDb3JyZWxhdGlvbklkIiwiY29ycmVsYXRpb25JZCIsInNldCIsImNyZWF0ZUhlYWRlcnNXaXRoQ29ycmVsYXRpb24iLCJhZGRpdGlvbmFsSGVhZGVycyIsImNyZWF0ZUZldGNoT3B0aW9uc1dpdGhDb3JyZWxhdGlvbiIsIm9wdGlvbnMiLCJDb3JyZWxhdGlvbkNvbnRleHRNYW5hZ2VyIiwic2V0Q29udGV4dCIsImNvbnRleHQiLCJjdXJyZW50Q29udGV4dCIsIm5vdGlmeUxpc3RlbmVycyIsImdldENvbnRleHQiLCJjcmVhdGVDaGlsZENvbnRleHQiLCJwYXJlbnRfY29ycmVsYXRpb25faWQiLCJ1cGRhdGVDb250ZXh0IiwidXBkYXRlZF9hdCIsImNsZWFyQ29udGV4dCIsInN1YnNjcmliZSIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYWRkIiwiZGVsZXRlIiwiZm9yRWFjaCIsImVycm9yIiwiY29uc29sZSIsImV4dHJhY3RGcm9tSGVhZGVycyIsInNldEN1cnJlbnRDb250ZXh0IiwibmV3Q29udGV4dCIsInV1aWR2NCIsInVuZGVmaW5lZCIsInRlbmFudElkIiwidG9TdHJpbmciLCJzZXJ2aWNlIiwidmVyc2lvbiIsIk5FWFRfUFVCTElDX0FQUF9WRVJTSU9OIiwiZW52aXJvbm1lbnQiLCJTZXQiLCJjb3JyZWxhdGlvbk1hbmFnZXIiLCJsb2dXaXRoQ29ycmVsYXRpb24iLCJsZXZlbCIsIm1lc3NhZ2UiLCJkYXRhIiwibG9nRGF0YSIsImNvcnJlbGF0aW9uX2lkIiwidHJhY2VfaWQiLCJzcGFuX2lkIiwiaW5mbyIsIndhcm4iLCJkZWJ1ZyIsImNyZWF0ZUNvcnJlbGF0aW9uQXdhcmVGZXRjaCIsImlucHV0IiwiaW5pdCIsInVybCIsIm1ldGhvZCIsInJlc3BvbnNlIiwiZmV0Y2giLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJTdHJpbmciLCJjb3JyZWxhdGlvbkF3YXJlRmV0Y2giLCJ3aXRoQ29ycmVsYXRpb25Db250ZXh0Iiwib3BlcmF0aW9uIiwiY2hpbGRDb250ZXh0IiwiZmluYWxseSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/correlation-id.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/health-monitoring-simple.ts":
/*!*********************************************!*\
  !*** ./src/lib/health-monitoring-simple.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   healthMonitoring: () => (/* binding */ healthMonitoring)\n/* harmony export */ });\n/* harmony import */ var _correlation_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./correlation-id */ \"(app-pages-browser)/./src/lib/correlation-id.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Default health check configurations\nconst DEFAULT_HEALTH_CHECKS = [\n    {\n        name: 'system',\n        endpoint: 'internal',\n        timeout: 5000,\n        critical: false,\n        retries: 2\n    },\n    {\n        name: 'frontend',\n        endpoint: '/api/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3\n    },\n    {\n        name: 'backend-api',\n        endpoint: process.env.NEXT_PUBLIC_HEALTH_API_URL || 'http://localhost:8000/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3\n    }\n];\n// Health monitoring service\nclass HealthMonitoringService {\n    // Run a single health check\n    async runHealthCheck(config) {\n        var _correlationIDManager_getCurrentContext;\n        const startTime = Date.now();\n        const correlationId = (_correlationIDManager_getCurrentContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()) === null || _correlationIDManager_getCurrentContext === void 0 ? void 0 : _correlationIDManager_getCurrentContext.correlationId;\n        try {\n            let result;\n            if (config.endpoint === 'internal') {\n                // Internal system check\n                result = await this.runInternalHealthCheck(config);\n            } else {\n                // External endpoint check\n                result = await this.runExternalHealthCheck(config);\n            }\n            // Add correlation ID to result\n            if (correlationId) {\n                result.correlationId = correlationId;\n            }\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString(),\n                correlationId\n            };\n        }\n    }\n    // Run internal health check\n    async runInternalHealthCheck(config) {\n        const startTime = Date.now();\n        try {\n            // Check system resources\n            const systemInfo = await this.getSystemInfo();\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'pass',\n                responseTime,\n                details: systemInfo,\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Run external health check\n    async runExternalHealthCheck(config) {\n        const startTime = Date.now();\n        let lastError = null;\n        // Try with retries\n        for(let attempt = 1; attempt <= config.retries; attempt++){\n            try {\n                const headers = {\n                    ...(0,_correlation_id__WEBPACK_IMPORTED_MODULE_0__.getCorrelationHeaders)(),\n                    ...config.headers,\n                    'User-Agent': 'Health-Monitor/1.0'\n                };\n                const controller = new AbortController();\n                const timeoutId = setTimeout(()=>controller.abort(), config.timeout);\n                const response = await fetch(config.endpoint, {\n                    method: 'HEAD',\n                    headers,\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                const responseTime = Date.now() - startTime;\n                if (config.expectedStatus && response.status !== config.expectedStatus) {\n                    throw new Error(\"Expected status \".concat(config.expectedStatus, \", got \").concat(response.status));\n                }\n                return {\n                    status: response.status < 400 ? 'pass' : response.status < 500 ? 'warn' : 'fail',\n                    responseTime,\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText,\n                        headers: Object.fromEntries(response.headers.entries())\n                    },\n                    timestamp: new Date().toISOString()\n                };\n            } catch (error) {\n                lastError = error instanceof Error ? error : new Error(String(error));\n                // If this is the last attempt, throw the error\n                if (attempt === config.retries) {\n                    break;\n                }\n                // Wait before retry (exponential backoff)\n                await new Promise((resolve)=>setTimeout(resolve, Math.pow(2, attempt) * 100));\n            }\n        }\n        const responseTime = Date.now() - startTime;\n        throw lastError || new Error('Health check failed after all retries');\n    }\n    // Get system information\n    async getSystemInfo() {\n        if (false) {}\n        // Client-side\n        return {\n            platform: 'browser',\n            userAgent: navigator.userAgent,\n            language: navigator.language,\n            cookieEnabled: navigator.cookieEnabled,\n            onLine: navigator.onLine,\n            timestamp: new Date().toISOString()\n        };\n    }\n    // Run comprehensive health check\n    async runComprehensiveHealthCheck() {\n        var _correlationIDManager_getCurrentContext;\n        const startTime = Date.now();\n        const correlationId = (_correlationIDManager_getCurrentContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()) === null || _correlationIDManager_getCurrentContext === void 0 ? void 0 : _correlationIDManager_getCurrentContext.correlationId;\n        // Generate correlation context for this health check\n        const healthCheckContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.generateContext(correlationId, undefined, undefined, undefined, {\n            operation: 'health_check',\n            type: 'comprehensive'\n        });\n        try {\n            const checkResults = {};\n            const checkPromises = DEFAULT_HEALTH_CHECKS.map(async (config)=>{\n                const result = await this.runHealthCheck(config);\n                checkResults[config.name] = result;\n                return result;\n            });\n            await Promise.allSettled(checkPromises);\n            // Calculate summary\n            const summary = this.calculateHealthSummary(checkResults);\n            // Determine overall status\n            let status = 'healthy';\n            if (summary.failedChecks > 0) {\n                status = 'unhealthy';\n            } else if (summary.warningChecks > 0 || summary.overallHealth < 90) {\n                status = 'degraded';\n            }\n            const result = {\n                status,\n                timestamp: new Date().toISOString(),\n                checks: checkResults,\n                summary,\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Add to history\n            this.healthHistory.push(result);\n            if (this.healthHistory.length > 100) {\n                this.healthHistory = this.healthHistory.slice(-100);\n            }\n            // Update metrics\n            this.updateMetrics(result);\n            // Log correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'info');\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            // Create error result\n            const errorResult = {\n                status: 'unhealthy',\n                timestamp: new Date().toISOString(),\n                checks: {},\n                summary: {\n                    overallHealth: 0,\n                    totalChecks: 0,\n                    passedChecks: 0,\n                    failedChecks: 1,\n                    warningChecks: 0,\n                    averageResponseTime: responseTime\n                },\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Log error with correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'error');\n            return errorResult;\n        } finally{\n            // Clear the health check context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.clearCurrentContext();\n        }\n    }\n    // Calculate health summary\n    calculateHealthSummary(checks) {\n        const checkArray = Object.values(checks);\n        const totalChecks = checkArray.length;\n        const passedChecks = checkArray.filter((c)=>c.status === 'pass').length;\n        const failedChecks = checkArray.filter((c)=>c.status === 'fail').length;\n        const warningChecks = checkArray.filter((c)=>c.status === 'warn').length;\n        const overallHealth = totalChecks > 0 ? passedChecks / totalChecks * 100 : 0;\n        const averageResponseTime = checkArray.length > 0 ? checkArray.reduce((sum, c)=>sum + c.responseTime, 0) / checkArray.length : 0;\n        return {\n            overallHealth: Math.round(overallHealth),\n            totalChecks,\n            passedChecks,\n            failedChecks,\n            warningChecks,\n            averageResponseTime: Math.round(averageResponseTime)\n        };\n    }\n    // Update metrics history\n    updateMetrics(healthResult) {\n        const metrics = {\n            overallScore: healthResult.summary.overallHealth,\n            errorRate: healthResult.summary.failedChecks / healthResult.summary.totalChecks,\n            responseTime: healthResult.summary.averageResponseTime,\n            uptime: healthResult.status === 'healthy' ? 100 : healthResult.status === 'degraded' ? 75 : 0,\n            lastCheck: healthResult.timestamp\n        };\n        this.metricsHistory.push(metrics);\n        if (this.metricsHistory.length > 1000) {\n            this.metricsHistory = this.metricsHistory.slice(-1000);\n        }\n    }\n    // Start monitoring\n    startMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        if (this.isMonitoring) return;\n        this.isMonitoring = true;\n        this.monitoringInterval = setInterval(async ()=>{\n            try {\n                await this.runComprehensiveHealthCheck();\n            } catch (error) {\n                console.error('Health monitoring error:', error);\n            }\n        }, intervalMs);\n        console.log('Health monitoring started with interval:', intervalMs, 'ms');\n    }\n    // Stop monitoring\n    stopMonitoring() {\n        if (this.monitoringInterval) {\n            clearInterval(this.monitoringInterval);\n            this.monitoringInterval = null;\n        }\n        this.isMonitoring = false;\n        console.log('Health monitoring stopped');\n    }\n    // Get current health\n    getCurrentHealth() {\n        return this.healthHistory.length > 0 ? this.healthHistory[this.healthHistory.length - 1] : null;\n    }\n    // Get health history\n    getHealthHistory() {\n        return [\n            ...this.healthHistory\n        ];\n    }\n    // Get metrics history\n    getMetricsHistory() {\n        return [\n            ...this.metricsHistory\n        ];\n    }\n    // Check if monitoring is active\n    isMonitoringActive() {\n        return this.isMonitoring;\n    }\n    // Get monitoring status\n    getMonitoringStatus() {\n        return {\n            isActive: this.isMonitoring,\n            interval: this.monitoringInterval ? 30000 : null\n        };\n    }\n    constructor(){\n        this.healthHistory = [];\n        this.metricsHistory = [];\n        this.isMonitoring = false;\n        this.monitoringInterval = null;\n    }\n}\n// Export singleton instance\nconst healthMonitoring = new HealthMonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaGVhbHRoLW1vbml0b3Jpbmctc2ltcGxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RTtBQTBEOUUsc0NBQXNDO0FBQ3RDLE1BQU1FLHdCQUE2QztJQUNqRDtRQUNFQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUNBO1FBQ0VKLE1BQU07UUFDTkMsVUFBVTtRQUNWQyxTQUFTO1FBQ1RHLGdCQUFnQjtRQUNoQkYsVUFBVTtRQUNWQyxTQUFTO0lBQ1g7SUFDQTtRQUNFSixNQUFNO1FBQ05DLFVBQVVLLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsMEJBQTBCLElBQUk7UUFDcEROLFNBQVM7UUFDVEcsZ0JBQWdCO1FBQ2hCRixVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtDQUNEO0FBRUQsNEJBQTRCO0FBQzVCLE1BQU1LO0lBTUosNEJBQTRCO0lBQzVCLE1BQU1DLGVBQWVDLE1BQXlCLEVBQThCO1lBRXBEZDtRQUR0QixNQUFNZSxZQUFZQyxLQUFLQyxHQUFHO1FBQzFCLE1BQU1DLGlCQUFnQmxCLDBDQUFBQSxtRkFBc0MsZ0JBQXRDQSw4REFBQUEsd0NBQTBDa0IsYUFBYTtRQUU3RSxJQUFJO1lBQ0YsSUFBSUU7WUFFSixJQUFJTixPQUFPVixRQUFRLEtBQUssWUFBWTtnQkFDbEMsd0JBQXdCO2dCQUN4QmdCLFNBQVMsTUFBTSxJQUFJLENBQUNDLHNCQUFzQixDQUFDUDtZQUM3QyxPQUFPO2dCQUNMLDBCQUEwQjtnQkFDMUJNLFNBQVMsTUFBTSxJQUFJLENBQUNFLHNCQUFzQixDQUFDUjtZQUM3QztZQUVBLCtCQUErQjtZQUMvQixJQUFJSSxlQUFlO2dCQUNqQkUsT0FBT0YsYUFBYSxHQUFHQTtZQUN6QjtZQUVBLE9BQU9FO1FBQ1QsRUFBRSxPQUFPRyxPQUFPO1lBQ2QsTUFBTUMsZUFBZVIsS0FBS0MsR0FBRyxLQUFLRjtZQUNsQyxPQUFPO2dCQUNMVSxRQUFR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Q2pDO0lBRUEsZ0NBQWdDO0lBQ2hDYSxxQkFBOEI7UUFDNUIsT0FBTyxJQUFJLENBQUNWLFlBQVk7SUFDMUI7SUFFQSx3QkFBd0I7SUFDeEJXLHNCQUFzRTtRQUNwRSxPQUFPO1lBQ0xDLFVBQVUsSUFBSSxDQUFDWixZQUFZO1lBQzNCYSxVQUFVLElBQUksQ0FBQ1osa0JBQWtCLEdBQUcsUUFBUTtRQUM5QztJQUNGOzthQS9VUTVCLGdCQUFnQyxFQUFFO2FBQ2xDd0IsaUJBQXVDLEVBQUU7YUFDekNHLGVBQXdCO2FBQ3hCQyxxQkFBNEM7O0FBNlV0RDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNYSxtQkFBbUIsSUFBSWhILDBCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2xpYi9oZWFsdGgtbW9uaXRvcmluZy1zaW1wbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29ycmVsYXRpb25JRE1hbmFnZXIsIGdldENvcnJlbGF0aW9uSGVhZGVycyB9IGZyb20gJy4vY29ycmVsYXRpb24taWQnXG5cbi8vIEhlYWx0aCBjaGVjayBjb25maWd1cmF0aW9uIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja0NvbmZpZyB7XG4gIG5hbWU6IHN0cmluZ1xuICBlbmRwb2ludDogc3RyaW5nXG4gIHRpbWVvdXQ6IG51bWJlclxuICBleHBlY3RlZFN0YXR1cz86IG51bWJlclxuICBjcml0aWNhbDogYm9vbGVhblxuICByZXRyaWVzOiBudW1iZXJcbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbn1cblxuLy8gSGVhbHRoIGNoZWNrIHJlc3VsdCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQ2hlY2tSZXN1bHQge1xuICBzdGF0dXM6ICdwYXNzJyB8ICd3YXJuJyB8ICdmYWlsJ1xuICByZXNwb25zZVRpbWU6IG51bWJlclxuICBlcnJvcj86IHN0cmluZ1xuICBkZXRhaWxzPzogYW55XG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmdcbn1cblxuLy8gSGVhbHRoIGluZGV4IG1ldHJpY3MgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aEluZGV4TWV0cmljcyB7XG4gIG92ZXJhbGxTY29yZTogbnVtYmVyXG4gIGVycm9yUmF0ZTogbnVtYmVyXG4gIHJlc3BvbnNlVGltZTogbnVtYmVyXG4gIHVwdGltZTogbnVtYmVyXG4gIGxhc3RDaGVjazogc3RyaW5nXG59XG5cbi8vIEhlYWx0aCBzdW1tYXJ5IGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhTdW1tYXJ5IHtcbiAgb3ZlcmFsbEhlYWx0aDogbnVtYmVyXG4gIHRvdGFsQ2hlY2tzOiBudW1iZXJcbiAgcGFzc2VkQ2hlY2tzOiBudW1iZXJcbiAgZmFpbGVkQ2hlY2tzOiBudW1iZXJcbiAgd2FybmluZ0NoZWNrczogbnVtYmVyXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IG51bWJlclxufVxuXG4vLyBIZWFsdGggcmVzdWx0IGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhSZXN1bHQge1xuICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5J1xuICB0aW1lc3RhbXA6IHN0cmluZ1xuICBjaGVja3M6IFJlY29yZDxzdHJpbmcsIEhlYWx0aENoZWNrUmVzdWx0PlxuICBzdW1tYXJ5OiBIZWFsdGhTdW1tYXJ5XG4gIG1ldGFkYXRhOiB7XG4gICAgc2VydmljZTogc3RyaW5nXG4gICAgcmVnaW9uOiBzdHJpbmdcbiAgICBpbnN0YW5jZTogc3RyaW5nXG4gICAgYnVpbGQ6IHN0cmluZ1xuICAgIGNvbW1pdDogc3RyaW5nXG4gICAgY29ycmVsYXRpb25JZD86IHN0cmluZ1xuICB9XG59XG5cbi8vIERlZmF1bHQgaGVhbHRoIGNoZWNrIGNvbmZpZ3VyYXRpb25zXG5jb25zdCBERUZBVUxUX0hFQUxUSF9DSEVDS1M6IEhlYWx0aENoZWNrQ29uZmlnW10gPSBbXG4gIHtcbiAgICBuYW1lOiAnc3lzdGVtJyxcbiAgICBlbmRwb2ludDogJ2ludGVybmFsJywgLy8gU3BlY2lhbCBjYXNlIGZvciBzeXN0ZW0gY2hlY2tzXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBjcml0aWNhbDogZmFsc2UsXG4gICAgcmV0cmllczogMixcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdmcm9udGVuZCcsXG4gICAgZW5kcG9pbnQ6ICcvYXBpL2hlYWx0aCcsXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBleHBlY3RlZFN0YXR1czogMjAwLFxuICAgIGNyaXRpY2FsOiB0cnVlLFxuICAgIHJldHJpZXM6IDMsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnYmFja2VuZC1hcGknLFxuICAgIGVuZHBvaW50OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IRUFMVEhfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2hlYWx0aCcsXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBleHBlY3RlZFN0YXR1czogMjAwLFxuICAgIGNyaXRpY2FsOiB0cnVlLFxuICAgIHJldHJpZXM6IDMsXG4gIH0sXG5dXG5cbi8vIEhlYWx0aCBtb25pdG9yaW5nIHNlcnZpY2VcbmNsYXNzIEhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBoZWFsdGhIaXN0b3J5OiBIZWFsdGhSZXN1bHRbXSA9IFtdXG4gIHByaXZhdGUgbWV0cmljc0hpc3Rvcnk6IEhlYWx0aEluZGV4TWV0cmljc1tdID0gW11cbiAgcHJpdmF0ZSBpc01vbml0b3Jpbmc6IGJvb2xlYW4gPSBmYWxzZVxuICBwcml2YXRlIG1vbml0b3JpbmdJbnRlcnZhbDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbFxuXG4gIC8vIFJ1biBhIHNpbmdsZSBoZWFsdGggY2hlY2tcbiAgYXN5bmMgcnVuSGVhbHRoQ2hlY2soY29uZmlnOiBIZWFsdGhDaGVja0NvbmZpZyk6IFByb21pc2U8SGVhbHRoQ2hlY2tSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk/LmNvcnJlbGF0aW9uSWRcblxuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzdWx0OiBIZWFsdGhDaGVja1Jlc3VsdFxuXG4gICAgICBpZiAoY29uZmlnLmVuZHBvaW50ID09PSAnaW50ZXJuYWwnKSB7XG4gICAgICAgIC8vIEludGVybmFsIHN5c3RlbSBjaGVja1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkludGVybmFsSGVhbHRoQ2hlY2soY29uZmlnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXh0ZXJuYWwgZW5kcG9pbnQgY2hlY2tcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5FeHRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZylcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGNvcnJlbGF0aW9uIElEIHRvIHJlc3VsdFxuICAgICAgaWYgKGNvcnJlbGF0aW9uSWQpIHtcbiAgICAgICAgcmVzdWx0LmNvcnJlbGF0aW9uSWQgPSBjb3JyZWxhdGlvbklkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnZmFpbCcsXG4gICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNvcnJlbGF0aW9uSWRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSdW4gaW50ZXJuYWwgaGVhbHRoIGNoZWNrXG4gIHByaXZhdGUgYXN5bmMgcnVuSW50ZXJuYWxIZWFsdGhDaGVjayhjb25maWc6IEhlYWx0aENoZWNrQ29uZmlnKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgc3lzdGVtIHJlc291cmNlc1xuICAgICAgY29uc3Qgc3lzdGVtSW5mbyA9IGF3YWl0IHRoaXMuZ2V0U3lzdGVtSW5mbygpXG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAncGFzcycsXG4gICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgZGV0YWlsczogc3lzdGVtSW5mbyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnZmFpbCcsXG4gICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSdW4gZXh0ZXJuYWwgaGVhbHRoIGNoZWNrXG4gIHByaXZhdGUgYXN5bmMgcnVuRXh0ZXJuYWxIZWFsdGhDaGVjayhjb25maWc6IEhlYWx0aENoZWNrQ29uZmlnKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsXG5cbiAgICAvLyBUcnkgd2l0aCByZXRyaWVzXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gY29uZmlnLnJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAuLi5nZXRDb3JyZWxhdGlvbkhlYWRlcnMoKSxcbiAgICAgICAgICAuLi5jb25maWcuaGVhZGVycyxcbiAgICAgICAgICAnVXNlci1BZ2VudCc6ICdIZWFsdGgtTW9uaXRvci8xLjAnXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBjb25maWcudGltZW91dClcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGNvbmZpZy5lbmRwb2ludCwge1xuICAgICAgICAgIG1ldGhvZDogJ0hFQUQnLCAvLyBVc2UgSEVBRCBmb3IgaGVhbHRoIGNoZWNrcyB0byBtaW5pbWl6ZSBkYXRhIHRyYW5zZmVyXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgIH0pXG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG5cbiAgICAgICAgaWYgKGNvbmZpZy5leHBlY3RlZFN0YXR1cyAmJiByZXNwb25zZS5zdGF0dXMgIT09IGNvbmZpZy5leHBlY3RlZFN0YXR1cykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgc3RhdHVzICR7Y29uZmlnLmV4cGVjdGVkU3RhdHVzfSwgZ290ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIDwgNDAwID8gJ3Bhc3MnIDogcmVzcG9uc2Uuc3RhdHVzIDwgNTAwID8gJ3dhcm4nIDogJ2ZhaWwnLFxuICAgICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMocmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSlcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgYXR0ZW1wdCwgdGhyb3cgdGhlIGVycm9yXG4gICAgICAgIGlmIChhdHRlbXB0ID09PSBjb25maWcucmV0cmllcykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeSAoZXhwb25lbnRpYWwgYmFja29mZilcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucG93KDIsIGF0dGVtcHQpICogMTAwKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgdGhyb3cgbGFzdEVycm9yIHx8IG5ldyBFcnJvcignSGVhbHRoIGNoZWNrIGZhaWxlZCBhZnRlciBhbGwgcmV0cmllcycpXG4gIH1cblxuICAvLyBHZXQgc3lzdGVtIGluZm9ybWF0aW9uXG4gIHByaXZhdGUgYXN5bmMgZ2V0U3lzdGVtSW5mbygpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gU2VydmVyLXNpZGVcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBsYXRmb3JtOiAnc2VydmVyJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGllbnQtc2lkZVxuICAgIHJldHVybiB7XG4gICAgICBwbGF0Zm9ybTogJ2Jyb3dzZXInLFxuICAgICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgbGFuZ3VhZ2U6IG5hdmlnYXRvci5sYW5ndWFnZSxcbiAgICAgIGNvb2tpZUVuYWJsZWQ6IG5hdmlnYXRvci5jb29raWVFbmFibGVkLFxuICAgICAgb25MaW5lOiBuYXZpZ2F0b3Iub25MaW5lLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICB9XG4gIH1cblxuICAvLyBSdW4gY29tcHJlaGVuc2l2ZSBoZWFsdGggY2hlY2tcbiAgYXN5bmMgcnVuQ29tcHJlaGVuc2l2ZUhlYWx0aENoZWNrKCk6IFByb21pc2U8SGVhbHRoUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGNvcnJlbGF0aW9uSWQgPSBjb3JyZWxhdGlvbklETWFuYWdlci5nZXRDdXJyZW50Q29udGV4dCgpPy5jb3JyZWxhdGlvbklkXG5cbiAgICAvLyBHZW5lcmF0ZSBjb3JyZWxhdGlvbiBjb250ZXh0IGZvciB0aGlzIGhlYWx0aCBjaGVja1xuICAgIGNvbnN0IGhlYWx0aENoZWNrQ29udGV4dCA9IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdlbmVyYXRlQ29udGV4dChcbiAgICAgIGNvcnJlbGF0aW9uSWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB7IG9wZXJhdGlvbjogJ2hlYWx0aF9jaGVjaycsIHR5cGU6ICdjb21wcmVoZW5zaXZlJyB9XG4gICAgKVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNoZWNrUmVzdWx0czogUmVjb3JkPHN0cmluZywgSGVhbHRoQ2hlY2tSZXN1bHQ+ID0ge31cbiAgICAgIGNvbnN0IGNoZWNrUHJvbWlzZXMgPSBERUZBVUxUX0hFQUxUSF9DSEVDS1MubWFwKGFzeW5jIChjb25maWcpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5IZWFsdGhDaGVjayhjb25maWcpXG4gICAgICAgIGNoZWNrUmVzdWx0c1tjb25maWcubmFtZV0gPSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGNoZWNrUHJvbWlzZXMpXG5cbiAgICAgIC8vIENhbGN1bGF0ZSBzdW1tYXJ5XG4gICAgICBjb25zdCBzdW1tYXJ5ID0gdGhpcy5jYWxjdWxhdGVIZWFsdGhTdW1tYXJ5KGNoZWNrUmVzdWx0cylcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIG92ZXJhbGwgc3RhdHVzXG4gICAgICBsZXQgc3RhdHVzOiAnaGVhbHRoeScgfCAnZGVncmFkZWQnIHwgJ3VuaGVhbHRoeScgPSAnaGVhbHRoeSdcbiAgICAgIGlmIChzdW1tYXJ5LmZhaWxlZENoZWNrcyA+IDApIHtcbiAgICAgICAgc3RhdHVzID0gJ3VuaGVhbHRoeSdcbiAgICAgIH0gZWxzZSBpZiAoc3VtbWFyeS53YXJuaW5nQ2hlY2tzID4gMCB8fCBzdW1tYXJ5Lm92ZXJhbGxIZWFsdGggPCA5MCkge1xuICAgICAgICBzdGF0dXMgPSAnZGVncmFkZWQnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdDogSGVhbHRoUmVzdWx0ID0ge1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjaGVja3M6IGNoZWNrUmVzdWx0cyxcbiAgICAgICAgc3VtbWFyeSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBzZXJ2aWNlOiAnQUkgU2FhUyBGYWN0b3J5IC0gTmV4dC5qcyBGcm9udGVuZCcsXG4gICAgICAgICAgcmVnaW9uOiAnbG9jYWwnLFxuICAgICAgICAgIGluc3RhbmNlOiAnbG9jYWxob3N0JyxcbiAgICAgICAgICBidWlsZDogJ2xvY2FsJyxcbiAgICAgICAgICBjb21taXQ6ICdsb2NhbCcsXG4gICAgICAgICAgY29ycmVsYXRpb25JZDogaGVhbHRoQ2hlY2tDb250ZXh0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdG8gaGlzdG9yeVxuICAgICAgdGhpcy5oZWFsdGhIaXN0b3J5LnB1c2gocmVzdWx0KVxuICAgICAgaWYgKHRoaXMuaGVhbHRoSGlzdG9yeS5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgdGhpcy5oZWFsdGhIaXN0b3J5ID0gdGhpcy5oZWFsdGhIaXN0b3J5LnNsaWNlKC0xMDApXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBtZXRyaWNzXG4gICAgICB0aGlzLnVwZGF0ZU1ldHJpY3MocmVzdWx0KVxuXG4gICAgICAvLyBMb2cgY29ycmVsYXRpb24gY29udGV4dFxuICAgICAgY29ycmVsYXRpb25JRE1hbmFnZXIubG9nQ29udGV4dChoZWFsdGhDaGVja0NvbnRleHQsICdpbmZvJylcblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBlcnJvciByZXN1bHRcbiAgICAgIGNvbnN0IGVycm9yUmVzdWx0OiBIZWFsdGhSZXN1bHQgPSB7XG4gICAgICAgIHN0YXR1czogJ3VuaGVhbHRoeScsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBjaGVja3M6IHt9LFxuICAgICAgICBzdW1tYXJ5OiB7XG4gICAgICAgICAgb3ZlcmFsbEhlYWx0aDogMCxcbiAgICAgICAgICB0b3RhbENoZWNrczogMCxcbiAgICAgICAgICBwYXNzZWRDaGVja3M6IDAsXG4gICAgICAgICAgZmFpbGVkQ2hlY2tzOiAxLFxuICAgICAgICAgIHdhcm5pbmdDaGVja3M6IDAsXG4gICAgICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogcmVzcG9uc2VUaW1lXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgc2VydmljZTogJ0FJIFNhYVMgRmFjdG9yeSAtIE5leHQuanMgRnJvbnRlbmQnLFxuICAgICAgICAgIHJlZ2lvbjogJ2xvY2FsJyxcbiAgICAgICAgICBpbnN0YW5jZTogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgYnVpbGQ6ICdsb2NhbCcsXG4gICAgICAgICAgY29tbWl0OiAnbG9jYWwnLFxuICAgICAgICAgIGNvcnJlbGF0aW9uSWQ6IGhlYWx0aENoZWNrQ29udGV4dC5jb3JyZWxhdGlvbklkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTG9nIGVycm9yIHdpdGggY29ycmVsYXRpb24gY29udGV4dFxuICAgICAgY29ycmVsYXRpb25JRE1hbmFnZXIubG9nQ29udGV4dChoZWFsdGhDaGVja0NvbnRleHQsICdlcnJvcicpXG4gICAgICBcbiAgICAgIHJldHVybiBlcnJvclJlc3VsdFxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBDbGVhciB0aGUgaGVhbHRoIGNoZWNrIGNvbnRleHRcbiAgICAgIGNvcnJlbGF0aW9uSURNYW5hZ2VyLmNsZWFyQ3VycmVudENvbnRleHQoKVxuICAgIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBoZWFsdGggc3VtbWFyeVxuICBwcml2YXRlIGNhbGN1bGF0ZUhlYWx0aFN1bW1hcnkoY2hlY2tzOiBSZWNvcmQ8c3RyaW5nLCBIZWFsdGhDaGVja1Jlc3VsdD4pOiBIZWFsdGhTdW1tYXJ5IHtcbiAgICBjb25zdCBjaGVja0FycmF5ID0gT2JqZWN0LnZhbHVlcyhjaGVja3MpXG4gICAgY29uc3QgdG90YWxDaGVja3MgPSBjaGVja0FycmF5Lmxlbmd0aFxuICAgIGNvbnN0IHBhc3NlZENoZWNrcyA9IGNoZWNrQXJyYXkuZmlsdGVyKGMgPT4gYy5zdGF0dXMgPT09ICdwYXNzJykubGVuZ3RoXG4gICAgY29uc3QgZmFpbGVkQ2hlY2tzID0gY2hlY2tBcnJheS5maWx0ZXIoYyA9PiBjLnN0YXR1cyA9PT0gJ2ZhaWwnKS5sZW5ndGhcbiAgICBjb25zdCB3YXJuaW5nQ2hlY2tzID0gY2hlY2tBcnJheS5maWx0ZXIoYyA9PiBjLnN0YXR1cyA9PT0gJ3dhcm4nKS5sZW5ndGhcblxuICAgIGNvbnN0IG92ZXJhbGxIZWFsdGggPSB0b3RhbENoZWNrcyA+IDAgPyAocGFzc2VkQ2hlY2tzIC8gdG90YWxDaGVja3MpICogMTAwIDogMFxuICAgIGNvbnN0IGF2ZXJhZ2VSZXNwb25zZVRpbWUgPSBjaGVja0FycmF5Lmxlbmd0aCA+IDAgXG4gICAgICA/IGNoZWNrQXJyYXkucmVkdWNlKChzdW0sIGMpID0+IHN1bSArIGMucmVzcG9uc2VUaW1lLCAwKSAvIGNoZWNrQXJyYXkubGVuZ3RoIFxuICAgICAgOiAwXG5cbiAgICByZXR1cm4ge1xuICAgICAgb3ZlcmFsbEhlYWx0aDogTWF0aC5yb3VuZChvdmVyYWxsSGVhbHRoKSxcbiAgICAgIHRvdGFsQ2hlY2tzLFxuICAgICAgcGFzc2VkQ2hlY2tzLFxuICAgICAgZmFpbGVkQ2hlY2tzLFxuICAgICAgd2FybmluZ0NoZWNrcyxcbiAgICAgIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IE1hdGgucm91bmQoYXZlcmFnZVJlc3BvbnNlVGltZSlcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgbWV0cmljcyBoaXN0b3J5XG4gIHByaXZhdGUgdXBkYXRlTWV0cmljcyhoZWFsdGhSZXN1bHQ6IEhlYWx0aFJlc3VsdCk6IHZvaWQge1xuICAgIGNvbnN0IG1ldHJpY3M6IEhlYWx0aEluZGV4TWV0cmljcyA9IHtcbiAgICAgIG92ZXJhbGxTY29yZTogaGVhbHRoUmVzdWx0LnN1bW1hcnkub3ZlcmFsbEhlYWx0aCxcbiAgICAgIGVycm9yUmF0ZTogaGVhbHRoUmVzdWx0LnN1bW1hcnkuZmFpbGVkQ2hlY2tzIC8gaGVhbHRoUmVzdWx0LnN1bW1hcnkudG90YWxDaGVja3MsXG4gICAgICByZXNwb25zZVRpbWU6IGhlYWx0aFJlc3VsdC5zdW1tYXJ5LmF2ZXJhZ2VSZXNwb25zZVRpbWUsXG4gICAgICB1cHRpbWU6IGhlYWx0aFJlc3VsdC5zdGF0dXMgPT09ICdoZWFsdGh5JyA/IDEwMCA6IGhlYWx0aFJlc3VsdC5zdGF0dXMgPT09ICdkZWdyYWRlZCcgPyA3NSA6IDAsXG4gICAgICBsYXN0Q2hlY2s6IGhlYWx0aFJlc3VsdC50aW1lc3RhbXBcbiAgICB9XG5cbiAgICB0aGlzLm1ldHJpY3NIaXN0b3J5LnB1c2gobWV0cmljcylcbiAgICBpZiAodGhpcy5tZXRyaWNzSGlzdG9yeS5sZW5ndGggPiAxMDAwKSB7XG4gICAgICB0aGlzLm1ldHJpY3NIaXN0b3J5ID0gdGhpcy5tZXRyaWNzSGlzdG9yeS5zbGljZSgtMTAwMClcbiAgICB9XG4gIH1cblxuICAvLyBTdGFydCBtb25pdG9yaW5nXG4gIHN0YXJ0TW9uaXRvcmluZyhpbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzTW9uaXRvcmluZykgcmV0dXJuXG5cbiAgICB0aGlzLmlzTW9uaXRvcmluZyA9IHRydWVcbiAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ29tcHJlaGVuc2l2ZUhlYWx0aENoZWNrKClcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0hlYWx0aCBtb25pdG9yaW5nIGVycm9yOicsIGVycm9yKVxuICAgICAgfVxuICAgIH0sIGludGVydmFsTXMpXG5cbiAgICBjb25zb2xlLmxvZygnSGVhbHRoIG1vbml0b3Jpbmcgc3RhcnRlZCB3aXRoIGludGVydmFsOicsIGludGVydmFsTXMsICdtcycpXG4gIH1cblxuICAvLyBTdG9wIG1vbml0b3JpbmdcbiAgc3RvcE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvcmluZ0ludGVydmFsKVxuICAgICAgdGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuICAgIHRoaXMuaXNNb25pdG9yaW5nID0gZmFsc2VcbiAgICBjb25zb2xlLmxvZygnSGVhbHRoIG1vbml0b3Jpbmcgc3RvcHBlZCcpXG4gIH1cblxuICAvLyBHZXQgY3VycmVudCBoZWFsdGhcbiAgZ2V0Q3VycmVudEhlYWx0aCgpOiBIZWFsdGhSZXN1bHQgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5oZWFsdGhIaXN0b3J5Lmxlbmd0aCA+IDAgPyB0aGlzLmhlYWx0aEhpc3RvcnlbdGhpcy5oZWFsdGhIaXN0b3J5Lmxlbmd0aCAtIDFdIDogbnVsbFxuICB9XG5cbiAgLy8gR2V0IGhlYWx0aCBoaXN0b3J5XG4gIGdldEhlYWx0aEhpc3RvcnkoKTogSGVhbHRoUmVzdWx0W10ge1xuICAgIHJldHVybiBbLi4udGhpcy5oZWFsdGhIaXN0b3J5XVxuICB9XG5cbiAgLy8gR2V0IG1ldHJpY3MgaGlzdG9yeVxuICBnZXRNZXRyaWNzSGlzdG9yeSgpOiBIZWFsdGhJbmRleE1ldHJpY3NbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLm1ldHJpY3NIaXN0b3J5XVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgbW9uaXRvcmluZyBpcyBhY3RpdmVcbiAgaXNNb25pdG9yaW5nQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzTW9uaXRvcmluZ1xuICB9XG5cbiAgLy8gR2V0IG1vbml0b3Jpbmcgc3RhdHVzXG4gIGdldE1vbml0b3JpbmdTdGF0dXMoKTogeyBpc0FjdGl2ZTogYm9vbGVhbjsgaW50ZXJ2YWw6IG51bWJlciB8IG51bGwgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZlOiB0aGlzLmlzTW9uaXRvcmluZyxcbiAgICAgIGludGVydmFsOiB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA/IDMwMDAwIDogbnVsbFxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgaGVhbHRoTW9uaXRvcmluZyA9IG5ldyBIZWFsdGhNb25pdG9yaW5nU2VydmljZSgpXG5cbi8vIEV4cG9ydCB0eXBlc1xuZXhwb3J0IHR5cGUge1xuICBIZWFsdGhDaGVja0NvbmZpZyxcbiAgSGVhbHRoQ2hlY2tSZXN1bHQsXG4gIEhlYWx0aEluZGV4TWV0cmljcyxcbiAgSGVhbHRoU3VtbWFyeSxcbiAgSGVhbHRoUmVzdWx0XG59XG4iXSwibmFtZXMiOlsiY29ycmVsYXRpb25JRE1hbmFnZXIiLCJnZXRDb3JyZWxhdGlvbkhlYWRlcnMiLCJERUZBVUxUX0hFQUxUSF9DSEVDS1MiLCJuYW1lIiwiZW5kcG9pbnQiLCJ0aW1lb3V0IiwiY3JpdGljYWwiLCJyZXRyaWVzIiwiZXhwZWN0ZWRTdGF0dXMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfSEVBTFRIX0FQSV9VUkwiLCJIZWFsdGhNb25pdG9yaW5nU2VydmljZSIsInJ1bkhlYWx0aENoZWNrIiwiY29uZmlnIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5vdyIsImNvcnJlbGF0aW9uSWQiLCJnZXRDdXJyZW50Q29udGV4dCIsInJlc3VsdCIsInJ1bkludGVybmFsSGVhbHRoQ2hlY2siLCJydW5FeHRlcm5hbEhlYWx0aENoZWNrIiwiZXJyb3IiLCJyZXNwb25zZVRpbWUiLCJzdGF0dXMiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInN5c3RlbUluZm8iLCJnZXRTeXN0ZW1JbmZvIiwiZGV0YWlscyIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJoZWFkZXJzIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiLCJzdGF0dXNUZXh0IiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJNYXRoIiwicG93IiwicGxhdGZvcm0iLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsImNvb2tpZUVuYWJsZWQiLCJvbkxpbmUiLCJydW5Db21wcmVoZW5zaXZlSGVhbHRoQ2hlY2siLCJoZWFsdGhDaGVja0NvbnRleHQiLCJnZW5lcmF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJvcGVyYXRpb24iLCJ0eXBlIiwiY2hlY2tSZXN1bHRzIiwiY2hlY2tQcm9taXNlcyIsIm1hcCIsImFsbFNldHRsZWQiLCJzdW1tYXJ5IiwiY2FsY3VsYXRlSGVhbHRoU3VtbWFyeSIsImZhaWxlZENoZWNrcyIsIndhcm5pbmdDaGVja3MiLCJvdmVyYWxsSGVhbHRoIiwiY2hlY2tzIiwibWV0YWRhdGEiLCJzZXJ2aWNlIiwicmVnaW9uIiwiaW5zdGFuY2UiLCJidWlsZCIsImNvbW1pdCIsImhlYWx0aEhpc3RvcnkiLCJwdXNoIiwibGVuZ3RoIiwic2xpY2UiLCJ1cGRhdGVNZXRyaWNzIiwibG9nQ29udGV4dCIsImVycm9yUmVzdWx0IiwidG90YWxDaGVja3MiLCJwYXNzZWRDaGVja3MiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwiY2xlYXJDdXJyZW50Q29udGV4dCIsImNoZWNrQXJyYXkiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJjIiwicmVkdWNlIiwic3VtIiwicm91bmQiLCJoZWFsdGhSZXN1bHQiLCJtZXRyaWNzIiwib3ZlcmFsbFNjb3JlIiwiZXJyb3JSYXRlIiwidXB0aW1lIiwibGFzdENoZWNrIiwibWV0cmljc0hpc3RvcnkiLCJzdGFydE1vbml0b3JpbmciLCJpbnRlcnZhbE1zIiwiaXNNb25pdG9yaW5nIiwibW9uaXRvcmluZ0ludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjb25zb2xlIiwibG9nIiwic3RvcE1vbml0b3JpbmciLCJjbGVhckludGVydmFsIiwiZ2V0Q3VycmVudEhlYWx0aCIsImdldEhlYWx0aEhpc3RvcnkiLCJnZXRNZXRyaWNzSGlzdG9yeSIsImlzTW9uaXRvcmluZ0FjdGl2ZSIsImdldE1vbml0b3JpbmdTdGF0dXMiLCJpc0FjdGl2ZSIsImludGVydmFsIiwiaGVhbHRoTW9uaXRvcmluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/health-monitoring-simple.ts\n"));

/***/ })

});