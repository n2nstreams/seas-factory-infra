"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"831b6b248bff\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiODMxYjZiMjQ4YmZmXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/health-monitoring-simple.ts":
/*!*********************************************!*\
  !*** ./src/lib/health-monitoring-simple.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   healthMonitoring: () => (/* binding */ healthMonitoring)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Simple Health Monitoring System\n// This version provides basic health checks without external dependencies\n// Default health check configurations\nconst DEFAULT_HEALTH_CHECKS = [\n    {\n        name: 'system',\n        endpoint: 'internal',\n        timeout: 5000,\n        critical: false,\n        retries: 2\n    },\n    // Remove frontend self-check to avoid circular dependency\n    // The frontend health is determined by the overall API response\n    {\n        name: 'backend-api',\n        endpoint: process.env.NEXT_PUBLIC_HEALTH_API_URL || 'http://localhost:8000/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3,\n        method: 'GET'\n    }\n];\nclass SimpleHealthMonitoringService {\n    // Run comprehensive health check\n    async runHealthCheck() {\n        const startTime = Date.now();\n        const checks = {};\n        let totalChecks = 0;\n        let passedChecks = 0;\n        let failedChecks = 0;\n        let warningChecks = 0;\n        // Run all health checks in parallel\n        const checkPromises = DEFAULT_HEALTH_CHECKS.map(async (config)=>{\n            const checkStartTime = Date.now();\n            let retryCount = 0;\n            let lastError;\n            while(retryCount < config.retries){\n                try {\n                    const result = await this.performHealthCheck(config);\n                    const responseTime = Date.now() - checkStartTime;\n                    checks[config.name] = {\n                        ...result,\n                        responseTime\n                    };\n                    if (result.status === 'pass') {\n                        passedChecks++;\n                    } else if (result.status === 'warn') {\n                        warningChecks++;\n                    } else {\n                        failedChecks++;\n                    }\n                    break; // Success, no need to retry\n                } catch (error) {\n                    lastError = error instanceof Error ? error.message : String(error);\n                    retryCount++;\n                    if (retryCount >= config.retries) {\n                        checks[config.name] = {\n                            status: 'fail',\n                            error: lastError\n                        };\n                        failedChecks++;\n                    } else {\n                        // Wait before retry\n                        await new Promise((resolve)=>setTimeout(resolve, 1000 * retryCount));\n                    }\n                }\n            }\n        });\n        await Promise.all(checkPromises);\n        totalChecks = Object.keys(checks).length;\n        const overallHealth = totalChecks > 0 ? passedChecks / totalChecks * 100 : 0;\n        const healthResult = {\n            status: this.determineOverallStatus(overallHealth, failedChecks),\n            timestamp: new Date().toISOString(),\n            checks,\n            summary: {\n                totalChecks,\n                passedChecks,\n                failedChecks,\n                warningChecks,\n                overallHealth: Math.round(overallHealth)\n            }\n        };\n        // Store in history\n        this.healthHistory.push(healthResult);\n        if (this.healthHistory.length > 100) {\n            this.healthHistory = this.healthHistory.slice(-100);\n        }\n        // Calculate and store health index metrics\n        await this.calculateHealthIndexMetrics(healthResult);\n        console.log('Health check completed:', healthResult.summary);\n        return healthResult;\n    }\n    // Perform individual health check\n    async performHealthCheck(config) {\n        if (config.endpoint === 'internal') {\n            return this.performInternalHealthCheck(config);\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), config.timeout);\n        try {\n            const response = await fetch(config.endpoint, {\n                method: config.method || 'GET',\n                signal: controller.signal,\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            clearTimeout(timeoutId);\n            if (response.ok) {\n                const data = await response.json();\n                return {\n                    status: 'pass',\n                    details: data\n                };\n            } else if (response.status >= 500) {\n                return {\n                    status: 'fail',\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText\n                    }\n                };\n            } else {\n                return {\n                    status: 'warn',\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText\n                    }\n                };\n            }\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new Error(\"Health check timeout after \".concat(config.timeout, \"ms\"));\n            }\n            throw error;\n        }\n    }\n    // Perform internal health checks\n    async performInternalHealthCheck(config) {\n        try {\n            switch(config.name){\n                case 'system':\n                    // Basic system health check that doesn't require external services\n                    return {\n                        status: 'pass',\n                        details: {\n                            uptime: process.uptime(),\n                            memory: process.memoryUsage(),\n                            nodeVersion: process.version,\n                            platform: process.platform,\n                            timestamp: new Date().toISOString()\n                        }\n                    };\n                default:\n                    return {\n                        status: 'warn',\n                        details: {\n                            error: 'Unknown internal health check'\n                        }\n                    };\n            }\n        } catch (error) {\n            return {\n                status: 'warn',\n                details: {\n                    error: error instanceof Error ? error.message : String(error),\n                    message: 'Internal health check failed'\n                }\n            };\n        }\n    }\n    // Determine overall health status\n    determineOverallStatus(overallHealth, failedChecks) {\n        if (overallHealth >= 90 && failedChecks === 0) {\n            return 'healthy';\n        } else if (overallHealth >= 70 && failedChecks <= 1) {\n            return 'degraded';\n        } else {\n            return 'unhealthy';\n        }\n    }\n    // Calculate health index metrics\n    async calculateHealthIndexMetrics(healthResult) {\n        const now = new Date();\n        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n        // Get recent health checks for metrics calculation\n        const recentChecks = this.healthHistory.filter((check)=>new Date(check.timestamp) >= oneHourAgo);\n        if (recentChecks.length === 0) return;\n        // Calculate error rate\n        const totalChecks = recentChecks.reduce((sum, check)=>sum + check.summary.totalChecks, 0);\n        const totalFailures = recentChecks.reduce((sum, check)=>sum + check.summary.failedChecks, 0);\n        const errorRate = totalChecks > 0 ? totalFailures / totalChecks : 0;\n        // Calculate average response time\n        const responseTimes = recentChecks.flatMap((check)=>Object.values(check.checks).map((c)=>c.responseTime).filter((rt)=>rt !== undefined));\n        const avgResponseTime = responseTimes.length > 0 ? responseTimes.reduce((sum, rt)=>sum + rt, 0) / responseTimes.length : 0;\n        // Calculate uptime (simplified - just check if we have recent health checks)\n        const uptime = recentChecks.length > 0 ? 1.0 : 0.0;\n        // Create metrics entry\n        const metrics = {\n            timestamp: now.toISOString(),\n            errorRate: errorRate * 100,\n            responseTime: avgResponseTime,\n            uptime: uptime * 100,\n            jobFailures: 0,\n            authFailures: 0,\n            webhookFailures: 0,\n            overallScore: healthResult.summary.overallHealth\n        };\n        this.metricsHistory.push(metrics);\n        if (this.metricsHistory.length > 1000) {\n            this.metricsHistory = this.metricsHistory.slice(-1000);\n        }\n    }\n    // Get health history\n    getHealthHistory() {\n        return [\n            ...this.healthHistory\n        ];\n    }\n    // Get metrics history\n    getMetricsHistory() {\n        return [\n            ...this.metricsHistory\n        ];\n    }\n    // Start monitoring (placeholder for future implementation)\n    async startMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        console.log(\"Health monitoring started with \".concat(intervalMs, \"ms interval\"));\n    }\n    // Stop monitoring (placeholder for future implementation)\n    stopMonitoring() {\n        console.log('Health monitoring stopped');\n    }\n    constructor(){\n        this.healthHistory = [];\n        this.metricsHistory = [];\n    }\n}\n// Export singleton instance\nconst healthMonitoring = new SimpleHealthMonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaGVhbHRoLW1vbml0b3Jpbmctc2ltcGxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0NBQWtDO0FBQ2xDLDBFQUEwRTtBQTZDMUUsc0NBQXNDO0FBQ3RDLE1BQU1BLHdCQUE2QztJQUNqRDtRQUNFQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUNBLDBEQUEwRDtJQUMxRCxnRUFBZ0U7SUFDaEU7UUFDRUosTUFBTTtRQUNOQyxVQUFVSSxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLDBCQUEwQixJQUFJO1FBQ3BETCxTQUFTO1FBQ1RNLGdCQUFnQjtRQUNoQkwsVUFBVTtRQUNWQyxTQUFTO1FBQ1RLLFFBQVE7SUFDVjtDQUNEO0FBRUQsTUFBTUM7SUFJSixpQ0FBaUM7SUFDakMsTUFBTUMsaUJBQXdDO1FBQzVDLE1BQU1DLFlBQVlDLEtBQUtDLEdBQUc7UUFDMUIsTUFBTUMsU0FBK0MsQ0FBQztRQUN0RCxJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLGVBQWU7UUFDbkIsSUFBSUMsZUFBZTtRQUNuQixJQUFJQyxnQkFBZ0I7UUFFcEIsb0NBQW9DO1FBQ3BDLE1BQU1DLGdCQUFnQnJCLHNCQUFzQnNCLEdBQUcsQ0FBQyxPQUFPQztZQUNyRCxNQUFNQyxpQkFBaUJWLEtBQUtDLEdBQUc7WUFDL0IsSUFBSVUsYUFBYTtZQUNqQixJQUFJQztZQUVKLE1BQU9ELGFBQWFGLE9BQU9sQixPQUFPLENBQUU7Z0JBQ2xDLElBQUk7b0JBQ0YsTUFBTXNCLFNBQVMsTUFBTSxJQUFJLENBQUNDLGtCQUFrQixDQUFDTDtvQkFDN0MsTUFBTU0sZUFBZWYsS0FBS0MsR0FBRyxLQUFLUztvQkFFbENSLE1BQU0sQ0FBQ08sT0FBT3RCLElBQUksQ0FBQyxHQUFHO3dCQUNwQixHQUFHMEIsTUFBTTt3QkFDVEU7b0JBQ0Y7b0JBRUEsSUFBSUYsT0FBT0csTUFBTSxLQUFLLFFBQVE7d0JB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QyxjQUFjdEQsYUFBYUksT0FBTyxDQUFDTCxhQUFhO1FBQ2xEO1FBRUEsSUFBSSxDQUFDd0QsY0FBYyxDQUFDL0MsSUFBSSxDQUFDMEM7UUFDekIsSUFBSSxJQUFJLENBQUNLLGNBQWMsQ0FBQ3pELE1BQU0sR0FBRyxNQUFNO1lBQ3JDLElBQUksQ0FBQ3lELGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWMsQ0FBQzlDLEtBQUssQ0FBQyxDQUFDO1FBQ25EO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckIrQyxtQkFBbUM7UUFDakMsT0FBTztlQUFJLElBQUksQ0FBQ2pELGFBQWE7U0FBQztJQUNoQztJQUVBLHNCQUFzQjtJQUN0QmtELG9CQUEwQztRQUN4QyxPQUFPO2VBQUksSUFBSSxDQUFDRixjQUFjO1NBQUM7SUFDakM7SUFFQSwyREFBMkQ7SUFDM0QsTUFBTUcsa0JBQTJEO1lBQTNDQyxhQUFBQSxpRUFBcUI7UUFDekNoRCxRQUFRQyxHQUFHLENBQUMsa0NBQTZDLE9BQVgrQyxZQUFXO0lBQzNEO0lBRUEsMERBQTBEO0lBQzFEQyxpQkFBdUI7UUFDckJqRCxRQUFRQyxHQUFHLENBQUM7SUFDZDs7YUFyUFFMLGdCQUFnQyxFQUFFO2FBQ2xDZ0QsaUJBQXVDLEVBQUU7O0FBcVBuRDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNTSxtQkFBbUIsSUFBSTdGLGdDQUErQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2xpYi9oZWFsdGgtbW9uaXRvcmluZy1zaW1wbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2ltcGxlIEhlYWx0aCBNb25pdG9yaW5nIFN5c3RlbVxuLy8gVGhpcyB2ZXJzaW9uIHByb3ZpZGVzIGJhc2ljIGhlYWx0aCBjaGVja3Mgd2l0aG91dCBleHRlcm5hbCBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja0NvbmZpZyB7XG4gIG5hbWU6IHN0cmluZ1xuICBlbmRwb2ludDogc3RyaW5nXG4gIHRpbWVvdXQ6IG51bWJlclxuICBleHBlY3RlZFN0YXR1cz86IG51bWJlclxuICBjcml0aWNhbDogYm9vbGVhblxuICByZXRyaWVzOiBudW1iZXJcbiAgbWV0aG9kPzogJ0dFVCcgfCAnSEVBRCcgLy8gQWRkZWQgbWV0aG9kIGZvciBiYWNrZW5kIGNoZWNrc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aENoZWNrUmVzdWx0IHtcbiAgc3RhdHVzOiAncGFzcycgfCAnZmFpbCcgfCAnd2FybidcbiAgcmVzcG9uc2VUaW1lPzogbnVtYmVyXG4gIGVycm9yPzogc3RyaW5nXG4gIGRldGFpbHM/OiBhbnlcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhJbmRleE1ldHJpY3Mge1xuICB0aW1lc3RhbXA6IHN0cmluZ1xuICBlcnJvclJhdGU6IG51bWJlclxuICByZXNwb25zZVRpbWU6IG51bWJlclxuICB1cHRpbWU6IG51bWJlclxuICBqb2JGYWlsdXJlczogbnVtYmVyXG4gIGF1dGhGYWlsdXJlczogbnVtYmVyXG4gIHdlYmhvb2tGYWlsdXJlczogbnVtYmVyXG4gIG92ZXJhbGxTY29yZTogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoU3VtbWFyeSB7XG4gIHRvdGFsQ2hlY2tzOiBudW1iZXJcbiAgcGFzc2VkQ2hlY2tzOiBudW1iZXJcbiAgZmFpbGVkQ2hlY2tzOiBudW1iZXJcbiAgd2FybmluZ0NoZWNrczogbnVtYmVyXG4gIG92ZXJhbGxIZWFsdGg6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aFJlc3VsdCB7XG4gIHN0YXR1czogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknXG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIGNoZWNrczogeyBba2V5OiBzdHJpbmddOiBIZWFsdGhDaGVja1Jlc3VsdCB9XG4gIHN1bW1hcnk6IEhlYWx0aFN1bW1hcnlcbn1cblxuLy8gRGVmYXVsdCBoZWFsdGggY2hlY2sgY29uZmlndXJhdGlvbnNcbmNvbnN0IERFRkFVTFRfSEVBTFRIX0NIRUNLUzogSGVhbHRoQ2hlY2tDb25maWdbXSA9IFtcbiAge1xuICAgIG5hbWU6ICdzeXN0ZW0nLFxuICAgIGVuZHBvaW50OiAnaW50ZXJuYWwnLCAvLyBTcGVjaWFsIGNhc2UgZm9yIHN5c3RlbSBjaGVja3NcbiAgICB0aW1lb3V0OiA1MDAwLFxuICAgIGNyaXRpY2FsOiBmYWxzZSxcbiAgICByZXRyaWVzOiAyLFxuICB9LFxuICAvLyBSZW1vdmUgZnJvbnRlbmQgc2VsZi1jaGVjayB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gIC8vIFRoZSBmcm9udGVuZCBoZWFsdGggaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3ZlcmFsbCBBUEkgcmVzcG9uc2VcbiAge1xuICAgIG5hbWU6ICdiYWNrZW5kLWFwaScsXG4gICAgZW5kcG9pbnQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0hFQUxUSF9BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAvaGVhbHRoJyxcbiAgICB0aW1lb3V0OiA1MDAwLFxuICAgIGV4cGVjdGVkU3RhdHVzOiAyMDAsXG4gICAgY3JpdGljYWw6IHRydWUsXG4gICAgcmV0cmllczogMyxcbiAgICBtZXRob2Q6ICdHRVQnLCAvLyBVc2UgR0VUIGluc3RlYWQgb2YgSEVBRCBmb3IgYmFja2VuZFxuICB9LFxuXVxuXG5jbGFzcyBTaW1wbGVIZWFsdGhNb25pdG9yaW5nU2VydmljZSB7XG4gIHByaXZhdGUgaGVhbHRoSGlzdG9yeTogSGVhbHRoUmVzdWx0W10gPSBbXVxuICBwcml2YXRlIG1ldHJpY3NIaXN0b3J5OiBIZWFsdGhJbmRleE1ldHJpY3NbXSA9IFtdXG5cbiAgLy8gUnVuIGNvbXByZWhlbnNpdmUgaGVhbHRoIGNoZWNrXG4gIGFzeW5jIHJ1bkhlYWx0aENoZWNrKCk6IFByb21pc2U8SGVhbHRoUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IGNoZWNrczogeyBba2V5OiBzdHJpbmddOiBIZWFsdGhDaGVja1Jlc3VsdCB9ID0ge31cbiAgICBsZXQgdG90YWxDaGVja3MgPSAwXG4gICAgbGV0IHBhc3NlZENoZWNrcyA9IDBcbiAgICBsZXQgZmFpbGVkQ2hlY2tzID0gMFxuICAgIGxldCB3YXJuaW5nQ2hlY2tzID0gMFxuXG4gICAgLy8gUnVuIGFsbCBoZWFsdGggY2hlY2tzIGluIHBhcmFsbGVsXG4gICAgY29uc3QgY2hlY2tQcm9taXNlcyA9IERFRkFVTFRfSEVBTFRIX0NIRUNLUy5tYXAoYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgICAgY29uc3QgY2hlY2tTdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgICBsZXQgcmV0cnlDb3VudCA9IDBcbiAgICAgIGxldCBsYXN0RXJyb3I6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICB3aGlsZSAocmV0cnlDb3VudCA8IGNvbmZpZy5yZXRyaWVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wZXJmb3JtSGVhbHRoQ2hlY2soY29uZmlnKVxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBjaGVja1N0YXJ0VGltZVxuICAgICAgICAgIFxuICAgICAgICAgIGNoZWNrc1tjb25maWcubmFtZV0gPSB7XG4gICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICByZXNwb25zZVRpbWUsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdwYXNzJykge1xuICAgICAgICAgICAgcGFzc2VkQ2hlY2tzKytcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICd3YXJuJykge1xuICAgICAgICAgICAgd2FybmluZ0NoZWNrcysrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhaWxlZENoZWNrcysrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWsgLy8gU3VjY2Vzcywgbm8gbmVlZCB0byByZXRyeVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgIHJldHJ5Q291bnQrK1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChyZXRyeUNvdW50ID49IGNvbmZpZy5yZXRyaWVzKSB7XG4gICAgICAgICAgICBjaGVja3NbY29uZmlnLm5hbWVdID0ge1xuICAgICAgICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgICAgICAgZXJyb3I6IGxhc3RFcnJvcixcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhaWxlZENoZWNrcysrXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCAqIHJldHJ5Q291bnQpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChjaGVja1Byb21pc2VzKVxuXG4gICAgdG90YWxDaGVja3MgPSBPYmplY3Qua2V5cyhjaGVja3MpLmxlbmd0aFxuICAgIGNvbnN0IG92ZXJhbGxIZWFsdGggPSB0b3RhbENoZWNrcyA+IDAgPyAocGFzc2VkQ2hlY2tzIC8gdG90YWxDaGVja3MpICogMTAwIDogMFxuXG4gICAgY29uc3QgaGVhbHRoUmVzdWx0OiBIZWFsdGhSZXN1bHQgPSB7XG4gICAgICBzdGF0dXM6IHRoaXMuZGV0ZXJtaW5lT3ZlcmFsbFN0YXR1cyhvdmVyYWxsSGVhbHRoLCBmYWlsZWRDaGVja3MpLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBjaGVja3MsXG4gICAgICBzdW1tYXJ5OiB7XG4gICAgICAgIHRvdGFsQ2hlY2tzLFxuICAgICAgICBwYXNzZWRDaGVja3MsXG4gICAgICAgIGZhaWxlZENoZWNrcyxcbiAgICAgICAgd2FybmluZ0NoZWNrcyxcbiAgICAgICAgb3ZlcmFsbEhlYWx0aDogTWF0aC5yb3VuZChvdmVyYWxsSGVhbHRoKSxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgLy8gU3RvcmUgaW4gaGlzdG9yeVxuICAgIHRoaXMuaGVhbHRoSGlzdG9yeS5wdXNoKGhlYWx0aFJlc3VsdClcbiAgICBpZiAodGhpcy5oZWFsdGhIaXN0b3J5Lmxlbmd0aCA+IDEwMCkge1xuICAgICAgdGhpcy5oZWFsdGhIaXN0b3J5ID0gdGhpcy5oZWFsdGhIaXN0b3J5LnNsaWNlKC0xMDApXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGFuZCBzdG9yZSBoZWFsdGggaW5kZXggbWV0cmljc1xuICAgIGF3YWl0IHRoaXMuY2FsY3VsYXRlSGVhbHRoSW5kZXhNZXRyaWNzKGhlYWx0aFJlc3VsdClcblxuICAgIGNvbnNvbGUubG9nKCdIZWFsdGggY2hlY2sgY29tcGxldGVkOicsIGhlYWx0aFJlc3VsdC5zdW1tYXJ5KVxuICAgIHJldHVybiBoZWFsdGhSZXN1bHRcbiAgfVxuXG4gIC8vIFBlcmZvcm0gaW5kaXZpZHVhbCBoZWFsdGggY2hlY2tcbiAgcHJpdmF0ZSBhc3luYyBwZXJmb3JtSGVhbHRoQ2hlY2soY29uZmlnOiBIZWFsdGhDaGVja0NvbmZpZyk6IFByb21pc2U8SGVhbHRoQ2hlY2tSZXN1bHQ+IHtcbiAgICBpZiAoY29uZmlnLmVuZHBvaW50ID09PSAnaW50ZXJuYWwnKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZXJmb3JtSW50ZXJuYWxIZWFsdGhDaGVjayhjb25maWcpXG4gICAgfVxuXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBjb25maWcudGltZW91dClcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGNvbmZpZy5lbmRwb2ludCwge1xuICAgICAgICBtZXRob2Q6IGNvbmZpZy5tZXRob2QgfHwgJ0dFVCcsIC8vIFVzZSBtZXRob2QgZnJvbSBjb25maWcgb3IgZGVmYXVsdCB0byBHRVRcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuXG4gICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogJ3Bhc3MnLFxuICAgICAgICAgIGRldGFpbHM6IGRhdGEsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogJ2ZhaWwnLFxuICAgICAgICAgIGRldGFpbHM6IHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQgfSxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6ICd3YXJuJyxcbiAgICAgICAgICBkZXRhaWxzOiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0IH0sXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgIFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSGVhbHRoIGNoZWNrIHRpbWVvdXQgYWZ0ZXIgJHtjb25maWcudGltZW91dH1tc2ApXG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICB9XG5cbiAgLy8gUGVyZm9ybSBpbnRlcm5hbCBoZWFsdGggY2hlY2tzXG4gIHByaXZhdGUgYXN5bmMgcGVyZm9ybUludGVybmFsSGVhbHRoQ2hlY2soY29uZmlnOiBIZWFsdGhDaGVja0NvbmZpZyk6IFByb21pc2U8SGVhbHRoQ2hlY2tSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWcubmFtZSkge1xuICAgICAgICBjYXNlICdzeXN0ZW0nOlxuICAgICAgICAgIC8vIEJhc2ljIHN5c3RlbSBoZWFsdGggY2hlY2sgdGhhdCBkb2Vzbid0IHJlcXVpcmUgZXh0ZXJuYWwgc2VydmljZXNcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiAncGFzcycsXG4gICAgICAgICAgICBkZXRhaWxzOiB7IFxuICAgICAgICAgICAgICB1cHRpbWU6IHByb2Nlc3MudXB0aW1lKCksXG4gICAgICAgICAgICAgIG1lbW9yeTogcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLFxuICAgICAgICAgICAgICBub2RlVmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9uLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogJ3dhcm4nLFxuICAgICAgICAgICAgZGV0YWlsczogeyBlcnJvcjogJ1Vua25vd24gaW50ZXJuYWwgaGVhbHRoIGNoZWNrJyB9LFxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiAnd2FybicsXG4gICAgICAgIGRldGFpbHM6IHsgXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgaGVhbHRoIGNoZWNrIGZhaWxlZCdcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBEZXRlcm1pbmUgb3ZlcmFsbCBoZWFsdGggc3RhdHVzXG4gIHByaXZhdGUgZGV0ZXJtaW5lT3ZlcmFsbFN0YXR1cyhvdmVyYWxsSGVhbHRoOiBudW1iZXIsIGZhaWxlZENoZWNrczogbnVtYmVyKTogJ2hlYWx0aHknIHwgJ2RlZ3JhZGVkJyB8ICd1bmhlYWx0aHknIHtcbiAgICBpZiAob3ZlcmFsbEhlYWx0aCA+PSA5MCAmJiBmYWlsZWRDaGVja3MgPT09IDApIHtcbiAgICAgIHJldHVybiAnaGVhbHRoeSdcbiAgICB9IGVsc2UgaWYgKG92ZXJhbGxIZWFsdGggPj0gNzAgJiYgZmFpbGVkQ2hlY2tzIDw9IDEpIHtcbiAgICAgIHJldHVybiAnZGVncmFkZWQnXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAndW5oZWFsdGh5J1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBoZWFsdGggaW5kZXggbWV0cmljc1xuICBwcml2YXRlIGFzeW5jIGNhbGN1bGF0ZUhlYWx0aEluZGV4TWV0cmljcyhoZWFsdGhSZXN1bHQ6IEhlYWx0aFJlc3VsdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKClcbiAgICBjb25zdCBvbmVIb3VyQWdvID0gbmV3IERhdGUobm93LmdldFRpbWUoKSAtIDYwICogNjAgKiAxMDAwKVxuICAgIFxuICAgIC8vIEdldCByZWNlbnQgaGVhbHRoIGNoZWNrcyBmb3IgbWV0cmljcyBjYWxjdWxhdGlvblxuICAgIGNvbnN0IHJlY2VudENoZWNrcyA9IHRoaXMuaGVhbHRoSGlzdG9yeS5maWx0ZXIoXG4gICAgICBjaGVjayA9PiBuZXcgRGF0ZShjaGVjay50aW1lc3RhbXApID49IG9uZUhvdXJBZ29cbiAgICApXG5cbiAgICBpZiAocmVjZW50Q2hlY2tzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgICAvLyBDYWxjdWxhdGUgZXJyb3IgcmF0ZVxuICAgIGNvbnN0IHRvdGFsQ2hlY2tzID0gcmVjZW50Q2hlY2tzLnJlZHVjZSgoc3VtLCBjaGVjaykgPT4gc3VtICsgY2hlY2suc3VtbWFyeS50b3RhbENoZWNrcywgMClcbiAgICBjb25zdCB0b3RhbEZhaWx1cmVzID0gcmVjZW50Q2hlY2tzLnJlZHVjZSgoc3VtLCBjaGVjaykgPT4gc3VtICsgY2hlY2suc3VtbWFyeS5mYWlsZWRDaGVja3MsIDApXG4gICAgY29uc3QgZXJyb3JSYXRlID0gdG90YWxDaGVja3MgPiAwID8gdG90YWxGYWlsdXJlcyAvIHRvdGFsQ2hlY2tzIDogMFxuXG4gICAgLy8gQ2FsY3VsYXRlIGF2ZXJhZ2UgcmVzcG9uc2UgdGltZVxuICAgIGNvbnN0IHJlc3BvbnNlVGltZXMgPSByZWNlbnRDaGVja3MuZmxhdE1hcChjaGVjayA9PiBcbiAgICAgIE9iamVjdC52YWx1ZXMoY2hlY2suY2hlY2tzKVxuICAgICAgICAubWFwKGMgPT4gYy5yZXNwb25zZVRpbWUpXG4gICAgICAgIC5maWx0ZXIoKHJ0KTogcnQgaXMgbnVtYmVyID0+IHJ0ICE9PSB1bmRlZmluZWQpXG4gICAgKVxuICAgIGNvbnN0IGF2Z1Jlc3BvbnNlVGltZSA9IHJlc3BvbnNlVGltZXMubGVuZ3RoID4gMCBcbiAgICAgID8gcmVzcG9uc2VUaW1lcy5yZWR1Y2UoKHN1bSwgcnQpID0+IHN1bSArIHJ0LCAwKSAvIHJlc3BvbnNlVGltZXMubGVuZ3RoIFxuICAgICAgOiAwXG5cbiAgICAvLyBDYWxjdWxhdGUgdXB0aW1lIChzaW1wbGlmaWVkIC0ganVzdCBjaGVjayBpZiB3ZSBoYXZlIHJlY2VudCBoZWFsdGggY2hlY2tzKVxuICAgIGNvbnN0IHVwdGltZSA9IHJlY2VudENoZWNrcy5sZW5ndGggPiAwID8gMS4wIDogMC4wXG5cbiAgICAvLyBDcmVhdGUgbWV0cmljcyBlbnRyeVxuICAgIGNvbnN0IG1ldHJpY3M6IEhlYWx0aEluZGV4TWV0cmljcyA9IHtcbiAgICAgIHRpbWVzdGFtcDogbm93LnRvSVNPU3RyaW5nKCksXG4gICAgICBlcnJvclJhdGU6IGVycm9yUmF0ZSAqIDEwMCwgLy8gQ29udmVydCB0byBwZXJjZW50YWdlXG4gICAgICByZXNwb25zZVRpbWU6IGF2Z1Jlc3BvbnNlVGltZSxcbiAgICAgIHVwdGltZTogdXB0aW1lICogMTAwLCAvLyBDb252ZXJ0IHRvIHBlcmNlbnRhZ2VcbiAgICAgIGpvYkZhaWx1cmVzOiAwLCAvLyBQbGFjZWhvbGRlclxuICAgICAgYXV0aEZhaWx1cmVzOiAwLCAvLyBQbGFjZWhvbGRlclxuICAgICAgd2ViaG9va0ZhaWx1cmVzOiAwLCAvLyBQbGFjZWhvbGRlclxuICAgICAgb3ZlcmFsbFNjb3JlOiBoZWFsdGhSZXN1bHQuc3VtbWFyeS5vdmVyYWxsSGVhbHRoLFxuICAgIH1cblxuICAgIHRoaXMubWV0cmljc0hpc3RvcnkucHVzaChtZXRyaWNzKVxuICAgIGlmICh0aGlzLm1ldHJpY3NIaXN0b3J5Lmxlbmd0aCA+IDEwMDApIHtcbiAgICAgIHRoaXMubWV0cmljc0hpc3RvcnkgPSB0aGlzLm1ldHJpY3NIaXN0b3J5LnNsaWNlKC0xMDAwKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBoZWFsdGggaGlzdG9yeVxuICBnZXRIZWFsdGhIaXN0b3J5KCk6IEhlYWx0aFJlc3VsdFtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuaGVhbHRoSGlzdG9yeV1cbiAgfVxuXG4gIC8vIEdldCBtZXRyaWNzIGhpc3RvcnlcbiAgZ2V0TWV0cmljc0hpc3RvcnkoKTogSGVhbHRoSW5kZXhNZXRyaWNzW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5tZXRyaWNzSGlzdG9yeV1cbiAgfVxuXG4gIC8vIFN0YXJ0IG1vbml0b3JpbmcgKHBsYWNlaG9sZGVyIGZvciBmdXR1cmUgaW1wbGVtZW50YXRpb24pXG4gIGFzeW5jIHN0YXJ0TW9uaXRvcmluZyhpbnRlcnZhbE1zOiBudW1iZXIgPSAzMDAwMCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKGBIZWFsdGggbW9uaXRvcmluZyBzdGFydGVkIHdpdGggJHtpbnRlcnZhbE1zfW1zIGludGVydmFsYClcbiAgfVxuXG4gIC8vIFN0b3AgbW9uaXRvcmluZyAocGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBpbXBsZW1lbnRhdGlvbilcbiAgc3RvcE1vbml0b3JpbmcoKTogdm9pZCB7XG4gICAgY29uc29sZS5sb2coJ0hlYWx0aCBtb25pdG9yaW5nIHN0b3BwZWQnKVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBoZWFsdGhNb25pdG9yaW5nID0gbmV3IFNpbXBsZUhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlKClcblxuLy8gRXhwb3J0IHR5cGVzIGZvciBleHRlcm5hbCB1c2VcbmV4cG9ydCB0eXBlIHsgSGVhbHRoQ2hlY2tDb25maWcsIEhlYWx0aENoZWNrUmVzdWx0LCBIZWFsdGhJbmRleE1ldHJpY3MsIEhlYWx0aFN1bW1hcnksIEhlYWx0aFJlc3VsdCB9XG4iXSwibmFtZXMiOlsiREVGQVVMVF9IRUFMVEhfQ0hFQ0tTIiwibmFtZSIsImVuZHBvaW50IiwidGltZW91dCIsImNyaXRpY2FsIiwicmV0cmllcyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19IRUFMVEhfQVBJX1VSTCIsImV4cGVjdGVkU3RhdHVzIiwibWV0aG9kIiwiU2ltcGxlSGVhbHRoTW9uaXRvcmluZ1NlcnZpY2UiLCJydW5IZWFsdGhDaGVjayIsInN0YXJ0VGltZSIsIkRhdGUiLCJub3ciLCJjaGVja3MiLCJ0b3RhbENoZWNrcyIsInBhc3NlZENoZWNrcyIsImZhaWxlZENoZWNrcyIsIndhcm5pbmdDaGVja3MiLCJjaGVja1Byb21pc2VzIiwibWFwIiwiY29uZmlnIiwiY2hlY2tTdGFydFRpbWUiLCJyZXRyeUNvdW50IiwibGFzdEVycm9yIiwicmVzdWx0IiwicGVyZm9ybUhlYWx0aENoZWNrIiwicmVzcG9uc2VUaW1lIiwic3RhdHVzIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJhbGwiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwib3ZlcmFsbEhlYWx0aCIsImhlYWx0aFJlc3VsdCIsImRldGVybWluZU92ZXJhbGxTdGF0dXMiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInN1bW1hcnkiLCJNYXRoIiwicm91bmQiLCJoZWFsdGhIaXN0b3J5IiwicHVzaCIsInNsaWNlIiwiY2FsY3VsYXRlSGVhbHRoSW5kZXhNZXRyaWNzIiwiY29uc29sZSIsImxvZyIsInBlcmZvcm1JbnRlcm5hbEhlYWx0aENoZWNrIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsImhlYWRlcnMiLCJjbGVhclRpbWVvdXQiLCJvayIsImRhdGEiLCJqc29uIiwiZGV0YWlscyIsInN0YXR1c1RleHQiLCJ1cHRpbWUiLCJtZW1vcnkiLCJtZW1vcnlVc2FnZSIsIm5vZGVWZXJzaW9uIiwidmVyc2lvbiIsInBsYXRmb3JtIiwib25lSG91ckFnbyIsImdldFRpbWUiLCJyZWNlbnRDaGVja3MiLCJmaWx0ZXIiLCJjaGVjayIsInJlZHVjZSIsInN1bSIsInRvdGFsRmFpbHVyZXMiLCJlcnJvclJhdGUiLCJyZXNwb25zZVRpbWVzIiwiZmxhdE1hcCIsInZhbHVlcyIsImMiLCJydCIsInVuZGVmaW5lZCIsImF2Z1Jlc3BvbnNlVGltZSIsIm1ldHJpY3MiLCJqb2JGYWlsdXJlcyIsImF1dGhGYWlsdXJlcyIsIndlYmhvb2tGYWlsdXJlcyIsIm92ZXJhbGxTY29yZSIsIm1ldHJpY3NIaXN0b3J5IiwiZ2V0SGVhbHRoSGlzdG9yeSIsImdldE1ldHJpY3NIaXN0b3J5Iiwic3RhcnRNb25pdG9yaW5nIiwiaW50ZXJ2YWxNcyIsInN0b3BNb25pdG9yaW5nIiwiaGVhbHRoTW9uaXRvcmluZyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/health-monitoring-simple.ts\n"));

/***/ })

});