"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"38f8004e940d\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiMzhmODAwNGU5NDBkXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/health-monitoring-simple.ts":
/*!*********************************************!*\
  !*** ./src/lib/health-monitoring-simple.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   healthMonitoring: () => (/* binding */ healthMonitoring)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Simple Health Monitoring System\n// This version provides basic health checks without external dependencies\n// Default health check configurations\nconst DEFAULT_HEALTH_CHECKS = [\n    {\n        name: 'system',\n        endpoint: 'internal',\n        timeout: 5000,\n        critical: false,\n        retries: 2\n    },\n    {\n        name: 'frontend',\n        endpoint:  false ? 0 // Server-side: use full URL\n         : '/api/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3\n    },\n    {\n        name: 'backend-api',\n        endpoint: process.env.NEXT_PUBLIC_HEALTH_API_URL || 'http://localhost:8000/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3\n    }\n];\nclass SimpleHealthMonitoringService {\n    // Run comprehensive health check\n    async runHealthCheck() {\n        const startTime = Date.now();\n        const checks = {};\n        let totalChecks = 0;\n        let passedChecks = 0;\n        let failedChecks = 0;\n        let warningChecks = 0;\n        // Run all health checks in parallel\n        const checkPromises = DEFAULT_HEALTH_CHECKS.map(async (config)=>{\n            const checkStartTime = Date.now();\n            let retryCount = 0;\n            let lastError;\n            while(retryCount < config.retries){\n                try {\n                    const result = await this.performHealthCheck(config);\n                    const responseTime = Date.now() - checkStartTime;\n                    checks[config.name] = {\n                        ...result,\n                        responseTime\n                    };\n                    if (result.status === 'pass') {\n                        passedChecks++;\n                    } else if (result.status === 'warn') {\n                        warningChecks++;\n                    } else {\n                        failedChecks++;\n                    }\n                    break; // Success, no need to retry\n                } catch (error) {\n                    lastError = error instanceof Error ? error.message : String(error);\n                    retryCount++;\n                    if (retryCount >= config.retries) {\n                        checks[config.name] = {\n                            status: 'fail',\n                            error: lastError\n                        };\n                        failedChecks++;\n                    } else {\n                        // Wait before retry\n                        await new Promise((resolve)=>setTimeout(resolve, 1000 * retryCount));\n                    }\n                }\n            }\n        });\n        await Promise.all(checkPromises);\n        totalChecks = Object.keys(checks).length;\n        const overallHealth = totalChecks > 0 ? passedChecks / totalChecks * 100 : 0;\n        const healthResult = {\n            status: this.determineOverallStatus(overallHealth, failedChecks),\n            timestamp: new Date().toISOString(),\n            checks,\n            summary: {\n                totalChecks,\n                passedChecks,\n                failedChecks,\n                warningChecks,\n                overallHealth: Math.round(overallHealth)\n            }\n        };\n        // Store in history\n        this.healthHistory.push(healthResult);\n        if (this.healthHistory.length > 100) {\n            this.healthHistory = this.healthHistory.slice(-100);\n        }\n        // Calculate and store health index metrics\n        await this.calculateHealthIndexMetrics(healthResult);\n        console.log('Health check completed:', healthResult.summary);\n        return healthResult;\n    }\n    // Perform individual health check\n    async performHealthCheck(config) {\n        if (config.endpoint === 'internal') {\n            return this.performInternalHealthCheck(config);\n        }\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), config.timeout);\n        try {\n            const response = await fetch(config.endpoint, {\n                method: 'GET',\n                signal: controller.signal,\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            clearTimeout(timeoutId);\n            if (response.ok) {\n                const data = await response.json();\n                return {\n                    status: 'pass',\n                    details: data\n                };\n            } else if (response.status >= 500) {\n                return {\n                    status: 'fail',\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText\n                    }\n                };\n            } else {\n                return {\n                    status: 'warn',\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText\n                    }\n                };\n            }\n        } catch (error) {\n            clearTimeout(timeoutId);\n            if (error instanceof Error && error.name === 'AbortError') {\n                throw new Error(\"Health check timeout after \".concat(config.timeout, \"ms\"));\n            }\n            throw error;\n        }\n    }\n    // Perform internal health checks\n    async performInternalHealthCheck(config) {\n        try {\n            switch(config.name){\n                case 'system':\n                    // Basic system health check that doesn't require external services\n                    return {\n                        status: 'pass',\n                        details: {\n                            uptime: process.uptime(),\n                            memory: process.memoryUsage(),\n                            nodeVersion: process.version,\n                            platform: process.platform,\n                            timestamp: new Date().toISOString()\n                        }\n                    };\n                default:\n                    return {\n                        status: 'warn',\n                        details: {\n                            error: 'Unknown internal health check'\n                        }\n                    };\n            }\n        } catch (error) {\n            return {\n                status: 'warn',\n                details: {\n                    error: error instanceof Error ? error.message : String(error),\n                    message: 'Internal health check failed'\n                }\n            };\n        }\n    }\n    // Determine overall health status\n    determineOverallStatus(overallHealth, failedChecks) {\n        if (overallHealth >= 90 && failedChecks === 0) {\n            return 'healthy';\n        } else if (overallHealth >= 70 && failedChecks <= 1) {\n            return 'degraded';\n        } else {\n            return 'unhealthy';\n        }\n    }\n    // Calculate health index metrics\n    async calculateHealthIndexMetrics(healthResult) {\n        const now = new Date();\n        const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1000);\n        // Get recent health checks for metrics calculation\n        const recentChecks = this.healthHistory.filter((check)=>new Date(check.timestamp) >= oneHourAgo);\n        if (recentChecks.length === 0) return;\n        // Calculate error rate\n        const totalChecks = recentChecks.reduce((sum, check)=>sum + check.summary.totalChecks, 0);\n        const totalFailures = recentChecks.reduce((sum, check)=>sum + check.summary.failedChecks, 0);\n        const errorRate = totalChecks > 0 ? totalFailures / totalChecks : 0;\n        // Calculate average response time\n        const responseTimes = recentChecks.flatMap((check)=>Object.values(check.checks).map((c)=>c.responseTime).filter((rt)=>rt !== undefined));\n        const avgResponseTime = responseTimes.length > 0 ? responseTimes.reduce((sum, rt)=>sum + rt, 0) / responseTimes.length : 0;\n        // Calculate uptime (simplified - just check if we have recent health checks)\n        const uptime = recentChecks.length > 0 ? 1.0 : 0.0;\n        // Create metrics entry\n        const metrics = {\n            timestamp: now.toISOString(),\n            errorRate: errorRate * 100,\n            responseTime: avgResponseTime,\n            uptime: uptime * 100,\n            jobFailures: 0,\n            authFailures: 0,\n            webhookFailures: 0,\n            overallScore: healthResult.summary.overallHealth\n        };\n        this.metricsHistory.push(metrics);\n        if (this.metricsHistory.length > 1000) {\n            this.metricsHistory = this.metricsHistory.slice(-1000);\n        }\n    }\n    // Get health history\n    getHealthHistory() {\n        return [\n            ...this.healthHistory\n        ];\n    }\n    // Get metrics history\n    getMetricsHistory() {\n        return [\n            ...this.metricsHistory\n        ];\n    }\n    // Start monitoring (placeholder for future implementation)\n    async startMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        console.log(\"Health monitoring started with \".concat(intervalMs, \"ms interval\"));\n    }\n    // Stop monitoring (placeholder for future implementation)\n    stopMonitoring() {\n        console.log('Health monitoring stopped');\n    }\n    constructor(){\n        this.healthHistory = [];\n        this.metricsHistory = [];\n    }\n}\n// Export singleton instance\nconst healthMonitoring = new SimpleHealthMonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaGVhbHRoLW1vbml0b3Jpbmctc2ltcGxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsa0NBQWtDO0FBQ2xDLDBFQUEwRTtBQTRDMUUsc0NBQXNDO0FBQ3RDLE1BQU1BLHdCQUE2QztJQUNqRDtRQUNFQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUNBO1FBQ0VKLE1BQU07UUFDTkMsVUFBVSxNQUE2QixHQUNuQyxDQUFrQyxDQUFFLDRCQUE0QjtXQUNoRTtRQUNKQyxTQUFTO1FBQ1RHLGdCQUFnQjtRQUNoQkYsVUFBVTtRQUNWQyxTQUFTO0lBQ1g7SUFDQTtRQUNFSixNQUFNO1FBQ05DLFVBQVVLLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsMEJBQTBCLElBQUk7UUFDcEROLFNBQVM7UUFDVEcsZ0JBQWdCO1FBQ2hCRixVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtDQUNEO0FBRUQsTUFBTUs7SUFJSixpQ0FBaUM7SUFDakMsTUFBTUMsaUJBQXdDO1FBQzVDLE1BQU1DLFlBQVlDLEtBQUtDLEdBQUc7UUFDMUIsTUFBTUMsU0FBK0MsQ0FBQztRQUN0RCxJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLGVBQWU7UUFDbkIsSUFBSUMsZUFBZTtRQUNuQixJQUFJQyxnQkFBZ0I7UUFFcEIsb0NBQW9DO1FBQ3BDLE1BQU1DLGdCQUFnQnBCLHNCQUFzQnFCLEdBQUcsQ0FBQyxPQUFPQztZQUNyRCxNQUFNQyxpQkFBaUJWLEtBQUtDLEdBQUc7WUFDL0IsSUFBSVUsYUFBYTtZQUNqQixJQUFJQztZQUVKLE1BQU9ELGFBQWFGLE9BQU9qQixPQUFPLENBQUU7Z0JBQ2xDLElBQUk7b0JBQ0YsTUFBTXFCLFNBQVMsTUFBTSxJQUFJLENBQUNDLGtCQUFrQixDQUFDTDtvQkFDN0MsTUFBTU0sZUFBZWYsS0FBS0MsR0FBRyxLQUFLUztvQkFFbENSLE1BQU0sQ0FBQ08sT0FBT3JCLElBQUks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WUFDZHJCLFFBQVFBLFNBQVM7WUFDakJ1QixhQUFhO1lBQ2JDLGNBQWM7WUFDZEMsaUJBQWlCO1lBQ2pCQyxjQUFjdkQsYUFBYUksT0FBTyxDQUFDTCxhQUFhO1FBQ2xEO1FBRUEsSUFBSSxDQUFDeUQsY0FBYyxDQUFDaEQsSUFBSSxDQUFDMkM7UUFDekIsSUFBSSxJQUFJLENBQUNLLGNBQWMsQ0FBQzFELE1BQU0sR0FBRyxNQUFNO1lBQ3JDLElBQUksQ0FBQzBELGNBQWMsR0FBRyxJQUFJLENBQUNBLGNBQWMsQ0FBQy9DLEtBQUssQ0FBQyxDQUFDO1FBQ25EO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckJnRCxtQkFBbUM7UUFDakMsT0FBTztlQUFJLElBQUksQ0FBQ2xELGFBQWE7U0FBQztJQUNoQztJQUVBLHNCQUFzQjtJQUN0Qm1ELG9CQUEwQztRQUN4QyxPQUFPO2VBQUksSUFBSSxDQUFDRixjQUFjO1NBQUM7SUFDakM7SUFFQSwyREFBMkQ7SUFDM0QsTUFBTUcsa0JBQTJEO1lBQTNDQyxhQUFBQSxpRUFBcUI7UUFDekNqRCxRQUFRQyxHQUFHLENBQUMsa0NBQTZDLE9BQVhnRCxZQUFXO0lBQzNEO0lBRUEsMERBQTBEO0lBQzFEQyxpQkFBdUI7UUFDckJsRCxRQUFRQyxHQUFHLENBQUM7SUFDZDs7YUFyUFFMLGdCQUFnQyxFQUFFO2FBQ2xDaUQsaUJBQXVDLEVBQUU7O0FBcVBuRDtBQUVBLDRCQUE0QjtBQUNyQixNQUFNTSxtQkFBbUIsSUFBSTlGLGdDQUErQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL1NhYVMgRmFjdG9yeS91aS9uZXh0anMvc3JjL2xpYi9oZWFsdGgtbW9uaXRvcmluZy1zaW1wbGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2ltcGxlIEhlYWx0aCBNb25pdG9yaW5nIFN5c3RlbVxuLy8gVGhpcyB2ZXJzaW9uIHByb3ZpZGVzIGJhc2ljIGhlYWx0aCBjaGVja3Mgd2l0aG91dCBleHRlcm5hbCBkZXBlbmRlbmNpZXNcblxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja0NvbmZpZyB7XG4gIG5hbWU6IHN0cmluZ1xuICBlbmRwb2ludDogc3RyaW5nXG4gIHRpbWVvdXQ6IG51bWJlclxuICBleHBlY3RlZFN0YXR1cz86IG51bWJlclxuICBjcml0aWNhbDogYm9vbGVhblxuICByZXRyaWVzOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhDaGVja1Jlc3VsdCB7XG4gIHN0YXR1czogJ3Bhc3MnIHwgJ2ZhaWwnIHwgJ3dhcm4nXG4gIHJlc3BvbnNlVGltZT86IG51bWJlclxuICBlcnJvcj86IHN0cmluZ1xuICBkZXRhaWxzPzogYW55XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoSW5kZXhNZXRyaWNzIHtcbiAgdGltZXN0YW1wOiBzdHJpbmdcbiAgZXJyb3JSYXRlOiBudW1iZXJcbiAgcmVzcG9uc2VUaW1lOiBudW1iZXJcbiAgdXB0aW1lOiBudW1iZXJcbiAgam9iRmFpbHVyZXM6IG51bWJlclxuICBhdXRoRmFpbHVyZXM6IG51bWJlclxuICB3ZWJob29rRmFpbHVyZXM6IG51bWJlclxuICBvdmVyYWxsU2NvcmU6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aFN1bW1hcnkge1xuICB0b3RhbENoZWNrczogbnVtYmVyXG4gIHBhc3NlZENoZWNrczogbnVtYmVyXG4gIGZhaWxlZENoZWNrczogbnVtYmVyXG4gIHdhcm5pbmdDaGVja3M6IG51bWJlclxuICBvdmVyYWxsSGVhbHRoOiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhSZXN1bHQge1xuICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5J1xuICB0aW1lc3RhbXA6IHN0cmluZ1xuICBjaGVja3M6IHsgW2tleTogc3RyaW5nXTogSGVhbHRoQ2hlY2tSZXN1bHQgfVxuICBzdW1tYXJ5OiBIZWFsdGhTdW1tYXJ5XG59XG5cbi8vIERlZmF1bHQgaGVhbHRoIGNoZWNrIGNvbmZpZ3VyYXRpb25zXG5jb25zdCBERUZBVUxUX0hFQUxUSF9DSEVDS1M6IEhlYWx0aENoZWNrQ29uZmlnW10gPSBbXG4gIHtcbiAgICBuYW1lOiAnc3lzdGVtJyxcbiAgICBlbmRwb2ludDogJ2ludGVybmFsJywgLy8gU3BlY2lhbCBjYXNlIGZvciBzeXN0ZW0gY2hlY2tzXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBjcml0aWNhbDogZmFsc2UsXG4gICAgcmV0cmllczogMixcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdmcm9udGVuZCcsXG4gICAgZW5kcG9pbnQ6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIFxuICAgICAgPyAnaHR0cDovL2xvY2FsaG9zdDozMDAxL2FwaS9oZWFsdGgnICAvLyBTZXJ2ZXItc2lkZTogdXNlIGZ1bGwgVVJMXG4gICAgICA6ICcvYXBpL2hlYWx0aCcsICAgICAgICAgICAgICAgICAgICAgIC8vIENsaWVudC1zaWRlOiB1c2UgcmVsYXRpdmUgVVJMXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBleHBlY3RlZFN0YXR1czogMjAwLFxuICAgIGNyaXRpY2FsOiB0cnVlLFxuICAgIHJldHJpZXM6IDMsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnYmFja2VuZC1hcGknLFxuICAgIGVuZHBvaW50OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IRUFMVEhfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2hlYWx0aCcsXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBleHBlY3RlZFN0YXR1czogMjAwLFxuICAgIGNyaXRpY2FsOiB0cnVlLFxuICAgIHJldHJpZXM6IDMsXG4gIH0sXG5dXG5cbmNsYXNzIFNpbXBsZUhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBoZWFsdGhIaXN0b3J5OiBIZWFsdGhSZXN1bHRbXSA9IFtdXG4gIHByaXZhdGUgbWV0cmljc0hpc3Rvcnk6IEhlYWx0aEluZGV4TWV0cmljc1tdID0gW11cblxuICAvLyBSdW4gY29tcHJlaGVuc2l2ZSBoZWFsdGggY2hlY2tcbiAgYXN5bmMgcnVuSGVhbHRoQ2hlY2soKTogUHJvbWlzZTxIZWFsdGhSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgY2hlY2tzOiB7IFtrZXk6IHN0cmluZ106IEhlYWx0aENoZWNrUmVzdWx0IH0gPSB7fVxuICAgIGxldCB0b3RhbENoZWNrcyA9IDBcbiAgICBsZXQgcGFzc2VkQ2hlY2tzID0gMFxuICAgIGxldCBmYWlsZWRDaGVja3MgPSAwXG4gICAgbGV0IHdhcm5pbmdDaGVja3MgPSAwXG5cbiAgICAvLyBSdW4gYWxsIGhlYWx0aCBjaGVja3MgaW4gcGFyYWxsZWxcbiAgICBjb25zdCBjaGVja1Byb21pc2VzID0gREVGQVVMVF9IRUFMVEhfQ0hFQ0tTLm1hcChhc3luYyAoY29uZmlnKSA9PiB7XG4gICAgICBjb25zdCBjaGVja1N0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICAgIGxldCByZXRyeUNvdW50ID0gMFxuICAgICAgbGV0IGxhc3RFcnJvcjogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICAgIHdoaWxlIChyZXRyeUNvdW50IDwgY29uZmlnLnJldHJpZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBlcmZvcm1IZWFsdGhDaGVjayhjb25maWcpXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIGNoZWNrU3RhcnRUaW1lXG4gICAgICAgICAgXG4gICAgICAgICAgY2hlY2tzW2NvbmZpZy5uYW1lXSA9IHtcbiAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3Bhc3MnKSB7XG4gICAgICAgICAgICBwYXNzZWRDaGVja3MrK1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3dhcm4nKSB7XG4gICAgICAgICAgICB3YXJuaW5nQ2hlY2tzKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFpbGVkQ2hlY2tzKytcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhayAvLyBTdWNjZXNzLCBubyBuZWVkIHRvIHJldHJ5XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgbGFzdEVycm9yID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpXG4gICAgICAgICAgcmV0cnlDb3VudCsrXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHJldHJ5Q291bnQgPj0gY29uZmlnLnJldHJpZXMpIHtcbiAgICAgICAgICAgIGNoZWNrc1tjb25maWcubmFtZV0gPSB7XG4gICAgICAgICAgICAgIHN0YXR1czogJ2ZhaWwnLFxuICAgICAgICAgICAgICBlcnJvcjogbGFzdEVycm9yLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFpbGVkQ2hlY2tzKytcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2FpdCBiZWZvcmUgcmV0cnlcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwICogcmV0cnlDb3VudCkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGNoZWNrUHJvbWlzZXMpXG5cbiAgICB0b3RhbENoZWNrcyA9IE9iamVjdC5rZXlzKGNoZWNrcykubGVuZ3RoXG4gICAgY29uc3Qgb3ZlcmFsbEhlYWx0aCA9IHRvdGFsQ2hlY2tzID4gMCA/IChwYXNzZWRDaGVja3MgLyB0b3RhbENoZWNrcykgKiAxMDAgOiAwXG5cbiAgICBjb25zdCBoZWFsdGhSZXN1bHQ6IEhlYWx0aFJlc3VsdCA9IHtcbiAgICAgIHN0YXR1czogdGhpcy5kZXRlcm1pbmVPdmVyYWxsU3RhdHVzKG92ZXJhbGxIZWFsdGgsIGZhaWxlZENoZWNrcyksXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGNoZWNrcyxcbiAgICAgIHN1bW1hcnk6IHtcbiAgICAgICAgdG90YWxDaGVja3MsXG4gICAgICAgIHBhc3NlZENoZWNrcyxcbiAgICAgICAgZmFpbGVkQ2hlY2tzLFxuICAgICAgICB3YXJuaW5nQ2hlY2tzLFxuICAgICAgICBvdmVyYWxsSGVhbHRoOiBNYXRoLnJvdW5kKG92ZXJhbGxIZWFsdGgpLFxuICAgICAgfSxcbiAgICB9XG5cbiAgICAvLyBTdG9yZSBpbiBoaXN0b3J5XG4gICAgdGhpcy5oZWFsdGhIaXN0b3J5LnB1c2goaGVhbHRoUmVzdWx0KVxuICAgIGlmICh0aGlzLmhlYWx0aEhpc3RvcnkubGVuZ3RoID4gMTAwKSB7XG4gICAgICB0aGlzLmhlYWx0aEhpc3RvcnkgPSB0aGlzLmhlYWx0aEhpc3Rvcnkuc2xpY2UoLTEwMClcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgYW5kIHN0b3JlIGhlYWx0aCBpbmRleCBtZXRyaWNzXG4gICAgYXdhaXQgdGhpcy5jYWxjdWxhdGVIZWFsdGhJbmRleE1ldHJpY3MoaGVhbHRoUmVzdWx0KVxuXG4gICAgY29uc29sZS5sb2coJ0hlYWx0aCBjaGVjayBjb21wbGV0ZWQ6JywgaGVhbHRoUmVzdWx0LnN1bW1hcnkpXG4gICAgcmV0dXJuIGhlYWx0aFJlc3VsdFxuICB9XG5cbiAgLy8gUGVyZm9ybSBpbmRpdmlkdWFsIGhlYWx0aCBjaGVja1xuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1IZWFsdGhDaGVjayhjb25maWc6IEhlYWx0aENoZWNrQ29uZmlnKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgIGlmIChjb25maWcuZW5kcG9pbnQgPT09ICdpbnRlcm5hbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1JbnRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZylcbiAgICB9XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIGNvbmZpZy50aW1lb3V0KVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY29uZmlnLmVuZHBvaW50LCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcblxuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6ICdwYXNzJyxcbiAgICAgICAgICBkZXRhaWxzOiBkYXRhLFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgICBkZXRhaWxzOiB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLCBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0IH0sXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiAnd2FybicsXG4gICAgICAgICAgZGV0YWlsczogeyBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cywgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCB9LFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICBcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhlYWx0aCBjaGVjayB0aW1lb3V0IGFmdGVyICR7Y29uZmlnLnRpbWVvdXR9bXNgKVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIC8vIFBlcmZvcm0gaW50ZXJuYWwgaGVhbHRoIGNoZWNrc1xuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1JbnRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZzogSGVhbHRoQ2hlY2tDb25maWcpOiBQcm9taXNlPEhlYWx0aENoZWNrUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoY29uZmlnLm5hbWUpIHtcbiAgICAgICAgY2FzZSAnc3lzdGVtJzpcbiAgICAgICAgICAvLyBCYXNpYyBzeXN0ZW0gaGVhbHRoIGNoZWNrIHRoYXQgZG9lc24ndCByZXF1aXJlIGV4dGVybmFsIHNlcnZpY2VzXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogJ3Bhc3MnLFxuICAgICAgICAgICAgZGV0YWlsczogeyBcbiAgICAgICAgICAgICAgdXB0aW1lOiBwcm9jZXNzLnVwdGltZSgpLFxuICAgICAgICAgICAgICBtZW1vcnk6IHByb2Nlc3MubWVtb3J5VXNhZ2UoKSxcbiAgICAgICAgICAgICAgbm9kZVZlcnNpb246IHByb2Nlc3MudmVyc2lvbixcbiAgICAgICAgICAgICAgcGxhdGZvcm06IHByb2Nlc3MucGxhdGZvcm0sXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6ICd3YXJuJyxcbiAgICAgICAgICAgIGRldGFpbHM6IHsgZXJyb3I6ICdVbmtub3duIGludGVybmFsIGhlYWx0aCBjaGVjaycgfSxcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogJ3dhcm4nLFxuICAgICAgICBkZXRhaWxzOiB7IFxuICAgICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgbWVzc2FnZTogJ0ludGVybmFsIGhlYWx0aCBjaGVjayBmYWlsZWQnXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZXJtaW5lIG92ZXJhbGwgaGVhbHRoIHN0YXR1c1xuICBwcml2YXRlIGRldGVybWluZU92ZXJhbGxTdGF0dXMob3ZlcmFsbEhlYWx0aDogbnVtYmVyLCBmYWlsZWRDaGVja3M6IG51bWJlcik6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5JyB7XG4gICAgaWYgKG92ZXJhbGxIZWFsdGggPj0gOTAgJiYgZmFpbGVkQ2hlY2tzID09PSAwKSB7XG4gICAgICByZXR1cm4gJ2hlYWx0aHknXG4gICAgfSBlbHNlIGlmIChvdmVyYWxsSGVhbHRoID49IDcwICYmIGZhaWxlZENoZWNrcyA8PSAxKSB7XG4gICAgICByZXR1cm4gJ2RlZ3JhZGVkJ1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3VuaGVhbHRoeSdcbiAgICB9XG4gIH1cblxuICAvLyBDYWxjdWxhdGUgaGVhbHRoIGluZGV4IG1ldHJpY3NcbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhdGVIZWFsdGhJbmRleE1ldHJpY3MoaGVhbHRoUmVzdWx0OiBIZWFsdGhSZXN1bHQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgY29uc3Qgb25lSG91ckFnbyA9IG5ldyBEYXRlKG5vdy5nZXRUaW1lKCkgLSA2MCAqIDYwICogMTAwMClcbiAgICBcbiAgICAvLyBHZXQgcmVjZW50IGhlYWx0aCBjaGVja3MgZm9yIG1ldHJpY3MgY2FsY3VsYXRpb25cbiAgICBjb25zdCByZWNlbnRDaGVja3MgPSB0aGlzLmhlYWx0aEhpc3RvcnkuZmlsdGVyKFxuICAgICAgY2hlY2sgPT4gbmV3IERhdGUoY2hlY2sudGltZXN0YW1wKSA+PSBvbmVIb3VyQWdvXG4gICAgKVxuXG4gICAgaWYgKHJlY2VudENoZWNrcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gICAgLy8gQ2FsY3VsYXRlIGVycm9yIHJhdGVcbiAgICBjb25zdCB0b3RhbENoZWNrcyA9IHJlY2VudENoZWNrcy5yZWR1Y2UoKHN1bSwgY2hlY2spID0+IHN1bSArIGNoZWNrLnN1bW1hcnkudG90YWxDaGVja3MsIDApXG4gICAgY29uc3QgdG90YWxGYWlsdXJlcyA9IHJlY2VudENoZWNrcy5yZWR1Y2UoKHN1bSwgY2hlY2spID0+IHN1bSArIGNoZWNrLnN1bW1hcnkuZmFpbGVkQ2hlY2tzLCAwKVxuICAgIGNvbnN0IGVycm9yUmF0ZSA9IHRvdGFsQ2hlY2tzID4gMCA/IHRvdGFsRmFpbHVyZXMgLyB0b3RhbENoZWNrcyA6IDBcblxuICAgIC8vIENhbGN1bGF0ZSBhdmVyYWdlIHJlc3BvbnNlIHRpbWVcbiAgICBjb25zdCByZXNwb25zZVRpbWVzID0gcmVjZW50Q2hlY2tzLmZsYXRNYXAoY2hlY2sgPT4gXG4gICAgICBPYmplY3QudmFsdWVzKGNoZWNrLmNoZWNrcylcbiAgICAgICAgLm1hcChjID0+IGMucmVzcG9uc2VUaW1lKVxuICAgICAgICAuZmlsdGVyKChydCk6IHJ0IGlzIG51bWJlciA9PiBydCAhPT0gdW5kZWZpbmVkKVxuICAgIClcbiAgICBjb25zdCBhdmdSZXNwb25zZVRpbWUgPSByZXNwb25zZVRpbWVzLmxlbmd0aCA+IDAgXG4gICAgICA/IHJlc3BvbnNlVGltZXMucmVkdWNlKChzdW0sIHJ0KSA9PiBzdW0gKyBydCwgMCkgLyByZXNwb25zZVRpbWVzLmxlbmd0aCBcbiAgICAgIDogMFxuXG4gICAgLy8gQ2FsY3VsYXRlIHVwdGltZSAoc2ltcGxpZmllZCAtIGp1c3QgY2hlY2sgaWYgd2UgaGF2ZSByZWNlbnQgaGVhbHRoIGNoZWNrcylcbiAgICBjb25zdCB1cHRpbWUgPSByZWNlbnRDaGVja3MubGVuZ3RoID4gMCA/IDEuMCA6IDAuMFxuXG4gICAgLy8gQ3JlYXRlIG1ldHJpY3MgZW50cnlcbiAgICBjb25zdCBtZXRyaWNzOiBIZWFsdGhJbmRleE1ldHJpY3MgPSB7XG4gICAgICB0aW1lc3RhbXA6IG5vdy50b0lTT1N0cmluZygpLFxuICAgICAgZXJyb3JSYXRlOiBlcnJvclJhdGUgKiAxMDAsIC8vIENvbnZlcnQgdG8gcGVyY2VudGFnZVxuICAgICAgcmVzcG9uc2VUaW1lOiBhdmdSZXNwb25zZVRpbWUsXG4gICAgICB1cHRpbWU6IHVwdGltZSAqIDEwMCwgLy8gQ29udmVydCB0byBwZXJjZW50YWdlXG4gICAgICBqb2JGYWlsdXJlczogMCwgLy8gUGxhY2Vob2xkZXJcbiAgICAgIGF1dGhGYWlsdXJlczogMCwgLy8gUGxhY2Vob2xkZXJcbiAgICAgIHdlYmhvb2tGYWlsdXJlczogMCwgLy8gUGxhY2Vob2xkZXJcbiAgICAgIG92ZXJhbGxTY29yZTogaGVhbHRoUmVzdWx0LnN1bW1hcnkub3ZlcmFsbEhlYWx0aCxcbiAgICB9XG5cbiAgICB0aGlzLm1ldHJpY3NIaXN0b3J5LnB1c2gobWV0cmljcylcbiAgICBpZiAodGhpcy5tZXRyaWNzSGlzdG9yeS5sZW5ndGggPiAxMDAwKSB7XG4gICAgICB0aGlzLm1ldHJpY3NIaXN0b3J5ID0gdGhpcy5tZXRyaWNzSGlzdG9yeS5zbGljZSgtMTAwMClcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgaGVhbHRoIGhpc3RvcnlcbiAgZ2V0SGVhbHRoSGlzdG9yeSgpOiBIZWFsdGhSZXN1bHRbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmhlYWx0aEhpc3RvcnldXG4gIH1cblxuICAvLyBHZXQgbWV0cmljcyBoaXN0b3J5XG4gIGdldE1ldHJpY3NIaXN0b3J5KCk6IEhlYWx0aEluZGV4TWV0cmljc1tdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMubWV0cmljc0hpc3RvcnldXG4gIH1cblxuICAvLyBTdGFydCBtb25pdG9yaW5nIChwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uKVxuICBhc3luYyBzdGFydE1vbml0b3JpbmcoaW50ZXJ2YWxNczogbnVtYmVyID0gMzAwMDApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZyhgSGVhbHRoIG1vbml0b3Jpbmcgc3RhcnRlZCB3aXRoICR7aW50ZXJ2YWxNc31tcyBpbnRlcnZhbGApXG4gIH1cblxuICAvLyBTdG9wIG1vbml0b3JpbmcgKHBsYWNlaG9sZGVyIGZvciBmdXR1cmUgaW1wbGVtZW50YXRpb24pXG4gIHN0b3BNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKCdIZWFsdGggbW9uaXRvcmluZyBzdG9wcGVkJylcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgaGVhbHRoTW9uaXRvcmluZyA9IG5ldyBTaW1wbGVIZWFsdGhNb25pdG9yaW5nU2VydmljZSgpXG5cbi8vIEV4cG9ydCB0eXBlcyBmb3IgZXh0ZXJuYWwgdXNlXG5leHBvcnQgdHlwZSB7IEhlYWx0aENoZWNrQ29uZmlnLCBIZWFsdGhDaGVja1Jlc3VsdCwgSGVhbHRoSW5kZXhNZXRyaWNzLCBIZWFsdGhTdW1tYXJ5LCBIZWFsdGhSZXN1bHQgfVxuIl0sIm5hbWVzIjpbIkRFRkFVTFRfSEVBTFRIX0NIRUNLUyIsIm5hbWUiLCJlbmRwb2ludCIsInRpbWVvdXQiLCJjcml0aWNhbCIsInJldHJpZXMiLCJleHBlY3RlZFN0YXR1cyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19IRUFMVEhfQVBJX1VSTCIsIlNpbXBsZUhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlIiwicnVuSGVhbHRoQ2hlY2siLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY2hlY2tzIiwidG90YWxDaGVja3MiLCJwYXNzZWRDaGVja3MiLCJmYWlsZWRDaGVja3MiLCJ3YXJuaW5nQ2hlY2tzIiwiY2hlY2tQcm9taXNlcyIsIm1hcCIsImNvbmZpZyIsImNoZWNrU3RhcnRUaW1lIiwicmV0cnlDb3VudCIsImxhc3RFcnJvciIsInJlc3VsdCIsInBlcmZvcm1IZWFsdGhDaGVjayIsInJlc3BvbnNlVGltZSIsInN0YXR1cyIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiYWxsIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIm92ZXJhbGxIZWFsdGgiLCJoZWFsdGhSZXN1bHQiLCJkZXRlcm1pbmVPdmVyYWxsU3RhdHVzIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJzdW1tYXJ5IiwiTWF0aCIsInJvdW5kIiwiaGVhbHRoSGlzdG9yeSIsInB1c2giLCJzbGljZSIsImNhbGN1bGF0ZUhlYWx0aEluZGV4TWV0cmljcyIsImNvbnNvbGUiLCJsb2ciLCJwZXJmb3JtSW50ZXJuYWxIZWFsdGhDaGVjayIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJhYm9ydCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJzaWduYWwiLCJoZWFkZXJzIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJkYXRhIiwianNvbiIsImRldGFpbHMiLCJzdGF0dXNUZXh0IiwidXB0aW1lIiwibWVtb3J5IiwibWVtb3J5VXNhZ2UiLCJub2RlVmVyc2lvbiIsInZlcnNpb24iLCJwbGF0Zm9ybSIsIm9uZUhvdXJBZ28iLCJnZXRUaW1lIiwicmVjZW50Q2hlY2tzIiwiZmlsdGVyIiwiY2hlY2siLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbEZhaWx1cmVzIiwiZXJyb3JSYXRlIiwicmVzcG9uc2VUaW1lcyIsImZsYXRNYXAiLCJ2YWx1ZXMiLCJjIiwicnQiLCJ1bmRlZmluZWQiLCJhdmdSZXNwb25zZVRpbWUiLCJtZXRyaWNzIiwiam9iRmFpbHVyZXMiLCJhdXRoRmFpbHVyZXMiLCJ3ZWJob29rRmFpbHVyZXMiLCJvdmVyYWxsU2NvcmUiLCJtZXRyaWNzSGlzdG9yeSIsImdldEhlYWx0aEhpc3RvcnkiLCJnZXRNZXRyaWNzSGlzdG9yeSIsInN0YXJ0TW9uaXRvcmluZyIsImludGVydmFsTXMiLCJzdG9wTW9uaXRvcmluZyIsImhlYWx0aE1vbml0b3JpbmciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/health-monitoring-simple.ts\n"));

/***/ })

});