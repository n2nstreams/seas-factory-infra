"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"534be6851d9b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3VpL25leHRqcy9zcmMvYXBwL2dsb2JhbHMuY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiNTM0YmU2ODUxZDliXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/health-monitoring-simple.ts":
/*!*********************************************!*\
  !*** ./src/lib/health-monitoring-simple.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   healthMonitoring: () => (/* binding */ healthMonitoring)\n/* harmony export */ });\n/* harmony import */ var _correlation_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./correlation-id */ \"(app-pages-browser)/./src/lib/correlation-id.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Default health check configurations\nconst DEFAULT_HEALTH_CHECKS = [\n    {\n        name: 'system',\n        endpoint: 'internal',\n        timeout: 5000,\n        critical: false,\n        retries: 2\n    },\n    // Remove frontend self-check to avoid circular dependency\n    // The frontend health is determined by the overall API response\n    {\n        name: 'backend-api',\n        endpoint: process.env.NEXT_PUBLIC_HEALTH_API_URL || 'http://localhost:8000/health',\n        timeout: 5000,\n        expectedStatus: 200,\n        critical: true,\n        retries: 3,\n        method: 'GET'\n    }\n];\n// Health monitoring service\nclass HealthMonitoringService {\n    // Run a single health check\n    async runHealthCheck(config) {\n        var _correlationIDManager_getCurrentContext;\n        const startTime = Date.now();\n        const correlationId = (_correlationIDManager_getCurrentContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()) === null || _correlationIDManager_getCurrentContext === void 0 ? void 0 : _correlationIDManager_getCurrentContext.correlationId;\n        try {\n            let result;\n            if (config.endpoint === 'internal') {\n                // Internal system check\n                result = await this.runInternalHealthCheck(config);\n            } else {\n                // External endpoint check\n                result = await this.runExternalHealthCheck(config);\n            }\n            // Add correlation ID to result\n            if (correlationId) {\n                result.correlationId = correlationId;\n            }\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString(),\n                correlationId\n            };\n        }\n    }\n    // Run internal health check\n    async runInternalHealthCheck(config) {\n        const startTime = Date.now();\n        try {\n            // Check system resources\n            const systemInfo = await this.getSystemInfo();\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'pass',\n                responseTime,\n                details: systemInfo,\n                timestamp: new Date().toISOString()\n            };\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            return {\n                status: 'fail',\n                responseTime,\n                error: error instanceof Error ? error.message : String(error),\n                timestamp: new Date().toISOString()\n            };\n        }\n    }\n    // Run external health check\n    async runExternalHealthCheck(config) {\n        const startTime = Date.now();\n        let lastError = null;\n        // Try with retries\n        for(let attempt = 1; attempt <= config.retries; attempt++){\n            try {\n                const headers = {\n                    ...(0,_correlation_id__WEBPACK_IMPORTED_MODULE_0__.getCorrelationHeaders)(),\n                    ...config.headers,\n                    'User-Agent': 'Health-Monitor/1.0'\n                };\n                const controller = new AbortController();\n                const timeoutId = setTimeout(()=>controller.abort(), config.timeout);\n                const response = await fetch(config.endpoint, {\n                    method: config.method || 'HEAD',\n                    headers,\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                const responseTime = Date.now() - startTime;\n                if (config.expectedStatus && response.status !== config.expectedStatus) {\n                    throw new Error(\"Expected status \".concat(config.expectedStatus, \", got \").concat(response.status));\n                }\n                return {\n                    status: response.status < 400 ? 'pass' : response.status < 500 ? 'warn' : 'fail',\n                    responseTime,\n                    details: {\n                        status: response.status,\n                        statusText: response.statusText,\n                        headers: Object.fromEntries(response.headers.entries())\n                    },\n                    timestamp: new Date().toISOString()\n                };\n            } catch (error) {\n                lastError = error instanceof Error ? error : new Error(String(error));\n                // If this is the last attempt, throw the error\n                if (attempt === config.retries) {\n                    break;\n                }\n                // Wait before retry (exponential backoff)\n                await new Promise((resolve)=>setTimeout(resolve, Math.pow(2, attempt) * 100));\n            }\n        }\n        const responseTime = Date.now() - startTime;\n        throw lastError || new Error('Health check failed after all retries');\n    }\n    // Get system information\n    async getSystemInfo() {\n        if (false) {}\n        // Client-side\n        return {\n            platform: 'browser',\n            userAgent: navigator.userAgent,\n            language: navigator.language,\n            cookieEnabled: navigator.cookieEnabled,\n            onLine: navigator.onLine,\n            timestamp: new Date().toISOString()\n        };\n    }\n    // Run comprehensive health check\n    async runComprehensiveHealthCheck() {\n        var _correlationIDManager_getCurrentContext;\n        const startTime = Date.now();\n        const correlationId = (_correlationIDManager_getCurrentContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.getCurrentContext()) === null || _correlationIDManager_getCurrentContext === void 0 ? void 0 : _correlationIDManager_getCurrentContext.correlationId;\n        // Generate correlation context for this health check\n        const healthCheckContext = _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.generateContext(correlationId, undefined, undefined, undefined, {\n            operation: 'health_check',\n            type: 'comprehensive'\n        });\n        try {\n            const checkResults = {};\n            const checkPromises = DEFAULT_HEALTH_CHECKS.map(async (config)=>{\n                const result = await this.runHealthCheck(config);\n                checkResults[config.name] = result;\n                return result;\n            });\n            await Promise.allSettled(checkPromises);\n            // Calculate summary\n            const summary = this.calculateHealthSummary(checkResults);\n            // Determine overall status\n            let status = 'healthy';\n            if (summary.failedChecks > 0) {\n                status = 'unhealthy';\n            } else if (summary.warningChecks > 0 || summary.overallHealth < 90) {\n                status = 'degraded';\n            }\n            const result = {\n                status,\n                timestamp: new Date().toISOString(),\n                checks: checkResults,\n                summary,\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Add to history\n            this.healthHistory.push(result);\n            if (this.healthHistory.length > 100) {\n                this.healthHistory = this.healthHistory.slice(-100);\n            }\n            // Update metrics\n            this.updateMetrics(result);\n            // Log correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'info');\n            return result;\n        } catch (error) {\n            const responseTime = Date.now() - startTime;\n            // Create error result\n            const errorResult = {\n                status: 'unhealthy',\n                timestamp: new Date().toISOString(),\n                checks: {},\n                summary: {\n                    overallHealth: 0,\n                    totalChecks: 0,\n                    passedChecks: 0,\n                    failedChecks: 1,\n                    warningChecks: 0,\n                    averageResponseTime: responseTime\n                },\n                metadata: {\n                    service: 'AI SaaS Factory - Next.js Frontend',\n                    region: 'local',\n                    instance: 'localhost',\n                    build: 'local',\n                    commit: 'local',\n                    correlationId: healthCheckContext.correlationId\n                }\n            };\n            // Log error with correlation context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.logContext(healthCheckContext, 'error');\n            return errorResult;\n        } finally{\n            // Clear the health check context\n            _correlation_id__WEBPACK_IMPORTED_MODULE_0__.correlationIDManager.clearCurrentContext();\n        }\n    }\n    // Calculate health summary\n    calculateHealthSummary(checks) {\n        const checkArray = Object.values(checks);\n        const totalChecks = checkArray.length;\n        const passedChecks = checkArray.filter((c)=>c.status === 'pass').length;\n        const failedChecks = checkArray.filter((c)=>c.status === 'fail').length;\n        const warningChecks = checkArray.filter((c)=>c.status === 'warn').length;\n        const overallHealth = totalChecks > 0 ? passedChecks / totalChecks * 100 : 0;\n        const averageResponseTime = checkArray.length > 0 ? checkArray.reduce((sum, c)=>sum + c.responseTime, 0) / checkArray.length : 0;\n        return {\n            overallHealth: Math.round(overallHealth),\n            totalChecks,\n            passedChecks,\n            failedChecks,\n            warningChecks,\n            averageResponseTime: Math.round(averageResponseTime)\n        };\n    }\n    // Update metrics history\n    updateMetrics(healthResult) {\n        const metrics = {\n            overallScore: healthResult.summary.overallHealth,\n            errorRate: healthResult.summary.failedChecks / healthResult.summary.totalChecks,\n            responseTime: healthResult.summary.averageResponseTime,\n            uptime: healthResult.status === 'healthy' ? 100 : healthResult.status === 'degraded' ? 75 : 0,\n            lastCheck: healthResult.timestamp\n        };\n        this.metricsHistory.push(metrics);\n        if (this.metricsHistory.length > 1000) {\n            this.metricsHistory = this.metricsHistory.slice(-1000);\n        }\n    }\n    // Get health history\n    getHealthHistory() {\n        return [\n            ...this.healthHistory\n        ];\n    }\n    // Get metrics history\n    getMetricsHistory() {\n        return [\n            ...this.metricsHistory\n        ];\n    }\n    // Start monitoring\n    startMonitoring() {\n        let intervalMs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30000;\n        if (this.isMonitoring) return;\n        this.isMonitoring = true;\n        this.monitoringInterval = setInterval(async ()=>{\n            try {\n                await this.runComprehensiveHealthCheck();\n            } catch (error) {\n                console.error('Health monitoring error:', error);\n            }\n        }, intervalMs);\n        console.log('Health monitoring started with interval:', intervalMs, 'ms');\n    }\n    // Stop monitoring\n    stopMonitoring() {\n        if (this.monitoringInterval) {\n            clearInterval(this.monitoringInterval);\n            this.monitoringInterval = null;\n        }\n        this.isMonitoring = false;\n        console.log('Health monitoring stopped');\n    }\n    // Get current health\n    getCurrentHealth() {\n        return this.healthHistory.length > 0 ? this.healthHistory[this.healthHistory.length - 1] : null;\n    }\n    // Check if monitoring is active\n    isMonitoringActive() {\n        return this.isMonitoring;\n    }\n    // Get monitoring status\n    getMonitoringStatus() {\n        return {\n            isActive: this.isMonitoring,\n            interval: this.monitoringInterval ? 30000 : null\n        };\n    }\n    constructor(){\n        this.healthHistory = [];\n        this.metricsHistory = [];\n        this.isMonitoring = false;\n        this.monitoringInterval = null;\n    }\n}\n// Export singleton instance\nconst healthMonitoring = new HealthMonitoringService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvaGVhbHRoLW1vbml0b3Jpbmctc2ltcGxlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RTtBQTJEOUUsc0NBQXNDO0FBQ3RDLE1BQU1FLHdCQUE2QztJQUNqRDtRQUNFQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxVQUFVO1FBQ1ZDLFNBQVM7SUFDWDtJQUNBLDBEQUEwRDtJQUMxRCxnRUFBZ0U7SUFDaEU7UUFDRUosTUFBTTtRQUNOQyxVQUFVSSxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLDBCQUEwQixJQUFJO1FBQ3BETCxTQUFTO1FBQ1RNLGdCQUFnQjtRQUNoQkwsVUFBVTtRQUNWQyxTQUFTO1FBQ1RLLFFBQVE7SUFDVjtDQUNEO0FBRUQsNEJBQTRCO0FBQzVCLE1BQU1DO0lBTUosNEJBQTRCO0lBQzVCLE1BQU1DLGVBQWVDLE1BQXlCLEVBQThCO1lBRXBEZjtRQUR0QixNQUFNZ0IsWUFBWUMsS0FBS0MsR0FBRztRQUMxQixNQUFNQyxpQkFBZ0JuQiwwQ0FBQUEsaUVBQW9CQSxDQUFDb0IsaUJBQWlCLGdCQUF0Q3BCLDhEQUFBQSx3Q0FBMENtQixhQUFhO1FBRTdFLElBQUk7WUFDRixJQUFJRTtZQUVKLElBQUlOLE9BQU9YLFFBQVEsS0FBSyxZQUFZO2dCQUNsQyx3QkFBd0I7Z0JBQ3hCaUIsU0FBUyxNQUFNLElBQUksQ0FBQ0Msc0JBQXNCLENBQUNQO1lBQzdDLE9BQU87Z0JBQ0wsMEJBQTBCO2dCQUMxQk0sU0FBUyxNQUFNLElBQUksQ0FBQ0Usc0JBQXNCLENBQUNSO1lBQzdDO1lBRUEsK0JBQStCO1lBQy9CLElBQUlJLGVBQWU7Z0JBQ2pCRSxPQUFPRixhQUFhLEdBQUdBO1lBQ3pCO1lBRUEsT0FBT0U7UUFDVCxFQUFFLE9BQU9HLE9BQU87WUFDZCxNQUFNQyxlQUFlUixLQUFLQyxHQUFHLEtBQUtGO1lBQ2xDLE9BQU87Z0JBQ0xVLFFBQVE7Z0JBQ1JEO2dCQUNBRCxPQUFPQSxpQkFB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QUksQ0FBQ0YsYUFBYSxDQUFDLElBQUksQ0FBQ0EsYUFBYSxDQUFDRSxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQzdGO0lBRUEsZ0NBQWdDO0lBQ2hDbUMscUJBQThCO1FBQzVCLE9BQU8sSUFBSSxDQUFDUixZQUFZO0lBQzFCO0lBRUEsd0JBQXdCO0lBQ3hCUyxzQkFBc0U7UUFDcEUsT0FBTztZQUNMQyxVQUFVLElBQUksQ0FBQ1YsWUFBWTtZQUMzQlcsVUFBVSxJQUFJLENBQUNWLGtCQUFrQixHQUFHLFFBQVE7UUFDOUM7SUFDRjs7YUEvVVE5QixnQkFBZ0MsRUFBRTthQUNsQ3dCLGlCQUF1QyxFQUFFO2FBQ3pDSyxlQUF3QjthQUN4QkMscUJBQTRDOztBQTZVdEQ7QUFFQSw0QkFBNEI7QUFDckIsTUFBTVcsbUJBQW1CLElBQUkvRywwQkFBeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNtaW5pL0RvY3VtZW50cy9Qcm9qZWN0cy9TYWFTIEZhY3RvcnkvdWkvbmV4dGpzL3NyYy9saWIvaGVhbHRoLW1vbml0b3Jpbmctc2ltcGxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvcnJlbGF0aW9uSURNYW5hZ2VyLCBnZXRDb3JyZWxhdGlvbkhlYWRlcnMgfSBmcm9tICcuL2NvcnJlbGF0aW9uLWlkJ1xuXG4vLyBIZWFsdGggY2hlY2sgY29uZmlndXJhdGlvbiBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQ2hlY2tDb25maWcge1xuICBuYW1lOiBzdHJpbmdcbiAgZW5kcG9pbnQ6IHN0cmluZ1xuICB0aW1lb3V0OiBudW1iZXJcbiAgZXhwZWN0ZWRTdGF0dXM/OiBudW1iZXJcbiAgY3JpdGljYWw6IGJvb2xlYW5cbiAgcmV0cmllczogbnVtYmVyXG4gIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIG1ldGhvZD86ICdHRVQnIHwgJ0hFQUQnIC8vIEFkZGVkIG1ldGhvZCBmb3IgYmFja2VuZCBjaGVja3Ncbn1cblxuLy8gSGVhbHRoIGNoZWNrIHJlc3VsdCBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgSGVhbHRoQ2hlY2tSZXN1bHQge1xuICBzdGF0dXM6ICdwYXNzJyB8ICd3YXJuJyB8ICdmYWlsJ1xuICByZXNwb25zZVRpbWU6IG51bWJlclxuICBlcnJvcj86IHN0cmluZ1xuICBkZXRhaWxzPzogYW55XG4gIHRpbWVzdGFtcDogc3RyaW5nXG4gIGNvcnJlbGF0aW9uSWQ/OiBzdHJpbmdcbn1cblxuLy8gSGVhbHRoIGluZGV4IG1ldHJpY3MgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIEhlYWx0aEluZGV4TWV0cmljcyB7XG4gIG92ZXJhbGxTY29yZTogbnVtYmVyXG4gIGVycm9yUmF0ZTogbnVtYmVyXG4gIHJlc3BvbnNlVGltZTogbnVtYmVyXG4gIHVwdGltZTogbnVtYmVyXG4gIGxhc3RDaGVjazogc3RyaW5nXG59XG5cbi8vIEhlYWx0aCBzdW1tYXJ5IGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhTdW1tYXJ5IHtcbiAgb3ZlcmFsbEhlYWx0aDogbnVtYmVyXG4gIHRvdGFsQ2hlY2tzOiBudW1iZXJcbiAgcGFzc2VkQ2hlY2tzOiBudW1iZXJcbiAgZmFpbGVkQ2hlY2tzOiBudW1iZXJcbiAgd2FybmluZ0NoZWNrczogbnVtYmVyXG4gIGF2ZXJhZ2VSZXNwb25zZVRpbWU6IG51bWJlclxufVxuXG4vLyBIZWFsdGggcmVzdWx0IGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBIZWFsdGhSZXN1bHQge1xuICBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5J1xuICB0aW1lc3RhbXA6IHN0cmluZ1xuICBjaGVja3M6IFJlY29yZDxzdHJpbmcsIEhlYWx0aENoZWNrUmVzdWx0PlxuICBzdW1tYXJ5OiBIZWFsdGhTdW1tYXJ5XG4gIG1ldGFkYXRhOiB7XG4gICAgc2VydmljZTogc3RyaW5nXG4gICAgcmVnaW9uOiBzdHJpbmdcbiAgICBpbnN0YW5jZTogc3RyaW5nXG4gICAgYnVpbGQ6IHN0cmluZ1xuICAgIGNvbW1pdDogc3RyaW5nXG4gICAgY29ycmVsYXRpb25JZD86IHN0cmluZ1xuICB9XG59XG5cbi8vIERlZmF1bHQgaGVhbHRoIGNoZWNrIGNvbmZpZ3VyYXRpb25zXG5jb25zdCBERUZBVUxUX0hFQUxUSF9DSEVDS1M6IEhlYWx0aENoZWNrQ29uZmlnW10gPSBbXG4gIHtcbiAgICBuYW1lOiAnc3lzdGVtJyxcbiAgICBlbmRwb2ludDogJ2ludGVybmFsJywgLy8gU3BlY2lhbCBjYXNlIGZvciBzeXN0ZW0gY2hlY2tzXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBjcml0aWNhbDogZmFsc2UsXG4gICAgcmV0cmllczogMixcbiAgfSxcbiAgLy8gUmVtb3ZlIGZyb250ZW5kIHNlbGYtY2hlY2sgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAvLyBUaGUgZnJvbnRlbmQgaGVhbHRoIGlzIGRldGVybWluZWQgYnkgdGhlIG92ZXJhbGwgQVBJIHJlc3BvbnNlXG4gIHtcbiAgICBuYW1lOiAnYmFja2VuZC1hcGknLFxuICAgIGVuZHBvaW50OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19IRUFMVEhfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwL2hlYWx0aCcsXG4gICAgdGltZW91dDogNTAwMCxcbiAgICBleHBlY3RlZFN0YXR1czogMjAwLFxuICAgIGNyaXRpY2FsOiB0cnVlLFxuICAgIHJldHJpZXM6IDMsXG4gICAgbWV0aG9kOiAnR0VUJywgLy8gVXNlIEdFVCBpbnN0ZWFkIG9mIEhFQUQgZm9yIGJhY2tlbmRcbiAgfSxcbl1cblxuLy8gSGVhbHRoIG1vbml0b3Jpbmcgc2VydmljZVxuY2xhc3MgSGVhbHRoTW9uaXRvcmluZ1NlcnZpY2Uge1xuICBwcml2YXRlIGhlYWx0aEhpc3Rvcnk6IEhlYWx0aFJlc3VsdFtdID0gW11cbiAgcHJpdmF0ZSBtZXRyaWNzSGlzdG9yeTogSGVhbHRoSW5kZXhNZXRyaWNzW10gPSBbXVxuICBwcml2YXRlIGlzTW9uaXRvcmluZzogYm9vbGVhbiA9IGZhbHNlXG4gIHByaXZhdGUgbW9uaXRvcmluZ0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG5cbiAgLy8gUnVuIGEgc2luZ2xlIGhlYWx0aCBjaGVja1xuICBhc3luYyBydW5IZWFsdGhDaGVjayhjb25maWc6IEhlYWx0aENoZWNrQ29uZmlnKTogUHJvbWlzZTxIZWFsdGhDaGVja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBjb25zdCBjb3JyZWxhdGlvbklkID0gY29ycmVsYXRpb25JRE1hbmFnZXIuZ2V0Q3VycmVudENvbnRleHQoKT8uY29ycmVsYXRpb25JZFxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXN1bHQ6IEhlYWx0aENoZWNrUmVzdWx0XG5cbiAgICAgIGlmIChjb25maWcuZW5kcG9pbnQgPT09ICdpbnRlcm5hbCcpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgc3lzdGVtIGNoZWNrXG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuSW50ZXJuYWxIZWFsdGhDaGVjayhjb25maWcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeHRlcm5hbCBlbmRwb2ludCBjaGVja1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkV4dGVybmFsSGVhbHRoQ2hlY2soY29uZmlnKVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY29ycmVsYXRpb24gSUQgdG8gcmVzdWx0XG4gICAgICBpZiAoY29ycmVsYXRpb25JZCkge1xuICAgICAgICByZXN1bHQuY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgY29ycmVsYXRpb25JZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biBpbnRlcm5hbCBoZWFsdGggY2hlY2tcbiAgcHJpdmF0ZSBhc3luYyBydW5JbnRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZzogSGVhbHRoQ2hlY2tDb25maWcpOiBQcm9taXNlPEhlYWx0aENoZWNrUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBzeXN0ZW0gcmVzb3VyY2VzXG4gICAgICBjb25zdCBzeXN0ZW1JbmZvID0gYXdhaXQgdGhpcy5nZXRTeXN0ZW1JbmZvKClcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdwYXNzJyxcbiAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICBkZXRhaWxzOiBzeXN0ZW1JbmZvLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCByZXNwb25zZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6ICdmYWlsJyxcbiAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biBleHRlcm5hbCBoZWFsdGggY2hlY2tcbiAgcHJpdmF0ZSBhc3luYyBydW5FeHRlcm5hbEhlYWx0aENoZWNrKGNvbmZpZzogSGVhbHRoQ2hlY2tDb25maWcpOiBQcm9taXNlPEhlYWx0aENoZWNrUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGxcblxuICAgIC8vIFRyeSB3aXRoIHJldHJpZXNcbiAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBjb25maWcucmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgIC4uLmdldENvcnJlbGF0aW9uSGVhZGVycygpLFxuICAgICAgICAgIC4uLmNvbmZpZy5oZWFkZXJzLFxuICAgICAgICAgICdVc2VyLUFnZW50JzogJ0hlYWx0aC1Nb25pdG9yLzEuMCdcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIGNvbmZpZy50aW1lb3V0KVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY29uZmlnLmVuZHBvaW50LCB7XG4gICAgICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kIHx8ICdIRUFEJywgLy8gVXNlIG1ldGhvZCBmcm9tIGNvbmZpZyBvciBkZWZhdWx0IHRvIEhFQURcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICAgICAgfSlcblxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcblxuICAgICAgICBpZiAoY29uZmlnLmV4cGVjdGVkU3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyAhPT0gY29uZmlnLmV4cGVjdGVkU3RhdHVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBzdGF0dXMgJHtjb25maWcuZXhwZWN0ZWRTdGF0dXN9LCBnb3QgJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgPCA0MDAgPyAncGFzcycgOiByZXNwb25zZS5zdGF0dXMgPCA1MDAgPyAnd2FybicgOiAnZmFpbCcsXG4gICAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhyZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgbGFzdCBhdHRlbXB0LCB0aHJvdyB0aGUgZXJyb3JcbiAgICAgICAgaWYgKGF0dGVtcHQgPT09IGNvbmZpZy5yZXRyaWVzKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5IChleHBvbmVudGlhbCBiYWNrb2ZmKVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5wb3coMiwgYXR0ZW1wdCkgKiAxMDApKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IEVycm9yKCdIZWFsdGggY2hlY2sgZmFpbGVkIGFmdGVyIGFsbCByZXRyaWVzJylcbiAgfVxuXG4gIC8vIEdldCBzeXN0ZW0gaW5mb3JtYXRpb25cbiAgcHJpdmF0ZSBhc3luYyBnZXRTeXN0ZW1JbmZvKCk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBTZXJ2ZXItc2lkZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGxhdGZvcm06ICdzZXJ2ZXInLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsaWVudC1zaWRlXG4gICAgcmV0dXJuIHtcbiAgICAgIHBsYXRmb3JtOiAnYnJvd3NlcicsXG4gICAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICBsYW5ndWFnZTogbmF2aWdhdG9yLmxhbmd1YWdlLFxuICAgICAgY29va2llRW5hYmxlZDogbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQsXG4gICAgICBvbkxpbmU6IG5hdmlnYXRvci5vbkxpbmUsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biBjb21wcmVoZW5zaXZlIGhlYWx0aCBjaGVja1xuICBhc3luYyBydW5Db21wcmVoZW5zaXZlSGVhbHRoQ2hlY2soKTogUHJvbWlzZTxIZWFsdGhSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgY29uc3QgY29ycmVsYXRpb25JZCA9IGNvcnJlbGF0aW9uSURNYW5hZ2VyLmdldEN1cnJlbnRDb250ZXh0KCk/LmNvcnJlbGF0aW9uSWRcblxuICAgIC8vIEdlbmVyYXRlIGNvcnJlbGF0aW9uIGNvbnRleHQgZm9yIHRoaXMgaGVhbHRoIGNoZWNrXG4gICAgY29uc3QgaGVhbHRoQ2hlY2tDb250ZXh0ID0gY29ycmVsYXRpb25JRE1hbmFnZXIuZ2VuZXJhdGVDb250ZXh0KFxuICAgICAgY29ycmVsYXRpb25JZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHsgb3BlcmF0aW9uOiAnaGVhbHRoX2NoZWNrJywgdHlwZTogJ2NvbXByZWhlbnNpdmUnIH1cbiAgICApXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2hlY2tSZXN1bHRzOiBSZWNvcmQ8c3RyaW5nLCBIZWFsdGhDaGVja1Jlc3VsdD4gPSB7fVxuICAgICAgY29uc3QgY2hlY2tQcm9taXNlcyA9IERFRkFVTFRfSEVBTFRIX0NIRUNLUy5tYXAoYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkhlYWx0aENoZWNrKGNvbmZpZylcbiAgICAgICAgY2hlY2tSZXN1bHRzW2NvbmZpZy5uYW1lXSA9IHJlc3VsdFxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoY2hlY2tQcm9taXNlcylcblxuICAgICAgLy8gQ2FsY3VsYXRlIHN1bW1hcnlcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSB0aGlzLmNhbGN1bGF0ZUhlYWx0aFN1bW1hcnkoY2hlY2tSZXN1bHRzKVxuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgb3ZlcmFsbCBzdGF0dXNcbiAgICAgIGxldCBzdGF0dXM6ICdoZWFsdGh5JyB8ICdkZWdyYWRlZCcgfCAndW5oZWFsdGh5JyA9ICdoZWFsdGh5J1xuICAgICAgaWYgKHN1bW1hcnkuZmFpbGVkQ2hlY2tzID4gMCkge1xuICAgICAgICBzdGF0dXMgPSAndW5oZWFsdGh5J1xuICAgICAgfSBlbHNlIGlmIChzdW1tYXJ5Lndhcm5pbmdDaGVja3MgPiAwIHx8IHN1bW1hcnkub3ZlcmFsbEhlYWx0aCA8IDkwKSB7XG4gICAgICAgIHN0YXR1cyA9ICdkZWdyYWRlZCdcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0OiBIZWFsdGhSZXN1bHQgPSB7XG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNoZWNrczogY2hlY2tSZXN1bHRzLFxuICAgICAgICBzdW1tYXJ5LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIHNlcnZpY2U6ICdBSSBTYWFTIEZhY3RvcnkgLSBOZXh0LmpzIEZyb250ZW5kJyxcbiAgICAgICAgICByZWdpb246ICdsb2NhbCcsXG4gICAgICAgICAgaW5zdGFuY2U6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgIGJ1aWxkOiAnbG9jYWwnLFxuICAgICAgICAgIGNvbW1pdDogJ2xvY2FsJyxcbiAgICAgICAgICBjb3JyZWxhdGlvbklkOiBoZWFsdGhDaGVja0NvbnRleHQuY29ycmVsYXRpb25JZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0byBoaXN0b3J5XG4gICAgICB0aGlzLmhlYWx0aEhpc3RvcnkucHVzaChyZXN1bHQpXG4gICAgICBpZiAodGhpcy5oZWFsdGhIaXN0b3J5Lmxlbmd0aCA+IDEwMCkge1xuICAgICAgICB0aGlzLmhlYWx0aEhpc3RvcnkgPSB0aGlzLmhlYWx0aEhpc3Rvcnkuc2xpY2UoLTEwMClcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIG1ldHJpY3NcbiAgICAgIHRoaXMudXBkYXRlTWV0cmljcyhyZXN1bHQpXG5cbiAgICAgIC8vIExvZyBjb3JyZWxhdGlvbiBjb250ZXh0XG4gICAgICBjb3JyZWxhdGlvbklETWFuYWdlci5sb2dDb250ZXh0KGhlYWx0aENoZWNrQ29udGV4dCwgJ2luZm8nKVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWVcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGVycm9yIHJlc3VsdFxuICAgICAgY29uc3QgZXJyb3JSZXN1bHQ6IEhlYWx0aFJlc3VsdCA9IHtcbiAgICAgICAgc3RhdHVzOiAndW5oZWFsdGh5JyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGNoZWNrczoge30sXG4gICAgICAgIHN1bW1hcnk6IHtcbiAgICAgICAgICBvdmVyYWxsSGVhbHRoOiAwLFxuICAgICAgICAgIHRvdGFsQ2hlY2tzOiAwLFxuICAgICAgICAgIHBhc3NlZENoZWNrczogMCxcbiAgICAgICAgICBmYWlsZWRDaGVja3M6IDEsXG4gICAgICAgICAgd2FybmluZ0NoZWNrczogMCxcbiAgICAgICAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiByZXNwb25zZVRpbWVcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBzZXJ2aWNlOiAnQUkgU2FhUyBGYWN0b3J5IC0gTmV4dC5qcyBGcm9udGVuZCcsXG4gICAgICAgICAgcmVnaW9uOiAnbG9jYWwnLFxuICAgICAgICAgIGluc3RhbmNlOiAnbG9jYWxob3N0JyxcbiAgICAgICAgICBidWlsZDogJ2xvY2FsJyxcbiAgICAgICAgICBjb21taXQ6ICdsb2NhbCcsXG4gICAgICAgICAgY29ycmVsYXRpb25JZDogaGVhbHRoQ2hlY2tDb250ZXh0LmNvcnJlbGF0aW9uSWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2cgZXJyb3Igd2l0aCBjb3JyZWxhdGlvbiBjb250ZXh0XG4gICAgICBjb3JyZWxhdGlvbklETWFuYWdlci5sb2dDb250ZXh0KGhlYWx0aENoZWNrQ29udGV4dCwgJ2Vycm9yJylcbiAgICAgIFxuICAgICAgcmV0dXJuIGVycm9yUmVzdWx0XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHRoZSBoZWFsdGggY2hlY2sgY29udGV4dFxuICAgICAgY29ycmVsYXRpb25JRE1hbmFnZXIuY2xlYXJDdXJyZW50Q29udGV4dCgpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGhlYWx0aCBzdW1tYXJ5XG4gIHByaXZhdGUgY2FsY3VsYXRlSGVhbHRoU3VtbWFyeShjaGVja3M6IFJlY29yZDxzdHJpbmcsIEhlYWx0aENoZWNrUmVzdWx0Pik6IEhlYWx0aFN1bW1hcnkge1xuICAgIGNvbnN0IGNoZWNrQXJyYXkgPSBPYmplY3QudmFsdWVzKGNoZWNrcylcbiAgICBjb25zdCB0b3RhbENoZWNrcyA9IGNoZWNrQXJyYXkubGVuZ3RoXG4gICAgY29uc3QgcGFzc2VkQ2hlY2tzID0gY2hlY2tBcnJheS5maWx0ZXIoYyA9PiBjLnN0YXR1cyA9PT0gJ3Bhc3MnKS5sZW5ndGhcbiAgICBjb25zdCBmYWlsZWRDaGVja3MgPSBjaGVja0FycmF5LmZpbHRlcihjID0+IGMuc3RhdHVzID09PSAnZmFpbCcpLmxlbmd0aFxuICAgIGNvbnN0IHdhcm5pbmdDaGVja3MgPSBjaGVja0FycmF5LmZpbHRlcihjID0+IGMuc3RhdHVzID09PSAnd2FybicpLmxlbmd0aFxuXG4gICAgY29uc3Qgb3ZlcmFsbEhlYWx0aCA9IHRvdGFsQ2hlY2tzID4gMCA/IChwYXNzZWRDaGVja3MgLyB0b3RhbENoZWNrcykgKiAxMDAgOiAwXG4gICAgY29uc3QgYXZlcmFnZVJlc3BvbnNlVGltZSA9IGNoZWNrQXJyYXkubGVuZ3RoID4gMCBcbiAgICAgID8gY2hlY2tBcnJheS5yZWR1Y2UoKHN1bSwgYykgPT4gc3VtICsgYy5yZXNwb25zZVRpbWUsIDApIC8gY2hlY2tBcnJheS5sZW5ndGggXG4gICAgICA6IDBcblxuICAgIHJldHVybiB7XG4gICAgICBvdmVyYWxsSGVhbHRoOiBNYXRoLnJvdW5kKG92ZXJhbGxIZWFsdGgpLFxuICAgICAgdG90YWxDaGVja3MsXG4gICAgICBwYXNzZWRDaGVja3MsXG4gICAgICBmYWlsZWRDaGVja3MsXG4gICAgICB3YXJuaW5nQ2hlY2tzLFxuICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogTWF0aC5yb3VuZChhdmVyYWdlUmVzcG9uc2VUaW1lKVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSBtZXRyaWNzIGhpc3RvcnlcbiAgcHJpdmF0ZSB1cGRhdGVNZXRyaWNzKGhlYWx0aFJlc3VsdDogSGVhbHRoUmVzdWx0KTogdm9pZCB7XG4gICAgY29uc3QgbWV0cmljczogSGVhbHRoSW5kZXhNZXRyaWNzID0ge1xuICAgICAgb3ZlcmFsbFNjb3JlOiBoZWFsdGhSZXN1bHQuc3VtbWFyeS5vdmVyYWxsSGVhbHRoLFxuICAgICAgZXJyb3JSYXRlOiBoZWFsdGhSZXN1bHQuc3VtbWFyeS5mYWlsZWRDaGVja3MgLyBoZWFsdGhSZXN1bHQuc3VtbWFyeS50b3RhbENoZWNrcyxcbiAgICAgIHJlc3BvbnNlVGltZTogaGVhbHRoUmVzdWx0LnN1bW1hcnkuYXZlcmFnZVJlc3BvbnNlVGltZSxcbiAgICAgIHVwdGltZTogaGVhbHRoUmVzdWx0LnN0YXR1cyA9PT0gJ2hlYWx0aHknID8gMTAwIDogaGVhbHRoUmVzdWx0LnN0YXR1cyA9PT0gJ2RlZ3JhZGVkJyA/IDc1IDogMCxcbiAgICAgIGxhc3RDaGVjazogaGVhbHRoUmVzdWx0LnRpbWVzdGFtcFxuICAgIH1cblxuICAgIHRoaXMubWV0cmljc0hpc3RvcnkucHVzaChtZXRyaWNzKVxuICAgIGlmICh0aGlzLm1ldHJpY3NIaXN0b3J5Lmxlbmd0aCA+IDEwMDApIHtcbiAgICAgIHRoaXMubWV0cmljc0hpc3RvcnkgPSB0aGlzLm1ldHJpY3NIaXN0b3J5LnNsaWNlKC0xMDAwKVxuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBoZWFsdGggaGlzdG9yeVxuICBnZXRIZWFsdGhIaXN0b3J5KCk6IEhlYWx0aFJlc3VsdFtdIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuaGVhbHRoSGlzdG9yeV1cbiAgfVxuXG4gIC8vIEdldCBtZXRyaWNzIGhpc3RvcnlcbiAgZ2V0TWV0cmljc0hpc3RvcnkoKTogSGVhbHRoSW5kZXhNZXRyaWNzW10ge1xuICAgIHJldHVybiBbLi4udGhpcy5tZXRyaWNzSGlzdG9yeV1cbiAgfVxuXG4gIC8vIFN0YXJ0IG1vbml0b3JpbmdcbiAgc3RhcnRNb25pdG9yaW5nKGludGVydmFsTXM6IG51bWJlciA9IDMwMDAwKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNNb25pdG9yaW5nKSByZXR1cm5cblxuICAgIHRoaXMuaXNNb25pdG9yaW5nID0gdHJ1ZVxuICAgIHRoaXMubW9uaXRvcmluZ0ludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Db21wcmVoZW5zaXZlSGVhbHRoQ2hlY2soKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSGVhbHRoIG1vbml0b3JpbmcgZXJyb3I6JywgZXJyb3IpXG4gICAgICB9XG4gICAgfSwgaW50ZXJ2YWxNcylcblxuICAgIGNvbnNvbGUubG9nKCdIZWFsdGggbW9uaXRvcmluZyBzdGFydGVkIHdpdGggaW50ZXJ2YWw6JywgaW50ZXJ2YWxNcywgJ21zJylcbiAgfVxuXG4gIC8vIFN0b3AgbW9uaXRvcmluZ1xuICBzdG9wTW9uaXRvcmluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5tb25pdG9yaW5nSW50ZXJ2YWwpXG4gICAgICB0aGlzLm1vbml0b3JpbmdJbnRlcnZhbCA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5pc01vbml0b3JpbmcgPSBmYWxzZVxuICAgIGNvbnNvbGUubG9nKCdIZWFsdGggbW9uaXRvcmluZyBzdG9wcGVkJylcbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IGhlYWx0aFxuICBnZXRDdXJyZW50SGVhbHRoKCk6IEhlYWx0aFJlc3VsdCB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmhlYWx0aEhpc3RvcnkubGVuZ3RoID4gMCA/IHRoaXMuaGVhbHRoSGlzdG9yeVt0aGlzLmhlYWx0aEhpc3RvcnkubGVuZ3RoIC0gMV0gOiBudWxsXG4gIH1cblxuICAvLyBDaGVjayBpZiBtb25pdG9yaW5nIGlzIGFjdGl2ZVxuICBpc01vbml0b3JpbmdBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNNb25pdG9yaW5nXG4gIH1cblxuICAvLyBHZXQgbW9uaXRvcmluZyBzdGF0dXNcbiAgZ2V0TW9uaXRvcmluZ1N0YXR1cygpOiB7IGlzQWN0aXZlOiBib29sZWFuOyBpbnRlcnZhbDogbnVtYmVyIHwgbnVsbCB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNBY3RpdmU6IHRoaXMuaXNNb25pdG9yaW5nLFxuICAgICAgaW50ZXJ2YWw6IHRoaXMubW9uaXRvcmluZ0ludGVydmFsID8gMzAwMDAgOiBudWxsXG4gICAgfVxuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBoZWFsdGhNb25pdG9yaW5nID0gbmV3IEhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlKClcblxuLy8gRXhwb3J0IHR5cGVzXG5leHBvcnQgdHlwZSB7XG4gIEhlYWx0aENoZWNrQ29uZmlnLFxuICBIZWFsdGhDaGVja1Jlc3VsdCxcbiAgSGVhbHRoSW5kZXhNZXRyaWNzLFxuICBIZWFsdGhTdW1tYXJ5LFxuICBIZWFsdGhSZXN1bHRcbn1cbiJdLCJuYW1lcyI6WyJjb3JyZWxhdGlvbklETWFuYWdlciIsImdldENvcnJlbGF0aW9uSGVhZGVycyIsIkRFRkFVTFRfSEVBTFRIX0NIRUNLUyIsIm5hbWUiLCJlbmRwb2ludCIsInRpbWVvdXQiLCJjcml0aWNhbCIsInJldHJpZXMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfSEVBTFRIX0FQSV9VUkwiLCJleHBlY3RlZFN0YXR1cyIsIm1ldGhvZCIsIkhlYWx0aE1vbml0b3JpbmdTZXJ2aWNlIiwicnVuSGVhbHRoQ2hlY2siLCJjb25maWciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY29ycmVsYXRpb25JZCIsImdldEN1cnJlbnRDb250ZXh0IiwicmVzdWx0IiwicnVuSW50ZXJuYWxIZWFsdGhDaGVjayIsInJ1bkV4dGVybmFsSGVhbHRoQ2hlY2siLCJlcnJvciIsInJlc3BvbnNlVGltZSIsInN0YXR1cyIsIkVycm9yIiwibWVzc2FnZSIsIlN0cmluZyIsInRpbWVzdGFtcCIsInRvSVNPU3RyaW5nIiwic3lzdGVtSW5mbyIsImdldFN5c3RlbUluZm8iLCJkZXRhaWxzIiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsImhlYWRlcnMiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsInN0YXR1c1RleHQiLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImVudHJpZXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsIk1hdGgiLCJwb3ciLCJwbGF0Zm9ybSIsInVzZXJBZ2VudCIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwiY29va2llRW5hYmxlZCIsIm9uTGluZSIsInJ1bkNvbXByZWhlbnNpdmVIZWFsdGhDaGVjayIsImhlYWx0aENoZWNrQ29udGV4dCIsImdlbmVyYXRlQ29udGV4dCIsInVuZGVmaW5lZCIsIm9wZXJhdGlvbiIsInR5cGUiLCJjaGVja1Jlc3VsdHMiLCJjaGVja1Byb21pc2VzIiwibWFwIiwiYWxsU2V0dGxlZCIsInN1bW1hcnkiLCJjYWxjdWxhdGVIZWFsdGhTdW1tYXJ5IiwiZmFpbGVkQ2hlY2tzIiwid2FybmluZ0NoZWNrcyIsIm92ZXJhbGxIZWFsdGgiLCJjaGVja3MiLCJtZXRhZGF0YSIsInNlcnZpY2UiLCJyZWdpb24iLCJpbnN0YW5jZSIsImJ1aWxkIiwiY29tbWl0IiwiaGVhbHRoSGlzdG9yeSIsInB1c2giLCJsZW5ndGgiLCJzbGljZSIsInVwZGF0ZU1ldHJpY3MiLCJsb2dDb250ZXh0IiwiZXJyb3JSZXN1bHQiLCJ0b3RhbENoZWNrcyIsInBhc3NlZENoZWNrcyIsImF2ZXJhZ2VSZXNwb25zZVRpbWUiLCJjbGVhckN1cnJlbnRDb250ZXh0IiwiY2hlY2tBcnJheSIsInZhbHVlcyIsImZpbHRlciIsImMiLCJyZWR1Y2UiLCJzdW0iLCJyb3VuZCIsImhlYWx0aFJlc3VsdCIsIm1ldHJpY3MiLCJvdmVyYWxsU2NvcmUiLCJlcnJvclJhdGUiLCJ1cHRpbWUiLCJsYXN0Q2hlY2siLCJtZXRyaWNzSGlzdG9yeSIsImdldEhlYWx0aEhpc3RvcnkiLCJnZXRNZXRyaWNzSGlzdG9yeSIsInN0YXJ0TW9uaXRvcmluZyIsImludGVydmFsTXMiLCJpc01vbml0b3JpbmciLCJtb25pdG9yaW5nSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNvbnNvbGUiLCJsb2ciLCJzdG9wTW9uaXRvcmluZyIsImNsZWFySW50ZXJ2YWwiLCJnZXRDdXJyZW50SGVhbHRoIiwiaXNNb25pdG9yaW5nQWN0aXZlIiwiZ2V0TW9uaXRvcmluZ1N0YXR1cyIsImlzQWN0aXZlIiwiaW50ZXJ2YWwiLCJoZWFsdGhNb25pdG9yaW5nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/health-monitoring-simple.ts\n"));

/***/ })

});