"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main-app",{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/app-index.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/client/app-index.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hydrate\", ({\n    enumerable: true,\n    get: function() {\n        return hydrate;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n__webpack_require__(/*! ./app-globals */ \"(app-pages-browser)/./node_modules/next/dist/client/app-globals.js\");\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/client.js\"));\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _client1 = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _errorboundarycallbacks = __webpack_require__(/*! ./react-client-callbacks/error-boundary-callbacks */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\");\nconst _appcallserver = __webpack_require__(/*! ./app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ./app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _approuterinstance = __webpack_require__(/*! ./components/app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _approuter = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./components/app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\"));\nconst _createinitialrouterstate = __webpack_require__(/*! ./components/router-reducer/create-initial-router-state */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _appbuildid = __webpack_require__(/*! ./app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\n/// <reference types=\"react-dom/experimental\" />\nconst createFromReadableStream = _client1.createFromReadableStream;\nconst appElement = document;\nconst encoder = new TextEncoder();\nlet initialServerDataBuffer = undefined;\nlet initialServerDataWriter = undefined;\nlet initialServerDataLoaded = false;\nlet initialServerDataFlushed = false;\nlet initialFormStateData = null;\nfunction nextServerDataCallback(seg) {\n    if (seg[0] === 0) {\n        initialServerDataBuffer = [];\n    } else if (seg[0] === 1) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(encoder.encode(seg[1]));\n        } else {\n            initialServerDataBuffer.push(seg[1]);\n        }\n    } else if (seg[0] === 2) {\n        initialFormStateData = seg[1];\n    } else if (seg[0] === 3) {\n        if (!initialServerDataBuffer) throw Object.defineProperty(new Error('Unexpected server data: missing bootstrap script.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E18\",\n            enumerable: false,\n            configurable: true\n        });\n        // Decode the base64 string back to binary data.\n        const binaryString = atob(seg[1]);\n        const decodedChunk = new Uint8Array(binaryString.length);\n        for(var i = 0; i < binaryString.length; i++){\n            decodedChunk[i] = binaryString.charCodeAt(i);\n        }\n        if (initialServerDataWriter) {\n            initialServerDataWriter.enqueue(decodedChunk);\n        } else {\n            initialServerDataBuffer.push(decodedChunk);\n        }\n    }\n}\nfunction isStreamErrorOrUnfinished(ctr) {\n    // If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.\n    return ctr.desiredSize === null || ctr.desiredSize < 0;\n}\n// There might be race conditions between `nextServerDataRegisterWriter` and\n// `DOMContentLoaded`. The former will be called when React starts to hydrate\n// the root, the latter will be called when the DOM is fully loaded.\n// For streaming, the former is called first due to partial hydration.\n// For non-streaming, the latter can be called first.\n// Hence, we use two variables `initialServerDataLoaded` and\n// `initialServerDataFlushed` to make sure the writer will be closed and\n// `initialServerDataBuffer` will be cleared in the right time.\nfunction nextServerDataRegisterWriter(ctr) {\n    if (initialServerDataBuffer) {\n        initialServerDataBuffer.forEach((val)=>{\n            ctr.enqueue(typeof val === 'string' ? encoder.encode(val) : val);\n        });\n        if (initialServerDataLoaded && !initialServerDataFlushed) {\n            if (isStreamErrorOrUnfinished(ctr)) {\n                ctr.error(Object.defineProperty(new Error('The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E117\",\n                    enumerable: false,\n                    configurable: true\n                }));\n            } else {\n                ctr.close();\n            }\n            initialServerDataFlushed = true;\n            initialServerDataBuffer = undefined;\n        }\n    }\n    initialServerDataWriter = ctr;\n}\n// When `DOMContentLoaded`, we can close all pending writers to finish hydration.\nconst DOMContentLoaded = function() {\n    if (initialServerDataWriter && !initialServerDataFlushed) {\n        initialServerDataWriter.close();\n        initialServerDataFlushed = true;\n        initialServerDataBuffer = undefined;\n    }\n    initialServerDataLoaded = true;\n};\n_c = DOMContentLoaded;\n// It's possible that the DOM is already loaded.\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', DOMContentLoaded, false);\n} else {\n    // Delayed in marco task to ensure it's executed later than hydration\n    setTimeout(DOMContentLoaded);\n}\nconst nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];\nnextServerDataLoadingGlobal.forEach(nextServerDataCallback);\nnextServerDataLoadingGlobal.push = nextServerDataCallback;\nconst readable = new ReadableStream({\n    start (controller) {\n        nextServerDataRegisterWriter(controller);\n    }\n});\nconst initialServerResponse = createFromReadableStream(readable, {\n    callServer: _appcallserver.callServer,\n    findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n});\nfunction ServerRoot(param) {\n    let { pendingActionQueue } = param;\n    const initialRSCPayload = (0, _react.use)(initialServerResponse);\n    const actionQueue = (0, _react.use)(pendingActionQueue);\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuter.default, {\n        actionQueue: actionQueue,\n        globalErrorState: initialRSCPayload.G,\n        assetPrefix: initialRSCPayload.p\n    });\n    if ( true && initialRSCPayload.m) {\n        // We provide missing slot information in a context provider only during development\n        // as we log some additional information about the missing slots in the console.\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {\n            value: initialRSCPayload.m,\n            children: router\n        });\n    }\n    return router;\n}\n_c1 = ServerRoot;\nconst StrictModeIfEnabled =  true ? _react.default.StrictMode : 0;\nfunction Root(param) {\n    let { children } = param;\n    if (false) {}\n    return children;\n}\n_c2 = Root;\nfunction onDefaultTransitionIndicator() {\n    // TODO: Compose default with user-configureable (e.g. nprogress)\n    // TODO: Use React's default once we figure out hanging indicators: https://codesandbox.io/p/sandbox/charming-moon-hktkp6?file=%2Fsrc%2Findex.js%3A106%2C30\n    return ()=>{};\n}\nconst reactRootOptions = {\n    onDefaultTransitionIndicator: onDefaultTransitionIndicator,\n    onRecoverableError: _onrecoverableerror.onRecoverableError,\n    onCaughtError: _errorboundarycallbacks.onCaughtError,\n    onUncaughtError: _errorboundarycallbacks.onUncaughtError\n};\nfunction hydrate(instrumentationHooks) {\n    // React overrides `.then` and doesn't return a new promise chain,\n    // so we wrap the action queue in a promise to ensure that its value\n    // is defined when the promise resolves.\n    // https://github.com/facebook/react/blob/163365a07872337e04826c4f501565d43dbd2fd4/packages/react-client/src/ReactFlightClient.js#L189-L190\n    const pendingActionQueue = new Promise((resolve, reject)=>{\n        initialServerResponse.then((initialRSCPayload)=>{\n            // setAppBuildId should be called only once, during JS initialization\n            // and before any components have hydrated.\n            (0, _appbuildid.setAppBuildId)(initialRSCPayload.b);\n            const initialTimestamp = Date.now();\n            resolve((0, _approuterinstance.createMutableActionQueue)((0, _createinitialrouterstate.createInitialRouterState)({\n                navigatedAt: initialTimestamp,\n                initialFlightData: initialRSCPayload.f,\n                initialCanonicalUrlParts: initialRSCPayload.c,\n                initialParallelRoutes: new Map(),\n                location: window.location,\n                couldBeIntercepted: initialRSCPayload.i,\n                postponed: initialRSCPayload.s,\n                prerendered: initialRSCPayload.S\n            }), instrumentationHooks));\n        }, (err)=>reject(err));\n    });\n    const reactEl = /*#__PURE__*/ (0, _jsxruntime.jsx)(StrictModeIfEnabled, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n            value: {\n                appDir: true\n            },\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(ServerRoot, {\n                    pendingActionQueue: pendingActionQueue\n                })\n            })\n        })\n    });\n    if (document.documentElement.id === '__next_error__') {\n        let element = reactEl;\n        // Server rendering failed, fall back to client-side rendering\n        if (true) {\n            const { RootLevelDevOverlayElement } = __webpack_require__(/*! ../next-devtools/userspace/app/client-entry */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/client-entry.js\");\n            // Note this won't cause hydration mismatch because we are doing CSR w/o hydration\n            element = /*#__PURE__*/ (0, _jsxruntime.jsx)(RootLevelDevOverlayElement, {\n                children: element\n            });\n        }\n        _client.default.createRoot(appElement, reactRootOptions).render(element);\n    } else {\n        _react.default.startTransition(()=>{\n            _client.default.hydrateRoot(appElement, reactEl, {\n                ...reactRootOptions,\n                formState: initialFormStateData\n            });\n        });\n    }\n    // TODO-APP: Remove this logic when Float has GC built-in in development.\n    if (true) {\n        const { linkGc } = __webpack_require__(/*! ./app-link-gc */ \"(app-pages-browser)/./node_modules/next/dist/client/app-link-gc.js\");\n        linkGc();\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"DOMContentLoaded\");\n$RefreshReg$(_c1, \"ServerRoot\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FwcC1pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OzJDQWtPZ0JBOzs7ZUFBQUE7Ozs7OztvQkFsT1Q7NkVBQ29COzZFQUNBO3FDQUdpRDs2REFDekM7Z0RBQ0E7b0RBSTVCOzJDQUNvQjtpREFDTTsrQ0FJMUI7Z0ZBQ2U7c0RBRW1COzJEQUNOO3dDQUNMO0FBRTlCLGdEQUFnRDtBQUVoRCxNQUFNQywyQkFDSkMsU0FBQUEsd0JBQStCO0FBRWpDLE1BQU1DLGFBQXFDQztBQUUzQyxNQUFNQyxVQUFVLElBQUlDO0FBRXBCLElBQUlDLDBCQUErREM7QUFDbkUsSUFBSUMsMEJBQ0ZEO0FBQ0YsSUFBSUUsMEJBQTBCO0FBQzlCLElBQUlDLDJCQUEyQjtBQUUvQixJQUFJQyx1QkFBbUM7QUFtQnZDLFNBQVNDLHVCQUF1QkMsR0FBa0I7SUFDaEQsSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ2hCUCwwQkFBMEIsRUFBRTtJQUM5QixPQUFPLElBQUlPLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRztRQUN2QixJQUFJLENBQUNQLHlCQUNILE1BQU0scUJBQThELENBQTlELElBQUlRLE1BQU0sc0RBQVY7bUJBQUE7d0JBQUE7MEJBQUE7UUFBNkQ7UUFFckUsSUFBSU4seUJBQXlCO1lBQzNCQSx3QkFBd0JPLE9BQU8sQ0FBQ1gsUUFBUVksTUFBTSxDQUFDSCxHQUFHLENBQUMsRUFBRTtRQUN2RCxPQUFPO1lBQ0xQLHdCQUF3QlcsSUFBSSxDQUFDSixHQUFHLENBQUMsRUFBRTtRQUNyQztJQUNGLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCRix1QkFBdUJFLEdBQUcsQ0FBQyxFQUFFO0lBQy9CLE9BQU8sSUFBSUEsR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHO1FBQ3ZCLElBQUksQ0FBQ1AseUJBQ0gsTUFBTSxxQkFBOEQsQ0FBOUQsSUFBSVEs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bnQvYXBwLWluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vYXBwLWdsb2JhbHMnXG5pbXBvcnQgUmVhY3RET01DbGllbnQgZnJvbSAncmVhY3QtZG9tL2NsaWVudCdcbmltcG9ydCBSZWFjdCwgeyB1c2UgfSBmcm9tICdyZWFjdCdcbi8vIFRPRE86IEV4cGxpY2l0bHkgaW1wb3J0IGZyb20gY2xpZW50LmJyb3dzZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcbmltcG9ydCB7IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSBhcyBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIH0gZnJvbSAncmVhY3Qtc2VydmVyLWRvbS13ZWJwYWNrL2NsaWVudCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBvblJlY292ZXJhYmxlRXJyb3IgfSBmcm9tICcuL3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3InXG5pbXBvcnQge1xuICBvbkNhdWdodEVycm9yLFxuICBvblVuY2F1Z2h0RXJyb3IsXG59IGZyb20gJy4vcmVhY3QtY2xpZW50LWNhbGxiYWNrcy9lcnJvci1ib3VuZGFyeS1jYWxsYmFja3MnXG5pbXBvcnQgeyBjYWxsU2VydmVyIH0gZnJvbSAnLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgeyBmaW5kU291cmNlTWFwVVJMIH0gZnJvbSAnLi9hcHAtZmluZC1zb3VyY2UtbWFwLXVybCdcbmltcG9ydCB7XG4gIHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSxcbn0gZnJvbSAnLi9jb21wb25lbnRzL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgQXBwUm91dGVyIGZyb20gJy4vY29tcG9uZW50cy9hcHAtcm91dGVyJ1xuaW1wb3J0IHR5cGUgeyBJbml0aWFsUlNDUGF5bG9hZCB9IGZyb20gJy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIH0gZnJvbSAnLi9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1pbml0aWFsLXJvdXRlci1zdGF0ZSdcbmltcG9ydCB7IE1pc3NpbmdTbG90Q29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgc2V0QXBwQnVpbGRJZCB9IGZyb20gJy4vYXBwLWJ1aWxkLWlkJ1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuXG5jb25zdCBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gPVxuICBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSddXG5cbmNvbnN0IGFwcEVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgRG9jdW1lbnQgPSBkb2N1bWVudFxuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyOiAoc3RyaW5nIHwgVWludDhBcnJheSlbXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHwgdW5kZWZpbmVkID1cbiAgdW5kZWZpbmVkXG5sZXQgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgPSBmYWxzZVxubGV0IGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZCA9IGZhbHNlXG5cbmxldCBpbml0aWFsRm9ybVN0YXRlRGF0YTogbnVsbCB8IGFueSA9IG51bGxcblxudHlwZSBGbGlnaHRTZWdtZW50ID1cbiAgfCBbaXNCb290U3RyYXA6IDBdXG4gIHwgW2lzTm90Qm9vdHN0cmFwOiAxLCByZXNwb25zZVBhcnRpYWw6IHN0cmluZ11cbiAgfCBbaXNGb3JtU3RhdGU6IDIsIGZvcm1TdGF0ZTogYW55XVxuICB8IFtpc0JpbmFyeTogMywgcmVzcG9uc2VCYXNlNjRQYXJ0aWFsOiBzdHJpbmddXG5cbnR5cGUgTmV4dEZsaWdodCA9IE9taXQ8QXJyYXk8RmxpZ2h0U2VnbWVudD4sICdwdXNoJz4gJiB7XG4gIHB1c2g6IChzZWc6IEZsaWdodFNlZ21lbnQpID0+IHZvaWRcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICAvLyBJZiB5b3UncmUgd29ya2luZyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19uZXh0X2Y6IE5leHRGbGlnaHRcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0U2VydmVyRGF0YUNhbGxiYWNrKHNlZzogRmxpZ2h0U2VnbWVudCk6IHZvaWQge1xuICBpZiAoc2VnWzBdID09PSAwKSB7XG4gICAgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIgPSBbXVxuICB9IGVsc2UgaWYgKHNlZ1swXSA9PT0gMSkge1xuICAgIGlmICghaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2VydmVyIGRhdGE6IG1pc3NpbmcgYm9vdHN0cmFwIHNjcmlwdC4nKVxuXG4gICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyKSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKHNlZ1sxXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyLnB1c2goc2VnWzFdKVxuICAgIH1cbiAgfSBlbHNlIGlmIChzZWdbMF0gPT09IDIpIHtcbiAgICBpbml0aWFsRm9ybVN0YXRlRGF0YSA9IHNlZ1sxXVxuICB9IGVsc2UgaWYgKHNlZ1swXSA9PT0gMykge1xuICAgIGlmICghaW5pdGlhbFNlcnZlckRhdGFCdWZmZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgc2VydmVyIGRhdGE6IG1pc3NpbmcgYm9vdHN0cmFwIHNjcmlwdC4nKVxuXG4gICAgLy8gRGVjb2RlIHRoZSBiYXNlNjQgc3RyaW5nIGJhY2sgdG8gYmluYXJ5IGRhdGEuXG4gICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihzZWdbMV0pXG4gICAgY29uc3QgZGVjb2RlZENodW5rID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVjb2RlZENodW5rW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSlcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbFNlcnZlckRhdGFXcml0ZXIpIHtcbiAgICAgIGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyLmVucXVldWUoZGVjb2RlZENodW5rKVxuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlci5wdXNoKGRlY29kZWRDaHVuaylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdHJlYW1FcnJvck9yVW5maW5pc2hlZChjdHI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpIHtcbiAgLy8gSWYgYGRlc2lyZWRTaXplYCBpcyBudWxsLCBpdCBtZWFucyB0aGUgc3RyZWFtIGlzIGNsb3NlZCBvciBlcnJvcmVkLiBJZiBpdCBpcyBsb3dlciB0aGFuIDAsIHRoZSBzdHJlYW0gaXMgc3RpbGwgdW5maW5pc2hlZC5cbiAgcmV0dXJuIGN0ci5kZXNpcmVkU2l6ZSA9PT0gbnVsbCB8fCBjdHIuZGVzaXJlZFNpemUgPCAwXG59XG5cbi8vIFRoZXJlIG1pZ2h0IGJlIHJhY2UgY29uZGl0aW9ucyBiZXR3ZWVuIGBuZXh0U2VydmVyRGF0YVJlZ2lzdGVyV3JpdGVyYCBhbmRcbi8vIGBET01Db250ZW50TG9hZGVkYC4gVGhlIGZvcm1lciB3aWxsIGJlIGNhbGxlZCB3aGVuIFJlYWN0IHN0YXJ0cyB0byBoeWRyYXRlXG4vLyB0aGUgcm9vdCwgdGhlIGxhdHRlciB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBET00gaXMgZnVsbHkgbG9hZGVkLlxuLy8gRm9yIHN0cmVhbWluZywgdGhlIGZvcm1lciBpcyBjYWxsZWQgZmlyc3QgZHVlIHRvIHBhcnRpYWwgaHlkcmF0aW9uLlxuLy8gRm9yIG5vbi1zdHJlYW1pbmcsIHRoZSBsYXR0ZXIgY2FuIGJlIGNhbGxlZCBmaXJzdC5cbi8vIEhlbmNlLCB3ZSB1c2UgdHdvIHZhcmlhYmxlcyBgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWRgIGFuZFxuLy8gYGluaXRpYWxTZXJ2ZXJEYXRhRmx1c2hlZGAgdG8gbWFrZSBzdXJlIHRoZSB3cml0ZXIgd2lsbCBiZSBjbG9zZWQgYW5kXG4vLyBgaW5pdGlhbFNlcnZlckRhdGFCdWZmZXJgIHdpbGwgYmUgY2xlYXJlZCBpbiB0aGUgcmlnaHQgdGltZS5cbmZ1bmN0aW9uIG5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXIoY3RyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKSB7XG4gIGlmIChpbml0aWFsU2VydmVyRGF0YUJ1ZmZlcikge1xuICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgY3RyLmVucXVldWUodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBlbmNvZGVyLmVuY29kZSh2YWwpIDogdmFsKVxuICAgIH0pXG4gICAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhTG9hZGVkICYmICFpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQpIHtcbiAgICAgIGlmIChpc1N0cmVhbUVycm9yT3JVbmZpbmlzaGVkKGN0cikpIHtcbiAgICAgICAgY3RyLmVycm9yKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgY29ubmVjdGlvbiB0byB0aGUgcGFnZSB3YXMgdW5leHBlY3RlZGx5IGNsb3NlZCwgcG9zc2libHkgZHVlIHRvIHRoZSBzdG9wIGJ1dHRvbiBiZWluZyBjbGlja2VkLCBsb3NzIG9mIFdpLUZpLCBvciBhbiB1bnN0YWJsZSBpbnRlcm5ldCBjb25uZWN0aW9uLidcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0ci5jbG9zZSgpXG4gICAgICB9XG4gICAgICBpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQgPSB0cnVlXG4gICAgICBpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyID0gY3RyXG59XG5cbi8vIFdoZW4gYERPTUNvbnRlbnRMb2FkZWRgLCB3ZSBjYW4gY2xvc2UgYWxsIHBlbmRpbmcgd3JpdGVycyB0byBmaW5pc2ggaHlkcmF0aW9uLlxuY29uc3QgRE9NQ29udGVudExvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyICYmICFpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQpIHtcbiAgICBpbml0aWFsU2VydmVyRGF0YVdyaXRlci5jbG9zZSgpXG4gICAgaW5pdGlhbFNlcnZlckRhdGFGbHVzaGVkID0gdHJ1ZVxuICAgIGluaXRpYWxTZXJ2ZXJEYXRhQnVmZmVyID0gdW5kZWZpbmVkXG4gIH1cbiAgaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQgPSB0cnVlXG59XG5cbi8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgRE9NIGlzIGFscmVhZHkgbG9hZGVkLlxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgRE9NQ29udGVudExvYWRlZCwgZmFsc2UpXG59IGVsc2Uge1xuICAvLyBEZWxheWVkIGluIG1hcmNvIHRhc2sgdG8gZW5zdXJlIGl0J3MgZXhlY3V0ZWQgbGF0ZXIgdGhhbiBoeWRyYXRpb25cbiAgc2V0VGltZW91dChET01Db250ZW50TG9hZGVkKVxufVxuXG5jb25zdCBuZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwgPSAoc2VsZi5fX25leHRfZiA9IHNlbGYuX19uZXh0X2YgfHwgW10pXG5uZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwuZm9yRWFjaChuZXh0U2VydmVyRGF0YUNhbGxiYWNrKVxubmV4dFNlcnZlckRhdGFMb2FkaW5nR2xvYmFsLnB1c2ggPSBuZXh0U2VydmVyRGF0YUNhbGxiYWNrXG5cbmNvbnN0IHJlYWRhYmxlID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgc3RhcnQoY29udHJvbGxlcikge1xuICAgIG5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXIoY29udHJvbGxlcilcbiAgfSxcbn0pXG5cbmNvbnN0IGluaXRpYWxTZXJ2ZXJSZXNwb25zZSA9IGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbTxJbml0aWFsUlNDUGF5bG9hZD4oXG4gIHJlYWRhYmxlLFxuICB7IGNhbGxTZXJ2ZXIsIGZpbmRTb3VyY2VNYXBVUkwgfVxuKVxuXG5mdW5jdGlvbiBTZXJ2ZXJSb290KHtcbiAgcGVuZGluZ0FjdGlvblF1ZXVlLFxufToge1xuICBwZW5kaW5nQWN0aW9uUXVldWU6IFByb21pc2U8QXBwUm91dGVyQWN0aW9uUXVldWU+XG59KTogUmVhY3QuUmVhY3ROb2RlIHtcbiAgY29uc3QgaW5pdGlhbFJTQ1BheWxvYWQgPSB1c2UoaW5pdGlhbFNlcnZlclJlc3BvbnNlKVxuICBjb25zdCBhY3Rpb25RdWV1ZSA9IHVzZTxBcHBSb3V0ZXJBY3Rpb25RdWV1ZT4ocGVuZGluZ0FjdGlvblF1ZXVlKVxuXG4gIGNvbnN0IHJvdXRlciA9IChcbiAgICA8QXBwUm91dGVyXG4gICAgICBhY3Rpb25RdWV1ZT17YWN0aW9uUXVldWV9XG4gICAgICBnbG9iYWxFcnJvclN0YXRlPXtpbml0aWFsUlNDUGF5bG9hZC5HfVxuICAgICAgYXNzZXRQcmVmaXg9e2luaXRpYWxSU0NQYXlsb2FkLnB9XG4gICAgLz5cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBpbml0aWFsUlNDUGF5bG9hZC5tKSB7XG4gICAgLy8gV2UgcHJvdmlkZSBtaXNzaW5nIHNsb3QgaW5mb3JtYXRpb24gaW4gYSBjb250ZXh0IHByb3ZpZGVyIG9ubHkgZHVyaW5nIGRldmVsb3BtZW50XG4gICAgLy8gYXMgd2UgbG9nIHNvbWUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWlzc2luZyBzbG90cyBpbiB0aGUgY29uc29sZS5cbiAgICByZXR1cm4gKFxuICAgICAgPE1pc3NpbmdTbG90Q29udGV4dCB2YWx1ZT17aW5pdGlhbFJTQ1BheWxvYWQubX0+XG4gICAgICAgIHtyb3V0ZXJ9XG4gICAgICA8L01pc3NpbmdTbG90Q29udGV4dD5cbiAgICApXG4gIH1cblxuICByZXR1cm4gcm91dGVyXG59XG5cbmNvbnN0IFN0cmljdE1vZGVJZkVuYWJsZWQgPSBwcm9jZXNzLmVudi5fX05FWFRfU1RSSUNUX01PREVfQVBQXG4gID8gUmVhY3QuU3RyaWN0TW9kZVxuICA6IFJlYWN0LkZyYWdtZW50XG5cbmZ1bmN0aW9uIFJvb3QoeyBjaGlsZHJlbiB9OiBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7fT4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWVcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQVQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQj8uKClcbiAgICB9LCBbXSlcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlblxufVxuXG5mdW5jdGlvbiBvbkRlZmF1bHRUcmFuc2l0aW9uSW5kaWNhdG9yKCkge1xuICAvLyBUT0RPOiBDb21wb3NlIGRlZmF1bHQgd2l0aCB1c2VyLWNvbmZpZ3VyZWFibGUgKGUuZy4gbnByb2dyZXNzKVxuICAvLyBUT0RPOiBVc2UgUmVhY3QncyBkZWZhdWx0IG9uY2Ugd2UgZmlndXJlIG91dCBoYW5naW5nIGluZGljYXRvcnM6IGh0dHBzOi8vY29kZXNhbmRib3guaW8vcC9zYW5kYm94L2NoYXJtaW5nLW1vb24taGt0a3A2P2ZpbGU9JTJGc3JjJTJGaW5kZXguanMlM0ExMDYlMkMzMFxuICByZXR1cm4gKCkgPT4ge31cbn1cblxuY29uc3QgcmVhY3RSb290T3B0aW9uczogUmVhY3RET01DbGllbnQuUm9vdE9wdGlvbnMgPSB7XG4gIG9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3I6IG9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3IsXG4gIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgb25DYXVnaHRFcnJvcixcbiAgb25VbmNhdWdodEVycm9yLFxufVxuXG5leHBvcnQgdHlwZSBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyA9IHtcbiAgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQ/OiAoXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgbmF2aWdhdGlvblR5cGU6ICdwdXNoJyB8ICdyZXBsYWNlJyB8ICd0cmF2ZXJzZSdcbiAgKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKFxuICBpbnN0cnVtZW50YXRpb25Ib29rczogQ2xpZW50SW5zdHJ1bWVudGF0aW9uSG9va3MgfCBudWxsXG4pIHtcbiAgLy8gUmVhY3Qgb3ZlcnJpZGVzIGAudGhlbmAgYW5kIGRvZXNuJ3QgcmV0dXJuIGEgbmV3IHByb21pc2UgY2hhaW4sXG4gIC8vIHNvIHdlIHdyYXAgdGhlIGFjdGlvbiBxdWV1ZSBpbiBhIHByb21pc2UgdG8gZW5zdXJlIHRoYXQgaXRzIHZhbHVlXG4gIC8vIGlzIGRlZmluZWQgd2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvMTYzMzY1YTA3ODcyMzM3ZTA0ODI2YzRmNTAxNTY1ZDQzZGJkMmZkNC9wYWNrYWdlcy9yZWFjdC1jbGllbnQvc3JjL1JlYWN0RmxpZ2h0Q2xpZW50LmpzI0wxODktTDE5MFxuICBjb25zdCBwZW5kaW5nQWN0aW9uUXVldWU6IFByb21pc2U8QXBwUm91dGVyQWN0aW9uUXVldWU+ID0gbmV3IFByb21pc2UoXG4gICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaW5pdGlhbFNlcnZlclJlc3BvbnNlLnRoZW4oXG4gICAgICAgIChpbml0aWFsUlNDUGF5bG9hZCkgPT4ge1xuICAgICAgICAgIC8vIHNldEFwcEJ1aWxkSWQgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UsIGR1cmluZyBKUyBpbml0aWFsaXphdGlvblxuICAgICAgICAgIC8vIGFuZCBiZWZvcmUgYW55IGNvbXBvbmVudHMgaGF2ZSBoeWRyYXRlZC5cbiAgICAgICAgICBzZXRBcHBCdWlsZElkKGluaXRpYWxSU0NQYXlsb2FkLmIpXG5cbiAgICAgICAgICBjb25zdCBpbml0aWFsVGltZXN0YW1wID0gRGF0ZS5ub3coKVxuXG4gICAgICAgICAgcmVzb2x2ZShcbiAgICAgICAgICAgIGNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZShcbiAgICAgICAgICAgICAgY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlKHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZWRBdDogaW5pdGlhbFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBpbml0aWFsRmxpZ2h0RGF0YTogaW5pdGlhbFJTQ1BheWxvYWQuZixcbiAgICAgICAgICAgICAgICBpbml0aWFsQ2Fub25pY2FsVXJsUGFydHM6IGluaXRpYWxSU0NQYXlsb2FkLmMsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGluaXRpYWxSU0NQYXlsb2FkLmksXG4gICAgICAgICAgICAgICAgcG9zdHBvbmVkOiBpbml0aWFsUlNDUGF5bG9hZC5zLFxuICAgICAgICAgICAgICAgIHByZXJlbmRlcmVkOiBpbml0aWFsUlNDUGF5bG9hZC5TLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaW5zdHJ1bWVudGF0aW9uSG9va3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIH0sXG4gICAgICAgIChlcnI6IEVycm9yKSA9PiByZWplY3QoZXJyKVxuICAgICAgKVxuICAgIH1cbiAgKVxuXG4gIGNvbnN0IHJlYWN0RWwgPSAoXG4gICAgPFN0cmljdE1vZGVJZkVuYWJsZWQ+XG4gICAgICA8SGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGFwcERpcjogdHJ1ZSB9fT5cbiAgICAgICAgPFJvb3Q+XG4gICAgICAgICAgPFNlcnZlclJvb3QgcGVuZGluZ0FjdGlvblF1ZXVlPXtwZW5kaW5nQWN0aW9uUXVldWV9IC8+XG4gICAgICAgIDwvUm9vdD5cbiAgICAgIDwvSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvU3RyaWN0TW9kZUlmRW5hYmxlZD5cbiAgKVxuXG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaWQgPT09ICdfX25leHRfZXJyb3JfXycpIHtcbiAgICBsZXQgZWxlbWVudCA9IHJlYWN0RWxcbiAgICAvLyBTZXJ2ZXIgcmVuZGVyaW5nIGZhaWxlZCwgZmFsbCBiYWNrIHRvIGNsaWVudC1zaWRlIHJlbmRlcmluZ1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB7IFJvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50IH0gPVxuICAgICAgICByZXF1aXJlKCcuLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvY2xpZW50LWVudHJ5JykgYXMgdHlwZW9mIGltcG9ydCgnLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2NsaWVudC1lbnRyeScpXG5cbiAgICAgIC8vIE5vdGUgdGhpcyB3b24ndCBjYXVzZSBoeWRyYXRpb24gbWlzbWF0Y2ggYmVjYXVzZSB3ZSBhcmUgZG9pbmcgQ1NSIHcvbyBoeWRyYXRpb25cbiAgICAgIGVsZW1lbnQgPSAoXG4gICAgICAgIDxSb290TGV2ZWxEZXZPdmVybGF5RWxlbWVudD57ZWxlbWVudH08L1Jvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50PlxuICAgICAgKVxuICAgIH1cblxuICAgIFJlYWN0RE9NQ2xpZW50LmNyZWF0ZVJvb3QoYXBwRWxlbWVudCwgcmVhY3RSb290T3B0aW9ucykucmVuZGVyKGVsZW1lbnQpXG4gIH0gZWxzZSB7XG4gICAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIFJlYWN0RE9NQ2xpZW50Lmh5ZHJhdGVSb290KGFwcEVsZW1lbnQsIHJlYWN0RWwsIHtcbiAgICAgICAgLi4ucmVhY3RSb290T3B0aW9ucyxcbiAgICAgICAgZm9ybVN0YXRlOiBpbml0aWFsRm9ybVN0YXRlRGF0YSxcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIFRPRE8tQVBQOiBSZW1vdmUgdGhpcyBsb2dpYyB3aGVuIEZsb2F0IGhhcyBHQyBidWlsdC1pbiBpbiBkZXZlbG9wbWVudC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IGxpbmtHYyB9ID1cbiAgICAgIHJlcXVpcmUoJy4vYXBwLWxpbmstZ2MnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL2FwcC1saW5rLWdjJylcbiAgICBsaW5rR2MoKVxuICB9XG59XG4iXSwibmFtZXMiOlsiaHlkcmF0ZSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbUJyb3dzZXIiLCJhcHBFbGVtZW50IiwiZG9jdW1lbnQiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJpbml0aWFsU2VydmVyRGF0YUJ1ZmZlciIsInVuZGVmaW5lZCIsImluaXRpYWxTZXJ2ZXJEYXRhV3JpdGVyIiwiaW5pdGlhbFNlcnZlckRhdGFMb2FkZWQiLCJpbml0aWFsU2VydmVyRGF0YUZsdXNoZWQiLCJpbml0aWFsRm9ybVN0YXRlRGF0YSIsIm5leHRTZXJ2ZXJEYXRhQ2FsbGJhY2siLCJzZWciLCJFcnJvciIsImVucXVldWUiLCJlbmNvZGUiLCJwdXNoIiwiYmluYXJ5U3RyaW5nIiwiYXRvYiIsImRlY29kZWRDaHVuayIsIlVpbnQ4QXJyYXkiLCJsZW5ndGgiLCJpIiwiY2hhckNvZGVBdCIsImlzU3RyZWFtRXJyb3JPclVuZmluaXNoZWQiLCJjdHIiLCJkZXNpcmVkU2l6ZSIsIm5leHRTZXJ2ZXJEYXRhUmVnaXN0ZXJXcml0ZXIiLCJmb3JFYWNoIiwidmFsIiwiZXJyb3IiLCJjbG9zZSIsIkRPTUNvbnRlbnRMb2FkZWQiLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldFRpbWVvdXQiLCJuZXh0U2VydmVyRGF0YUxvYWRpbmdHbG9iYWwiLCJzZWxmIiwiX19uZXh0X2YiLCJyZWFkYWJsZSIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyIiwiaW5pdGlhbFNlcnZlclJlc3BvbnNlIiwiY2FsbFNlcnZlciIsImZpbmRTb3VyY2VNYXBVUkwiLCJTZXJ2ZXJSb290IiwicGVuZGluZ0FjdGlvblF1ZXVlIiwiaW5pdGlhbFJTQ1BheWxvYWQiLCJ1c2UiLCJhY3Rpb25RdWV1ZSIsInJvdXRlciIsIkFwcFJvdXRlciIsImdsb2JhbEVycm9yU3RhdGUiLCJHIiwiYXNzZXRQcmVmaXgiLCJwIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwibSIsIk1pc3NpbmdTbG90Q29udGV4dCIsInZhbHVlIiwiU3RyaWN0TW9kZUlmRW5hYmxlZCIsIl9fTkVYVF9TVFJJQ1RfTU9ERV9BUFAiLCJSZWFjdCIsIlN0cmljdE1vZGUiLCJGcmFnbWVudCIsIlJvb3QiLCJjaGlsZHJlbiIsIl9fTkVYVF9URVNUX01PREUiLCJ1c2VFZmZlY3QiLCJ3aW5kb3ciLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQVQiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIl9fTkVYVF9IWURSQVRFRF9DQiIsIm9uRGVmYXVsdFRyYW5zaXRpb25JbmRpY2F0b3IiLCJyZWFjdFJvb3RPcHRpb25zIiwib25SZWNvdmVyYWJsZUVycm9yIiwib25DYXVnaHRFcnJvciIsIm9uVW5jYXVnaHRFcnJvciIsImluc3RydW1lbnRhdGlvbkhvb2tzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJ0aGVuIiwic2V0QXBwQnVpbGRJZCIsImIiLCJpbml0aWFsVGltZXN0YW1wIiwiRGF0ZSIsImNyZWF0ZU11dGFibGVBY3Rpb25RdWV1ZSIsImNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSIsIm5hdmlnYXRlZEF0IiwiaW5pdGlhbEZsaWdodERhdGEiLCJmIiwiaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzIiwiYyIsImluaXRpYWxQYXJhbGxlbFJvdXRlcyIsIk1hcCIsImxvY2F0aW9uIiwiY291bGRCZUludGVyY2VwdGVkIiwicG9zdHBvbmVkIiwicyIsInByZXJlbmRlcmVkIiwiUyIsImVyciIsInJlYWN0RWwiLCJIZWFkTWFuYWdlckNvbnRleHQiLCJQcm92aWRlciIsImFwcERpciIsImRvY3VtZW50RWxlbWVudCIsImlkIiwiZWxlbWVudCIsIlJvb3RMZXZlbERldk92ZXJsYXlFbGVtZW50IiwicmVxdWlyZSIsIlJlYWN0RE9NQ2xpZW50IiwiY3JlYXRlUm9vdCIsInJlbmRlciIsInN0YXJ0VHJhbnNpdGlvbiIsImh5ZHJhdGVSb290IiwiZm9ybVN0YXRlIiwibGlua0djIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-instance.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createMutableActionQueue: function() {\n        return createMutableActionQueue;\n    },\n    dispatchNavigateAction: function() {\n        return dispatchNavigateAction;\n    },\n    dispatchTraverseAction: function() {\n        return dispatchTraverseAction;\n    },\n    getCurrentAppRouterState: function() {\n        return getCurrentAppRouterState;\n    },\n    publicAppRouterInstance: function() {\n        return publicAppRouterInstance;\n    }\n});\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _routerreducer = __webpack_require__(/*! ./router-reducer/router-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _isthenable = __webpack_require__(/*! ../../shared/lib/is-thenable */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/is-thenable.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-action-queue.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _approuter = __webpack_require__(/*! ./app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./router-reducer/reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nfunction runRemainingActions(actionQueue, setState) {\n    if (actionQueue.pending !== null) {\n        actionQueue.pending = actionQueue.pending.next;\n        if (actionQueue.pending !== null) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            runAction({\n                actionQueue,\n                action: actionQueue.pending,\n                setState\n            });\n        } else {\n            // No more actions are pending, check if a refresh is needed\n            if (actionQueue.needsRefresh) {\n                actionQueue.needsRefresh = false;\n                actionQueue.dispatch({\n                    type: _routerreducertypes.ACTION_REFRESH,\n                    origin: window.location.origin\n                }, setState);\n            }\n        }\n    }\n}\nasync function runAction(param) {\n    let { actionQueue, action, setState } = param;\n    const prevState = actionQueue.state;\n    actionQueue.pending = action;\n    const payload = action.payload;\n    const actionResult = actionQueue.action(prevState, payload);\n    function handleResult(nextState) {\n        // if we discarded this action, the state should also be discarded\n        if (action.discarded) {\n            return;\n        }\n        actionQueue.state = nextState;\n        runRemainingActions(actionQueue, setState);\n        action.resolve(nextState);\n    }\n    // if the action is a promise, set up a callback to resolve it\n    if ((0, _isthenable.isThenable)(actionResult)) {\n        actionResult.then(handleResult, (err)=>{\n            runRemainingActions(actionQueue, setState);\n            action.reject(err);\n        });\n    } else {\n        handleResult(actionResult);\n    }\n}\nfunction dispatchAction(actionQueue, payload, setState) {\n    let resolvers = {\n        resolve: setState,\n        reject: ()=>{}\n    };\n    // most of the action types are async with the exception of restore\n    // it's important that restore is handled quickly since it's fired on the popstate event\n    // and we don't want to add any delay on a back/forward nav\n    // this only creates a promise for the async actions\n    if (payload.type !== _routerreducertypes.ACTION_RESTORE) {\n        // Create the promise and assign the resolvers to the object.\n        const deferredPromise = new Promise((resolve, reject)=>{\n            resolvers = {\n                resolve,\n                reject\n            };\n        });\n        (0, _react.startTransition)(()=>{\n            // we immediately notify React of the pending promise -- the resolver is attached to the action node\n            // and will be called when the associated action promise resolves\n            setState(deferredPromise);\n        });\n    }\n    const newAction = {\n        payload,\n        next: null,\n        resolve: resolvers.resolve,\n        reject: resolvers.reject\n    };\n    // Check if the queue is empty\n    if (actionQueue.pending === null) {\n        // The queue is empty, so add the action and start it immediately\n        // Mark this action as the last in the queue\n        actionQueue.last = newAction;\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else if (payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {\n        // Navigations (including back/forward) take priority over any pending actions.\n        // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n        actionQueue.pending.discarded = true;\n        // The rest of the current queue should still execute after this navigation.\n        // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n        newAction.next = actionQueue.pending.next;\n        // if the pending action was a server action, mark the queue as needing a refresh once events are processed\n        if (actionQueue.pending.payload.type === _routerreducertypes.ACTION_SERVER_ACTION) {\n            actionQueue.needsRefresh = true;\n        }\n        runAction({\n            actionQueue,\n            action: newAction,\n            setState\n        });\n    } else {\n        // The queue is not empty, so add the action to the end of the queue\n        // It will be started by runRemainingActions after the previous action finishes\n        if (actionQueue.last !== null) {\n            actionQueue.last.next = newAction;\n        }\n        actionQueue.last = newAction;\n    }\n}\nlet globalActionQueue = null;\nfunction createMutableActionQueue(initialState, instrumentationHooks) {\n    const actionQueue = {\n        state: initialState,\n        dispatch: (payload, setState)=>dispatchAction(actionQueue, payload, setState),\n        action: async (state, action)=>{\n            const result = (0, _routerreducer.reducer)(state, action);\n            return result;\n        },\n        pending: null,\n        last: null,\n        onRouterTransitionStart: instrumentationHooks !== null && typeof instrumentationHooks.onRouterTransitionStart === 'function' ? instrumentationHooks.onRouterTransitionStart : null\n    };\n    if (true) {\n        // The action queue is lazily created on hydration, but after that point\n        // it doesn't change. So we can store it in a global rather than pass\n        // it around everywhere via props/context.\n        if (globalActionQueue !== null) {\n            throw Object.defineProperty(new Error('Internal Next.js Error: createMutableActionQueue was called more ' + 'than once'), \"__NEXT_ERROR_CODE\", {\n                value: \"E624\",\n                enumerable: false,\n                configurable: true\n            });\n        }\n        globalActionQueue = actionQueue;\n    }\n    return actionQueue;\n}\nfunction getCurrentAppRouterState() {\n    return globalActionQueue !== null ? globalActionQueue.state : null;\n}\nfunction getAppRouterActionQueue() {\n    if (globalActionQueue === null) {\n        throw Object.defineProperty(new Error('Internal Next.js error: Router action dispatched before initialization.'), \"__NEXT_ERROR_CODE\", {\n            value: \"E668\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    return globalActionQueue;\n}\nfunction getProfilingHookForOnNavigationStart() {\n    if (globalActionQueue !== null) {\n        return globalActionQueue.onRouterTransitionStart;\n    }\n    return null;\n}\nfunction dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {\n    // TODO: This stuff could just go into the reducer. Leaving as-is for now\n    // since we're about to rewrite all the router reducer stuff anyway.\n    const url = new URL((0, _addbasepath.addBasePath)(href), location.href);\n    if (false) {}\n    (0, _links.setLinkForCurrentNavigation)(linkInstanceRef);\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, navigateType);\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_NAVIGATE,\n        url,\n        isExternalUrl: (0, _approuter.isExternalURL)(url),\n        locationSearch: location.search,\n        shouldScroll,\n        navigateType,\n        allowAliasing: true\n    });\n}\nfunction dispatchTraverseAction(href, tree) {\n    const onRouterTransitionStart = getProfilingHookForOnNavigationStart();\n    if (onRouterTransitionStart !== null) {\n        onRouterTransitionStart(href, 'traverse');\n    }\n    (0, _useactionqueue.dispatchAppRouterAction)({\n        type: _routerreducertypes.ACTION_RESTORE,\n        url: new URL(href),\n        tree\n    });\n}\nconst publicAppRouterInstance = {\n    back: ()=>window.history.back(),\n    forward: ()=>window.history.forward(),\n    prefetch:  false ? // cache. So we don't need to dispatch an action.\n    0 : (href, options)=>{\n        // Use the old prefetch implementation.\n        const actionQueue = getAppRouterActionQueue();\n        const url = (0, _approuter.createPrefetchURL)(href);\n        if (url !== null) {\n            var _options_kind;\n            // The prefetch reducer doesn't actually update any state or\n            // trigger a rerender. It just writes to a mutable cache. So we\n            // shouldn't bother calling setState/dispatch; we can just re-run\n            // the reducer directly using the current state.\n            // TODO: Refactor this away from a \"reducer\" so it's\n            // less confusing.\n            (0, _prefetchreducer.prefetchReducer)(actionQueue.state, {\n                type: _routerreducertypes.ACTION_PREFETCH,\n                url,\n                kind: (_options_kind = options == null ? void 0 : options.kind) != null ? _options_kind : _routerreducertypes.PrefetchKind.FULL\n            });\n        }\n    },\n    replace: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            var _options_scroll;\n            dispatchNavigateAction(href, 'replace', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);\n        });\n    },\n    push: (href, options)=>{\n        (0, _react.startTransition)(()=>{\n            var _options_scroll;\n            dispatchNavigateAction(href, 'push', (_options_scroll = options == null ? void 0 : options.scroll) != null ? _options_scroll : true, null);\n        });\n    },\n    refresh: ()=>{\n        (0, _react.startTransition)(()=>{\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_REFRESH,\n                origin: window.location.origin\n            });\n        });\n    },\n    hmrRefresh: ()=>{\n        if (false) {} else {\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_HMR_REFRESH,\n                    origin: window.location.origin\n                });\n            });\n        }\n    }\n};\n// Exists for debugging purposes. Don't use in application code.\nif ( true && window.next) {\n    window.next.router = publicAppRouterInstance;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-instance.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1pbnN0YW5jZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFtTmdCQSx3QkFBd0I7ZUFBeEJBOztJQTBEQUMsc0JBQXNCO2VBQXRCQTs7SUErQkFDLHNCQUFzQjtlQUF0QkE7O0lBbkRBQyx3QkFBd0I7ZUFBeEJBOztJQXVFSEMsdUJBQXVCO2VBQXZCQTs7O2dEQXBUTjsyQ0FDaUI7bUNBQ1E7d0NBQ0w7MENBS3BCOzRDQUNpQzt5Q0FDWjt1Q0FDcUI7NkNBQ2pCO21DQU0rQjtBQWtDL0QsU0FBU0Msb0JBQ1BDLFdBQWlDLEVBQ2pDQyxRQUE4QjtJQUU5QixJQUFJRCxZQUFZRSxPQUFPLEtBQUssTUFBTTtRQUNoQ0YsWUFBWUUsT0FBTyxHQUFHRixZQUFZRSxPQUFPLENBQUNDLElBQUk7UUFDOUMsSUFBSUgsWUFBWUUsT0FBTyxLQUFLLE1BQU07WUFDaEMsbUVBQW1FO1lBQ25FRSxVQUFVO2dCQUNSSjtnQkFDQUssUUFBUUwsWUFBWUUsT0FBTztnQkFDM0JEO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsNERBQTREO1lBQzVELElBQUlELFlBQVlNLFlBQVksRUFBRTtnQkFDNUJOLFlBQVlNLFlBQVksR0FBRztnQkFDM0JOLFlBQVlPLFFBQVEsQ0FDbEI7b0JBQ0VDLE1BQU1DLG9CQUFBQSxjQUFjO29CQUNwQkMsUUFBUUMsT0FBT0MsUUFBUSxDQUFDRixNQUFNO2dCQUNoQyxHQUNBVDtZQUVKO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZUFBZUcsVUFBVSxLQVF4QjtJQVJ3QixNQUN2QkosV0FBVyxFQUNYSyxNQUFNLEVBQ05KLFFBQVEsRUFLVCxHQVJ3QjtJQVN2QixNQUFNWSxZQUFZYixZQUFZYyxLQUFLO0lBRW5DZCxZQUFZRSxPQUFPLEdBQUdHO0lBRXRCLE1BQU1VLFVBQVVWLE9BQU9VLE9BQU87SUFDOUIsTUFBTUMsZUFBZWhCLFlB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QUFBQSxHQUFBQSxPQUFBQSxlQUFBQSxFQUFnQjtnQkFDMEJzQztZQUF4Q3pFLHVCQUF1QmlELE1BQU0sV0FBV3dCLG1CQUFBQSxXQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxRQUFTa0IsTUFBTSxZQUFmbEIsa0JBQW1CLE1BQU07UUFDbkU7SUFDRjtJQUNBbUIsTUFBTSxDQUFDM0MsTUFBY3dCO1FBQ25CdEMsQ0FBQUEsR0FBQUEsT0FBQUEsZUFBQUEsRUFBZ0I7Z0JBQ3VCc0M7WUFBckN6RSx1QkFBdUJpRCxNQUFNLFFBQVF3QixDQUFBQSxrQkFBQUEsV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU2tCLE1BQUFBLEtBQU0sT0FBZmxCLGtCQUFtQixNQUFNO1FBQ2hFO0lBQ0Y7SUFDQW9CLFNBQVM7UUFDUDFELENBQUFBLEdBQUFBLE9BQUFBLGVBQUFBLEVBQWdCO1lBQ2QwQixDQUFBQSxHQUFBQSxnQkFBQUEsdUJBQUFBLEVBQXdCO2dCQUN0QmhELE1BQU1DLG9CQUFBQSxjQUFjO2dCQUNwQkMsUUFBUUMsT0FBT0MsUUFBUSxDQUFDRixNQUFNO1lBQ2hDO1FBQ0Y7SUFDRjtJQUNBK0UsWUFBWTtRQUNWLElBQUl0QyxLQUFvQixFQUFvQixFQUkzQyxNQUFNO1lBQ0xyQixDQUFBQSxHQUFBQSxPQUFBQSxlQUFBQSxFQUFnQjtnQkFDZDBCLENBQUFBLEdBQUFBLGdCQUFBQSx1QkFBQUEsRUFBd0I7b0JBQ3RCaEQsTUFBTW1GLG9CQUFBQSxrQkFBa0I7b0JBQ3hCakYsUUFBUUMsT0FBT0MsUUFBUSxDQUFDRixNQUFNO2dCQUNoQztZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZ0VBQWdFO0FBQ2hFLElBQUksS0FBNkIsSUFBSUMsT0FBT1IsSUFBSSxFQUFFO0lBQ2hEUSxPQUFPUixJQUFJLENBQUN5RixNQUFNLEdBQUc5RjtBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL1Byb2plY3RzL3NyYy9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWluc3RhbmNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIHR5cGUgQXBwUm91dGVyU3RhdGUsXG4gIHR5cGUgUmVkdWNlckFjdGlvbnMsXG4gIHR5cGUgUmVkdWNlclN0YXRlLFxuICBBQ1RJT05fUkVGUkVTSCxcbiAgQUNUSU9OX1NFUlZFUl9BQ1RJT04sXG4gIEFDVElPTl9OQVZJR0FURSxcbiAgQUNUSU9OX1JFU1RPUkUsXG4gIHR5cGUgTmF2aWdhdGVBY3Rpb24sXG4gIEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgUHJlZmV0Y2hLaW5kLFxuICBBQ1RJT05fUFJFRkVUQ0gsXG59IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyByZWR1Y2VyIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlcidcbmltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNUaGVuYWJsZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaXMtdGhlbmFibGUnXG5pbXBvcnQge1xuICBGZXRjaFN0cmF0ZWd5LFxuICBwcmVmZXRjaCBhcyBwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUsXG4gIHR5cGUgUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneSxcbn0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHsgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24gfSBmcm9tICcuL3VzZS1hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uL2FkZC1iYXNlLXBhdGgnXG5pbXBvcnQgeyBjcmVhdGVQcmVmZXRjaFVSTCwgaXNFeHRlcm5hbFVSTCB9IGZyb20gJy4vYXBwLXJvdXRlcidcbmltcG9ydCB7IHByZWZldGNoUmVkdWNlciB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlcidcbmltcG9ydCB0eXBlIHtcbiAgQXBwUm91dGVySW5zdGFuY2UsXG4gIE5hdmlnYXRlT3B0aW9ucyxcbiAgUHJlZmV0Y2hPcHRpb25zLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbiwgdHlwZSBMaW5rSW5zdGFuY2UgfSBmcm9tICcuL2xpbmtzJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyB9IGZyb20gJy4uL2FwcC1pbmRleCdcbmltcG9ydCB0eXBlIHsgR2xvYmFsRXJyb3JDb21wb25lbnQgfSBmcm9tICcuL2J1aWx0aW4vZ2xvYmFsLWVycm9yJ1xuXG5leHBvcnQgdHlwZSBEaXNwYXRjaFN0YXRlUHJvbWlzZSA9IFJlYWN0LkRpc3BhdGNoPFJlZHVjZXJTdGF0ZT5cblxuZXhwb3J0IHR5cGUgQXBwUm91dGVyQWN0aW9uUXVldWUgPSB7XG4gIHN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxuICBkaXNwYXRjaDogKHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zLCBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2UpID0+IHZvaWRcbiAgYWN0aW9uOiAoc3RhdGU6IEFwcFJvdXRlclN0YXRlLCBhY3Rpb246IFJlZHVjZXJBY3Rpb25zKSA9PiBSZWR1Y2VyU3RhdGVcblxuICBvblJvdXRlclRyYW5zaXRpb25TdGFydDpcbiAgICB8ICgodXJsOiBzdHJpbmcsIHR5cGU6ICdwdXNoJyB8ICdyZXBsYWNlJyB8ICd0cmF2ZXJzZScpID0+IHZvaWQpXG4gICAgfCBudWxsXG5cbiAgcGVuZGluZzogQWN0aW9uUXVldWVOb2RlIHwgbnVsbFxuICBuZWVkc1JlZnJlc2g/OiBib29sZWFuXG4gIGxhc3Q6IEFjdGlvblF1ZXVlTm9kZSB8IG51bGxcbn1cblxuZXhwb3J0IHR5cGUgR2xvYmFsRXJyb3JTdGF0ZSA9IFtcbiAgR2xvYmFsRXJyb3I6IEdsb2JhbEVycm9yQ29tcG9uZW50LFxuICBzdHlsZXM6IFJlYWN0LlJlYWN0Tm9kZSxcbl1cblxuZXhwb3J0IHR5cGUgQWN0aW9uUXVldWVOb2RlID0ge1xuICBwYXlsb2FkOiBSZWR1Y2VyQWN0aW9uc1xuICBuZXh0OiBBY3Rpb25RdWV1ZU5vZGUgfCBudWxsXG4gIHJlc29sdmU6ICh2YWx1ZTogUmVkdWNlclN0YXRlKSA9PiB2b2lkXG4gIHJlamVjdDogKGVycjogRXJyb3IpID0+IHZvaWRcbiAgZGlzY2FyZGVkPzogYm9vbGVhblxufVxuXG5mdW5jdGlvbiBydW5SZW1haW5pbmdBY3Rpb25zKFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHNldFN0YXRlOiBEaXNwYXRjaFN0YXRlUHJvbWlzZVxuKSB7XG4gIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nICE9PSBudWxsKSB7XG4gICAgYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvblF1ZXVlLnBlbmRpbmcubmV4dFxuICAgIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nICE9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICBydW5BY3Rpb24oe1xuICAgICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25RdWV1ZS5wZW5kaW5nLFxuICAgICAgICBzZXRTdGF0ZSxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIG1vcmUgYWN0aW9ucyBhcmUgcGVuZGluZywgY2hlY2sgaWYgYSByZWZyZXNoIGlzIG5lZWRlZFxuICAgICAgaWYgKGFjdGlvblF1ZXVlLm5lZWRzUmVmcmVzaCkge1xuICAgICAgICBhY3Rpb25RdWV1ZS5uZWVkc1JlZnJlc2ggPSBmYWxzZVxuICAgICAgICBhY3Rpb25RdWV1ZS5kaXNwYXRjaChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBBQ1RJT05fUkVGUkVTSCxcbiAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldFN0YXRlXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuQWN0aW9uKHtcbiAgYWN0aW9uUXVldWUsXG4gIGFjdGlvbixcbiAgc2V0U3RhdGUsXG59OiB7XG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICBhY3Rpb246IEFjdGlvblF1ZXVlTm9kZVxuICBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2Vcbn0pIHtcbiAgY29uc3QgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGVcblxuICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uXG5cbiAgY29uc3QgcGF5bG9hZCA9IGFjdGlvbi5wYXlsb2FkXG4gIGNvbnN0IGFjdGlvblJlc3VsdCA9IGFjdGlvblF1ZXVlLmFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpXG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0KG5leHRTdGF0ZTogQXBwUm91dGVyU3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBkaXNjYXJkZWQgdGhpcyBhY3Rpb24sIHRoZSBzdGF0ZSBzaG91bGQgYWxzbyBiZSBkaXNjYXJkZWRcbiAgICBpZiAoYWN0aW9uLmRpc2NhcmRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGVcblxuICAgIHJ1blJlbWFpbmluZ0FjdGlvbnMoYWN0aW9uUXVldWUsIHNldFN0YXRlKVxuICAgIGFjdGlvbi5yZXNvbHZlKG5leHRTdGF0ZSlcbiAgfVxuXG4gIC8vIGlmIHRoZSBhY3Rpb24gaXMgYSBwcm9taXNlLCBzZXQgdXAgYSBjYWxsYmFjayB0byByZXNvbHZlIGl0XG4gIGlmIChpc1RoZW5hYmxlKGFjdGlvblJlc3VsdCkpIHtcbiAgICBhY3Rpb25SZXN1bHQudGhlbihoYW5kbGVSZXN1bHQsIChlcnIpID0+IHtcbiAgICAgIHJ1blJlbWFpbmluZ0FjdGlvbnMoYWN0aW9uUXVldWUsIHNldFN0YXRlKVxuICAgICAgYWN0aW9uLnJlamVjdChlcnIpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXN1bHQoYWN0aW9uUmVzdWx0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKFxuICBhY3Rpb25RdWV1ZTogQXBwUm91dGVyQWN0aW9uUXVldWUsXG4gIHBheWxvYWQ6IFJlZHVjZXJBY3Rpb25zLFxuICBzZXRTdGF0ZTogRGlzcGF0Y2hTdGF0ZVByb21pc2Vcbikge1xuICBsZXQgcmVzb2x2ZXJzOiB7XG4gICAgcmVzb2x2ZTogKHZhbHVlOiBSZWR1Y2VyU3RhdGUpID0+IHZvaWRcbiAgICByZWplY3Q6IChyZWFzb246IGFueSkgPT4gdm9pZFxuICB9ID0geyByZXNvbHZlOiBzZXRTdGF0ZSwgcmVqZWN0OiAoKSA9PiB7fSB9XG5cbiAgLy8gbW9zdCBvZiB0aGUgYWN0aW9uIHR5cGVzIGFyZSBhc3luYyB3aXRoIHRoZSBleGNlcHRpb24gb2YgcmVzdG9yZVxuICAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHJlc3RvcmUgaXMgaGFuZGxlZCBxdWlja2x5IHNpbmNlIGl0J3MgZmlyZWQgb24gdGhlIHBvcHN0YXRlIGV2ZW50XG4gIC8vIGFuZCB3ZSBkb24ndCB3YW50IHRvIGFkZCBhbnkgZGVsYXkgb24gYSBiYWNrL2ZvcndhcmQgbmF2XG4gIC8vIHRoaXMgb25seSBjcmVhdGVzIGEgcHJvbWlzZSBmb3IgdGhlIGFzeW5jIGFjdGlvbnNcbiAgaWYgKHBheWxvYWQudHlwZSAhPT0gQUNUSU9OX1JFU1RPUkUpIHtcbiAgICAvLyBDcmVhdGUgdGhlIHByb21pc2UgYW5kIGFzc2lnbiB0aGUgcmVzb2x2ZXJzIHRvIHRoZSBvYmplY3QuXG4gICAgY29uc3QgZGVmZXJyZWRQcm9taXNlID0gbmV3IFByb21pc2U8QXBwUm91dGVyU3RhdGU+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlc29sdmVycyA9IHsgcmVzb2x2ZSwgcmVqZWN0IH1cbiAgICB9KVxuXG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIC8vIHdlIGltbWVkaWF0ZWx5IG5vdGlmeSBSZWFjdCBvZiB0aGUgcGVuZGluZyBwcm9taXNlIC0tIHRoZSByZXNvbHZlciBpcyBhdHRhY2hlZCB0byB0aGUgYWN0aW9uIG5vZGVcbiAgICAgIC8vIGFuZCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBhc3NvY2lhdGVkIGFjdGlvbiBwcm9taXNlIHJlc29sdmVzXG4gICAgICBzZXRTdGF0ZShkZWZlcnJlZFByb21pc2UpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG5ld0FjdGlvbjogQWN0aW9uUXVldWVOb2RlID0ge1xuICAgIHBheWxvYWQsXG4gICAgbmV4dDogbnVsbCxcbiAgICByZXNvbHZlOiByZXNvbHZlcnMucmVzb2x2ZSxcbiAgICByZWplY3Q6IHJlc29sdmVycy5yZWplY3QsXG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgcXVldWUgaXMgZW1wdHlcbiAgaWYgKGFjdGlvblF1ZXVlLnBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgaXMgZW1wdHksIHNvIGFkZCB0aGUgYWN0aW9uIGFuZCBzdGFydCBpdCBpbW1lZGlhdGVseVxuICAgIC8vIE1hcmsgdGhpcyBhY3Rpb24gYXMgdGhlIGxhc3QgaW4gdGhlIHF1ZXVlXG4gICAgYWN0aW9uUXVldWUubGFzdCA9IG5ld0FjdGlvblxuXG4gICAgcnVuQWN0aW9uKHtcbiAgICAgIGFjdGlvblF1ZXVlLFxuICAgICAgYWN0aW9uOiBuZXdBY3Rpb24sXG4gICAgICBzZXRTdGF0ZSxcbiAgICB9KVxuICB9IGVsc2UgaWYgKFxuICAgIHBheWxvYWQudHlwZSA9PT0gQUNUSU9OX05BVklHQVRFIHx8XG4gICAgcGF5bG9hZC50eXBlID09PSBBQ1RJT05fUkVTVE9SRVxuICApIHtcbiAgICAvLyBOYXZpZ2F0aW9ucyAoaW5jbHVkaW5nIGJhY2svZm9yd2FyZCkgdGFrZSBwcmlvcml0eSBvdmVyIGFueSBwZW5kaW5nIGFjdGlvbnMuXG4gICAgLy8gTWFyayB0aGUgcGVuZGluZyBhY3Rpb24gYXMgZGlzY2FyZGVkIChzbyB0aGUgc3RhdGUgaXMgbmV2ZXIgYXBwbGllZCkgYW5kIHN0YXJ0IHRoZSBuYXZpZ2F0aW9uIGFjdGlvbiBpbW1lZGlhdGVseS5cbiAgICBhY3Rpb25RdWV1ZS5wZW5kaW5nLmRpc2NhcmRlZCA9IHRydWVcblxuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBjdXJyZW50IHF1ZXVlIHNob3VsZCBzdGlsbCBleGVjdXRlIGFmdGVyIHRoaXMgbmF2aWdhdGlvbi5cbiAgICAvLyAoTm90ZSB0aGF0IGl0IGNhbid0IGNvbnRhaW4gYW55IGVhcmxpZXIgbmF2aWdhdGlvbnMsIGJlY2F1c2Ugd2UgYWx3YXlzIHB1dCB0aG9zZSBpbnRvIGBhY3Rpb25RdWV1ZS5wZW5kaW5nYCBieSBjYWxsaW5nIGBydW5BY3Rpb25gKVxuICAgIG5ld0FjdGlvbi5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZy5uZXh0XG5cbiAgICAvLyBpZiB0aGUgcGVuZGluZyBhY3Rpb24gd2FzIGEgc2VydmVyIGFjdGlvbiwgbWFyayB0aGUgcXVldWUgYXMgbmVlZGluZyBhIHJlZnJlc2ggb25jZSBldmVudHMgYXJlIHByb2Nlc3NlZFxuICAgIGlmIChhY3Rpb25RdWV1ZS5wZW5kaW5nLnBheWxvYWQudHlwZSA9PT0gQUNUSU9OX1NFUlZFUl9BQ1RJT04pIHtcbiAgICAgIGFjdGlvblF1ZXVlLm5lZWRzUmVmcmVzaCA9IHRydWVcbiAgICB9XG5cbiAgICBydW5BY3Rpb24oe1xuICAgICAgYWN0aW9uUXVldWUsXG4gICAgICBhY3Rpb246IG5ld0FjdGlvbixcbiAgICAgIHNldFN0YXRlLFxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHF1ZXVlIGlzIG5vdCBlbXB0eSwgc28gYWRkIHRoZSBhY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcbiAgICAvLyBJdCB3aWxsIGJlIHN0YXJ0ZWQgYnkgcnVuUmVtYWluaW5nQWN0aW9ucyBhZnRlciB0aGUgcHJldmlvdXMgYWN0aW9uIGZpbmlzaGVzXG4gICAgaWYgKGFjdGlvblF1ZXVlLmxhc3QgIT09IG51bGwpIHtcbiAgICAgIGFjdGlvblF1ZXVlLmxhc3QubmV4dCA9IG5ld0FjdGlvblxuICAgIH1cbiAgICBhY3Rpb25RdWV1ZS5sYXN0ID0gbmV3QWN0aW9uXG4gIH1cbn1cblxubGV0IGdsb2JhbEFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSB8IG51bGwgPSBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNdXRhYmxlQWN0aW9uUXVldWUoXG4gIGluaXRpYWxTdGF0ZTogQXBwUm91dGVyU3RhdGUsXG4gIGluc3RydW1lbnRhdGlvbkhvb2tzOiBDbGllbnRJbnN0cnVtZW50YXRpb25Ib29rcyB8IG51bGxcbik6IEFwcFJvdXRlckFjdGlvblF1ZXVlIHtcbiAgY29uc3QgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlID0ge1xuICAgIHN0YXRlOiBpbml0aWFsU3RhdGUsXG4gICAgZGlzcGF0Y2g6IChwYXlsb2FkOiBSZWR1Y2VyQWN0aW9ucywgc2V0U3RhdGU6IERpc3BhdGNoU3RhdGVQcm9taXNlKSA9PlxuICAgICAgZGlzcGF0Y2hBY3Rpb24oYWN0aW9uUXVldWUsIHBheWxvYWQsIHNldFN0YXRlKSxcbiAgICBhY3Rpb246IGFzeW5jIChzdGF0ZTogQXBwUm91dGVyU3RhdGUsIGFjdGlvbjogUmVkdWNlckFjdGlvbnMpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZHVjZXIoc3RhdGUsIGFjdGlvbilcbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9LFxuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydDpcbiAgICAgIGluc3RydW1lbnRhdGlvbkhvb2tzICE9PSBudWxsICYmXG4gICAgICB0eXBlb2YgaW5zdHJ1bWVudGF0aW9uSG9va3Mub25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAvLyBUaGlzIHByb2ZpbGluZyBob29rIHdpbGwgYmUgY2FsbGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBuYXZpZ2F0aW9uLlxuICAgICAgICAgIGluc3RydW1lbnRhdGlvbkhvb2tzLm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0XG4gICAgICAgIDogbnVsbCxcbiAgfVxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRoZSBhY3Rpb24gcXVldWUgaXMgbGF6aWx5IGNyZWF0ZWQgb24gaHlkcmF0aW9uLCBidXQgYWZ0ZXIgdGhhdCBwb2ludFxuICAgIC8vIGl0IGRvZXNuJ3QgY2hhbmdlLiBTbyB3ZSBjYW4gc3RvcmUgaXQgaW4gYSBnbG9iYWwgcmF0aGVyIHRoYW4gcGFzc1xuICAgIC8vIGl0IGFyb3VuZCBldmVyeXdoZXJlIHZpYSBwcm9wcy9jb250ZXh0LlxuICAgIGlmIChnbG9iYWxBY3Rpb25RdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW50ZXJuYWwgTmV4dC5qcyBFcnJvcjogY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIHdhcyBjYWxsZWQgbW9yZSAnICtcbiAgICAgICAgICAndGhhbiBvbmNlJ1xuICAgICAgKVxuICAgIH1cbiAgICBnbG9iYWxBY3Rpb25RdWV1ZSA9IGFjdGlvblF1ZXVlXG4gIH1cblxuICByZXR1cm4gYWN0aW9uUXVldWVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSgpOiBBcHBSb3V0ZXJTdGF0ZSB8IG51bGwge1xuICByZXR1cm4gZ2xvYmFsQWN0aW9uUXVldWUgIT09IG51bGwgPyBnbG9iYWxBY3Rpb25RdWV1ZS5zdGF0ZSA6IG51bGxcbn1cblxuZnVuY3Rpb24gZ2V0QXBwUm91dGVyQWN0aW9uUXVldWUoKTogQXBwUm91dGVyQWN0aW9uUXVldWUge1xuICBpZiAoZ2xvYmFsQWN0aW9uUXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnSW50ZXJuYWwgTmV4dC5qcyBlcnJvcjogUm91dGVyIGFjdGlvbiBkaXNwYXRjaGVkIGJlZm9yZSBpbml0aWFsaXphdGlvbi4nXG4gICAgKVxuICB9XG4gIHJldHVybiBnbG9iYWxBY3Rpb25RdWV1ZVxufVxuXG5mdW5jdGlvbiBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKSB7XG4gIGlmIChnbG9iYWxBY3Rpb25RdWV1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnbG9iYWxBY3Rpb25RdWV1ZS5vblJvdXRlclRyYW5zaXRpb25TdGFydFxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaE5hdmlnYXRlQWN0aW9uKFxuICBocmVmOiBzdHJpbmcsXG4gIG5hdmlnYXRlVHlwZTogTmF2aWdhdGVBY3Rpb25bJ25hdmlnYXRlVHlwZSddLFxuICBzaG91bGRTY3JvbGw6IGJvb2xlYW4sXG4gIGxpbmtJbnN0YW5jZVJlZjogTGlua0luc3RhbmNlIHwgbnVsbFxuKTogdm9pZCB7XG4gIC8vIFRPRE86IFRoaXMgc3R1ZmYgY291bGQganVzdCBnbyBpbnRvIHRoZSByZWR1Y2VyLiBMZWF2aW5nIGFzLWlzIGZvciBub3dcbiAgLy8gc2luY2Ugd2UncmUgYWJvdXQgdG8gcmV3cml0ZSBhbGwgdGhlIHJvdXRlciByZWR1Y2VyIHN0dWZmIGFueXdheS5cbiAgY29uc3QgdXJsID0gbmV3IFVSTChhZGRCYXNlUGF0aChocmVmKSwgbG9jYXRpb24uaHJlZilcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9BUFBfTkFWX0ZBSUxfSEFORExJTkcpIHtcbiAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1cmxcbiAgfVxuXG4gIHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rSW5zdGFuY2VSZWYpXG5cbiAgY29uc3Qgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPSBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKVxuICBpZiAob25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgIT09IG51bGwpIHtcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydChocmVmLCBuYXZpZ2F0ZVR5cGUpXG4gIH1cblxuICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgdHlwZTogQUNUSU9OX05BVklHQVRFLFxuICAgIHVybCxcbiAgICBpc0V4dGVybmFsVXJsOiBpc0V4dGVybmFsVVJMKHVybCksXG4gICAgbG9jYXRpb25TZWFyY2g6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICBzaG91bGRTY3JvbGwsXG4gICAgbmF2aWdhdGVUeXBlLFxuICAgIGFsbG93QWxpYXNpbmc6IHRydWUsXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uKFxuICBocmVmOiBzdHJpbmcsXG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlIHwgdW5kZWZpbmVkXG4pIHtcbiAgY29uc3Qgb25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgPSBnZXRQcm9maWxpbmdIb29rRm9yT25OYXZpZ2F0aW9uU3RhcnQoKVxuICBpZiAob25Sb3V0ZXJUcmFuc2l0aW9uU3RhcnQgIT09IG51bGwpIHtcbiAgICBvblJvdXRlclRyYW5zaXRpb25TdGFydChocmVmLCAndHJhdmVyc2UnKVxuICB9XG4gIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICB0eXBlOiBBQ1RJT05fUkVTVE9SRSxcbiAgICB1cmw6IG5ldyBVUkwoaHJlZiksXG4gICAgdHJlZSxcbiAgfSlcbn1cblxuLyoqXG4gKiBUaGUgYXBwIHJvdXRlciB0aGF0IGlzIGV4cG9zZWQgdGhyb3VnaCBgdXNlUm91dGVyYC4gVGhlc2UgYXJlIHB1YmxpYyBBUElcbiAqIG1ldGhvZHMuIEludGVybmFsIE5leHQuanMgY29kZSBzaG91bGQgY2FsbCB0aGUgbG93ZXIgbGV2ZWwgbWV0aG9kcyBkaXJlY3RseVxuICogKGFsdGhvdWdoIHRoZXJlJ3MgbG90cyBvZiBleGlzdGluZyBjb2RlIHRoYXQgZG9lc24ndCBkbyB0aGF0KS5cbiAqL1xuZXhwb3J0IGNvbnN0IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlOiBBcHBSb3V0ZXJJbnN0YW5jZSA9IHtcbiAgYmFjazogKCkgPT4gd2luZG93Lmhpc3RvcnkuYmFjaygpLFxuICBmb3J3YXJkOiAoKSA9PiB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCksXG4gIHByZWZldGNoOiBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICA/IC8vIFVubGlrZSB0aGUgb2xkIGltcGxlbWVudGF0aW9uLCB0aGUgU2VnbWVudCBDYWNoZSBkb2Vzbid0IHN0b3JlIGl0c1xuICAgICAgLy8gZGF0YSBpbiB0aGUgcm91dGVyIHJlZHVjZXIgc3RhdGU7IGl0IHdyaXRlcyBpbnRvIGEgZ2xvYmFsIG11dGFibGVcbiAgICAgIC8vIGNhY2hlLiBTbyB3ZSBkb24ndCBuZWVkIHRvIGRpc3BhdGNoIGFuIGFjdGlvbi5cbiAgICAgIChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9uUXVldWUgPSBnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSgpXG4gICAgICAgIGNvbnN0IHByZWZldGNoS2luZCA9IG9wdGlvbnM/LmtpbmQgPz8gUHJlZmV0Y2hLaW5kLkFVVE9cblxuICAgICAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgb2ZmZXIgYSB3YXkgdG8gaXNzdWUgYSBydW50aW1lIHByZWZldGNoIHZpYSBgcm91dGVyLnByZWZldGNoKClgLlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgcG9zc2libGUgd2hlbiB3ZSB1cGRhdGUgaXRzIEFQSSB0byBub3QgdGFrZSBhIFByZWZldGNoS2luZC5cbiAgICAgICAgbGV0IGZldGNoU3RyYXRlZ3k6IFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3lcbiAgICAgICAgc3dpdGNoIChwcmVmZXRjaEtpbmQpIHtcbiAgICAgICAgICBjYXNlIFByZWZldGNoS2luZC5BVVRPOiB7XG4gICAgICAgICAgICAvLyBXZSBkZWZhdWx0IHRvIFBQUi4gV2UnbGwgZGlzY292ZXIgd2hldGhlciBvciBub3QgdGhlIHJvdXRlIHN1cHBvcnRzIGl0IHdpdGggdGhlIGluaXRpYWwgcHJlZmV0Y2guXG4gICAgICAgICAgICBmZXRjaFN0cmF0ZWd5ID0gRmV0Y2hTdHJhdGVneS5QUFJcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgUHJlZmV0Y2hLaW5kLkZVTEw6IHtcbiAgICAgICAgICAgIGZldGNoU3RyYXRlZ3kgPSBGZXRjaFN0cmF0ZWd5LkZ1bGxcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWToge1xuICAgICAgICAgICAgLy8gVGhpcyBjb25jZXB0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNlZ21lbnQgY2FjaGUgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgcHJlZmV0Y2hLaW5kIHNhdGlzZmllcyBuZXZlclxuICAgICAgICAgICAgLy8gRGVzcGl0ZSB0eXBlc2NyaXB0IHRoaW5raW5nIHRoYXQgdGhpcyBjYW4ndCBoYXBwZW4sXG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBnZXQgYW4gdW5leHBlY3RlZCB2YWx1ZSBmcm9tIHVzZXIgY29kZS5cbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgd2hhdCB0aGV5IHdhbnQsIGJ1dCB3ZSBrbm93IHRoZXkgd2FudCBhIHByZWZldGNoLFxuICAgICAgICAgICAgLy8gc28gdXNlIHRoZSBkZWZhdWx0LlxuICAgICAgICAgICAgZmV0Y2hTdHJhdGVneSA9IEZldGNoU3RyYXRlZ3kuUFBSXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJlZmV0Y2hXaXRoU2VnbWVudENhY2hlKFxuICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgYWN0aW9uUXVldWUuc3RhdGUubmV4dFVybCxcbiAgICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZS50cmVlLFxuICAgICAgICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgICAgICAgb3B0aW9ucz8ub25JbnZhbGlkYXRlID8/IG51bGxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIDogKGhyZWY6IHN0cmluZywgb3B0aW9ucz86IFByZWZldGNoT3B0aW9ucykgPT4ge1xuICAgICAgICAvLyBVc2UgdGhlIG9sZCBwcmVmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgY29uc3QgYWN0aW9uUXVldWUgPSBnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSgpXG4gICAgICAgIGNvbnN0IHVybCA9IGNyZWF0ZVByZWZldGNoVVJMKGhyZWYpXG4gICAgICAgIGlmICh1cmwgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGUgcHJlZmV0Y2ggcmVkdWNlciBkb2Vzbid0IGFjdHVhbGx5IHVwZGF0ZSBhbnkgc3RhdGUgb3JcbiAgICAgICAgICAvLyB0cmlnZ2VyIGEgcmVyZW5kZXIuIEl0IGp1c3Qgd3JpdGVzIHRvIGEgbXV0YWJsZSBjYWNoZS4gU28gd2VcbiAgICAgICAgICAvLyBzaG91bGRuJ3QgYm90aGVyIGNhbGxpbmcgc2V0U3RhdGUvZGlzcGF0Y2g7IHdlIGNhbiBqdXN0IHJlLXJ1blxuICAgICAgICAgIC8vIHRoZSByZWR1Y2VyIGRpcmVjdGx5IHVzaW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgYXdheSBmcm9tIGEgXCJyZWR1Y2VyXCIgc28gaXQnc1xuICAgICAgICAgIC8vIGxlc3MgY29uZnVzaW5nLlxuICAgICAgICAgIHByZWZldGNoUmVkdWNlcihhY3Rpb25RdWV1ZS5zdGF0ZSwge1xuICAgICAgICAgICAgdHlwZTogQUNUSU9OX1BSRUZFVENILFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAga2luZDogb3B0aW9ucz8ua2luZCA/PyBQcmVmZXRjaEtpbmQuRlVMTCxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuICByZXBsYWNlOiAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oaHJlZiwgJ3JlcGxhY2UnLCBvcHRpb25zPy5zY3JvbGwgPz8gdHJ1ZSwgbnVsbClcbiAgICB9KVxuICB9LFxuICBwdXNoOiAoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoTmF2aWdhdGVBY3Rpb24oaHJlZiwgJ3B1c2gnLCBvcHRpb25zPy5zY3JvbGwgPz8gdHJ1ZSwgbnVsbClcbiAgICB9KVxuICB9LFxuICByZWZyZXNoOiAoKSA9PiB7XG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIGRpc3BhdGNoQXBwUm91dGVyQWN0aW9uKHtcbiAgICAgICAgdHlwZTogQUNUSU9OX1JFRlJFU0gsXG4gICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgaG1yUmVmcmVzaDogKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaG1yUmVmcmVzaCBjYW4gb25seSBiZSB1c2VkIGluIGRldmVsb3BtZW50IG1vZGUuIFBsZWFzZSB1c2UgcmVmcmVzaCBpbnN0ZWFkLidcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9ITVJfUkVGUkVTSCxcbiAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbn1cblxuLy8gRXhpc3RzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuIERvbid0IHVzZSBpbiBhcHBsaWNhdGlvbiBjb2RlLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5uZXh0KSB7XG4gIHdpbmRvdy5uZXh0LnJvdXRlciA9IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlTXV0YWJsZUFjdGlvblF1ZXVlIiwiZGlzcGF0Y2hOYXZpZ2F0ZUFjdGlvbiIsImRpc3BhdGNoVHJhdmVyc2VBY3Rpb24iLCJnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUiLCJwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSIsInJ1blJlbWFpbmluZ0FjdGlvbnMiLCJhY3Rpb25RdWV1ZSIsInNldFN0YXRlIiwicGVuZGluZyIsIm5leHQiLCJydW5BY3Rpb24iLCJhY3Rpb24iLCJuZWVkc1JlZnJlc2giLCJkaXNwYXRjaCIsInR5cGUiLCJBQ1RJT05fUkVGUkVTSCIsIm9yaWdpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwicHJldlN0YXRlIiwic3RhdGUiLCJwYXlsb2FkIiwiYWN0aW9uUmVzdWx0IiwiaGFuZGxlUmVzdWx0IiwibmV4dFN0YXRlIiwiZGlzY2FyZGVkIiwicmVzb2x2ZSIsImlzVGhlbmFibGUiLCJ0aGVuIiwiZXJyIiwicmVqZWN0IiwiZGlzcGF0Y2hBY3Rpb24iLCJyZXNvbHZlcnMiLCJBQ1RJT05fUkVTVE9SRSIsImRlZmVycmVkUHJvbWlzZSIsIlByb21pc2UiLCJzdGFydFRyYW5zaXRpb24iLCJuZXdBY3Rpb24iLCJsYXN0IiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJnbG9iYWxBY3Rpb25RdWV1ZSIsImluaXRpYWxTdGF0ZSIsImluc3RydW1lbnRhdGlvbkhvb2tzIiwicmVzdWx0IiwicmVkdWNlciIsIm9uUm91dGVyVHJhbnNpdGlvblN0YXJ0IiwiRXJyb3IiLCJnZXRBcHBSb3V0ZXJBY3Rpb25RdWV1ZSIsImdldFByb2ZpbGluZ0hvb2tGb3JPbk5hdmlnYXRpb25TdGFydCIsImhyZWYiLCJuYXZpZ2F0ZVR5cGUiLCJzaG91bGRTY3JvbGwiLCJsaW5rSW5zdGFuY2VSZWYiLCJ1cmwiLCJVUkwiLCJhZGRCYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HIiwiX19wZW5kaW5nVXJsIiwic2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJpc0V4dGVybmFsVXJsIiwiaXNFeHRlcm5hbFVSTCIsImxvY2F0aW9uU2VhcmNoIiwic2VhcmNoIiwiYWxsb3dBbGlhc2luZyIsInRyZWUiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJwcmVmZXRjaCIsIl9fTkVYVF9DTElFTlRfU0VHTUVOVF9DQUNIRSIsIm9wdGlvbnMiLCJwcmVmZXRjaEtpbmQiLCJraW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsImZldGNoU3RyYXRlZ3kiLCJGZXRjaFN0cmF0ZWd5IiwiUFBSIiwiRlVMTCIsIkZ1bGwiLCJURU1QT1JBUlkiLCJwcmVmZXRjaFdpdGhTZWdtZW50Q2FjaGUiLCJuZXh0VXJsIiwib25JbnZhbGlkYXRlIiwiY3JlYXRlUHJlZmV0Y2hVUkwiLCJwcmVmZXRjaFJlZHVjZXIiLCJBQ1RJT05fUFJFRkVUQ0giLCJyZXBsYWNlIiwic2Nyb2xsIiwicHVzaCIsInJlZnJlc2giLCJobXJSZWZyZXNoIiwiTk9ERV9FTlYiLCJBQ1RJT05fSE1SX1JFRlJFU0giLCJyb3V0ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createEmptyCacheNode: function() {\n        return createEmptyCacheNode;\n    },\n    createPrefetchURL: function() {\n        return createPrefetchURL;\n    },\n    default: function() {\n        return AppRouter;\n    },\n    isExternalURL: function() {\n        return isExternalURL;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _createhreffromurl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _useactionqueue = __webpack_require__(/*! ./use-action-queue */ \"(app-pages-browser)/./node_modules/next/dist/client/components/use-action-queue.js\");\nconst _isbot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _addbasepath = __webpack_require__(/*! ../add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _approuterannouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-announcer.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _findheadincache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nconst _unresolvedthenable = __webpack_require__(/*! ./unresolved-thenable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/unresolved-thenable.js\");\nconst _removebasepath = __webpack_require__(/*! ../remove-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nconst _computechangedpath = __webpack_require__(/*! ./router-reducer/compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _navfailurehandler = __webpack_require__(/*! ./nav-failure-handler */ \"(app-pages-browser)/./node_modules/next/dist/client/components/nav-failure-handler.js\");\nconst _approuterinstance = __webpack_require__(/*! ./app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _redirecterror = __webpack_require__(/*! ./redirect-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-error.js\");\nconst _links = __webpack_require__(/*! ./links */ \"(app-pages-browser)/./node_modules/next/dist/client/components/links.js\");\nconst _rooterrorboundary = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./errors/root-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/errors/root-error-boundary.js\"));\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./builtin/global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst _boundarycomponents = __webpack_require__(/*! ../../lib/framework/boundary-components */ \"(app-pages-browser)/./node_modules/next/dist/lib/framework/boundary-components.js\");\nconst globalMutable = {};\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\nfunction createPrefetchURL(href) {\n    // Don't prefetch for bots as they don't navigate.\n    if ((0, _isbot.isBot)(window.navigator.userAgent)) {\n        return null;\n    }\n    let url;\n    try {\n        url = new URL((0, _addbasepath.addBasePath)(href), window.location.href);\n    } catch (_) {\n        // TODO: Does this need to throw or can we just console.error instead? Does\n        // anyone rely on this throwing? (Seems unlikely.)\n        throw Object.defineProperty(new Error(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\"), \"__NEXT_ERROR_CODE\", {\n            value: \"E234\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    // Don't prefetch during development (improves compilation performance)\n    if (true) {\n        return null;\n    }\n    // External urls can't be prefetched in the same way.\n    if (isExternalURL(url)) {\n        return null;\n    }\n    return url;\n}\nfunction HistoryUpdater(param) {\n    let { appRouterState } = param;\n    (0, _react.useInsertionEffect)(()=>{\n        if (false) {}\n        const { tree, pushRef, canonicalUrl } = appRouterState;\n        const historyState = {\n            ...pushRef.preserveCustomHistoryState ? window.history.state : {},\n            // Identifier is shortened intentionally.\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            // __N is used to identify if the history entry can be handled by the old router.\n            __NA: true,\n            __PRIVATE_NEXTJS_INTERNALS_TREE: tree\n        };\n        if (pushRef.pendingPush && // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n        // This mirrors the browser behavior for normal navigation.\n        (0, _createhreffromurl.createHrefFromUrl)(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, '', canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, '', canonicalUrl);\n        }\n    }, [\n        appRouterState\n    ]);\n    (0, _react.useEffect)(()=>{\n        // The Next-Url and the base tree may affect the result of a prefetch\n        // task. Re-prefetch all visible links with the updated values. In most\n        // cases, this will not result in any new network requests, only if\n        // the prefetch result actually varies on one of these inputs.\n        if (false) {}\n    }, [\n        appRouterState.nextUrl,\n        appRouterState.tree\n    ]);\n    return null;\n}\n_c = HistoryUpdater;\nfunction createEmptyCacheNode() {\n    return {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1\n    };\n}\nfunction copyNextJsInternalHistoryState(data) {\n    if (data == null) data = {};\n    const currentState = window.history.state;\n    const __NA = currentState == null ? void 0 : currentState.__NA;\n    if (__NA) {\n        data.__NA = __NA;\n    }\n    const __PRIVATE_NEXTJS_INTERNALS_TREE = currentState == null ? void 0 : currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;\n    if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n        data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;\n    }\n    return data;\n}\nfunction Head(param) {\n    let { headCacheNode } = param;\n    // If this segment has a `prefetchHead`, it's the statically prefetched data.\n    // We should use that on initial render instead of `head`. Then we'll switch\n    // to `head` when the dynamic response streams in.\n    const head = headCacheNode !== null ? headCacheNode.head : null;\n    const prefetchHead = headCacheNode !== null ? headCacheNode.prefetchHead : null;\n    // If no prefetch data is available, then we go straight to rendering `head`.\n    const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    return (0, _react.useDeferredValue)(head, resolvedPrefetchRsc);\n}\n_c1 = Head;\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    let { actionQueue, assetPrefix, globalError } = param;\n    const state = (0, _useactionqueue.useActionQueue)(actionQueue);\n    const { canonicalUrl } = state;\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams, pathname } = (0, _react.useMemo)(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: (0, _hasbasepath.hasBasePath)(url.pathname) ? (0, _removebasepath.removeBasePath)(url.pathname) : url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    if (true) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const { cache, prefetchCache, tree } = state;\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0, _react.useEffect)(()=>{\n            // Add `window.nd` for debugging purposes.\n            // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n            // @ts-ignore this is for debugging\n            window.nd = {\n                router: _approuterinstance.publicAppRouterInstance,\n                cache,\n                prefetchCache,\n                tree\n            };\n        }, [\n            cache,\n            prefetchCache,\n            tree\n        ]);\n    }\n    (0, _react.useEffect)(()=>{\n        // If the app is restored from bfcache, it's possible that\n        // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n        // would trigger the mpa navigation logic again from the lines below.\n        // This will restore the router to the initial state in the event that the app is restored from bfcache.\n        function handlePageShow(event) {\n            var _window_history_state;\n            if (!event.persisted || !((_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {\n                return;\n            }\n            // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n            // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n            // of the last MPA navigation.\n            globalMutable.pendingMpaPath = undefined;\n            (0, _useactionqueue.dispatchAppRouterAction)({\n                type: _routerreducertypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n            });\n        }\n        window.addEventListener('pageshow', handlePageShow);\n        return ()=>{\n            window.removeEventListener('pageshow', handlePageShow);\n        };\n    }, []);\n    (0, _react.useEffect)(()=>{\n        // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n        // are caught and handled by the router.\n        function handleUnhandledRedirect(event) {\n            const error = 'reason' in event ? event.reason : event.error;\n            if ((0, _redirecterror.isRedirectError)(error)) {\n                event.preventDefault();\n                const url = (0, _redirect.getURLFromRedirectError)(error);\n                const redirectType = (0, _redirect.getRedirectTypeFromError)(error);\n                // TODO: This should access the router methods directly, rather than\n                // go through the public interface.\n                if (redirectType === _redirecterror.RedirectType.push) {\n                    _approuterinstance.publicAppRouterInstance.push(url, {});\n                } else {\n                    _approuterinstance.publicAppRouterInstance.replace(url, {});\n                }\n            }\n        }\n        window.addEventListener('error', handleUnhandledRedirect);\n        window.addEventListener('unhandledrejection', handleUnhandledRedirect);\n        return ()=>{\n            window.removeEventListener('error', handleUnhandledRedirect);\n            window.removeEventListener('unhandledrejection', handleUnhandledRedirect);\n        };\n    }, []);\n    // When mpaNavigation flag is set do a hard navigation to the new url.\n    // Infinitely suspend because we don't actually want to rerender any child\n    // components with the new URL and any entangled state updates shouldn't\n    // commit either (eg: useTransition isPending should stay true until the page\n    // unloads).\n    //\n    // This is a side effect in render. Don't try this at home, kids. It's\n    // probably safe because we know this is a singleton component and it's never\n    // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n    // but that's... fine?)\n    const { pushRef } = state;\n    if (pushRef.mpaNavigation) {\n        // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n        if (globalMutable.pendingMpaPath !== canonicalUrl) {\n            const location = window.location;\n            if (pushRef.pendingPush) {\n                location.assign(canonicalUrl);\n            } else {\n                location.replace(canonicalUrl);\n            }\n            globalMutable.pendingMpaPath = canonicalUrl;\n        }\n        // TODO-APP: Should we listen to navigateerror here to catch failed\n        // navigations somehow? And should we call window.stop() if a SPA navigation\n        // should interrupt an MPA one?\n        // NOTE: This is intentionally using `throw` instead of `use` because we're\n        // inside an externally mutable condition (pushRef.mpaNavigation), which\n        // violates the rules of hooks.\n        throw _unresolvedthenable.unresolvedThenable;\n    }\n    (0, _react.useEffect)(()=>{\n        const originalPushState = window.history.pushState.bind(window.history);\n        const originalReplaceState = window.history.replaceState.bind(window.history);\n        // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n        const applyUrlFromHistoryPushReplace = (url)=>{\n            var _window_history_state;\n            const href = window.location.href;\n            const tree = (_window_history_state = window.history.state) == null ? void 0 : _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;\n            (0, _react.startTransition)(()=>{\n                (0, _useactionqueue.dispatchAppRouterAction)({\n                    type: _routerreducertypes.ACTION_RESTORE,\n                    url: new URL(url != null ? url : href, href),\n                    tree\n                });\n            });\n        };\n        /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.pushState = function pushState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalPushState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalPushState(data, _unused, url);\n        };\n        /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */ window.history.replaceState = function replaceState(data, _unused, url) {\n            // Avoid a loop when Next.js internals trigger pushState/replaceState\n            if ((data == null ? void 0 : data.__NA) || (data == null ? void 0 : data._N)) {\n                return originalReplaceState(data, _unused, url);\n            }\n            data = copyNextJsInternalHistoryState(data);\n            if (url) {\n                applyUrlFromHistoryPushReplace(url);\n            }\n            return originalReplaceState(data, _unused, url);\n        };\n        /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */ const onPopState = (event)=>{\n            if (!event.state) {\n                // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n                return;\n            }\n            // This case happens when the history entry was pushed by the `pages` router.\n            if (!event.state.__NA) {\n                window.location.reload();\n                return;\n            }\n            // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n            // Without startTransition works if the cache is there for this path\n            (0, _react.startTransition)(()=>{\n                (0, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);\n            });\n        };\n        // Register popstate event to call onPopstate.\n        window.addEventListener('popstate', onPopState);\n        return ()=>{\n            window.history.pushState = originalPushState;\n            window.history.replaceState = originalReplaceState;\n            window.removeEventListener('popstate', onPopState);\n        };\n    }, []);\n    const { cache, tree, nextUrl, focusAndScrollRef } = state;\n    const matchingHead = (0, _react.useMemo)(()=>{\n        return (0, _findheadincache.findHeadInCache)(cache, tree[1]);\n    }, [\n        cache,\n        tree\n    ]);\n    // Add memoized pathParams for useParams.\n    const pathParams = (0, _react.useMemo)(()=>{\n        return (0, _computechangedpath.getSelectedParams)(tree);\n    }, [\n        tree\n    ]);\n    const layoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            parentTree: tree,\n            parentCacheNode: cache,\n            parentSegmentPath: null,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl\n        };\n    }, [\n        tree,\n        cache,\n        canonicalUrl\n    ]);\n    const globalLayoutRouterContext = (0, _react.useMemo)(()=>{\n        return {\n            tree,\n            focusAndScrollRef,\n            nextUrl\n        };\n    }, [\n        tree,\n        focusAndScrollRef,\n        nextUrl\n    ]);\n    let head;\n    if (matchingHead !== null) {\n        // The head is wrapped in an extra component so we can use\n        // `useDeferredValue` to swap between the prefetched and final versions of\n        // the head. (This is what LayoutRouter does for segment data, too.)\n        //\n        // The `key` is used to remount the component whenever the head moves to\n        // a different segment.\n        const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;\n        head = /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n            headCacheNode: headCacheNode\n        },  false ? 0 : headKey);\n    } else {\n        head = null;\n    }\n    let content = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {\n        children: [\n            head,\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {\n                children: cache.rsc\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {\n                tree: tree\n            })\n        ]\n    });\n    if (true) {\n        // In development, we apply few error boundaries and hot-reloader:\n        // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n        // - HotReloader:\n        //  - hot-reload the app when the code changes\n        //  - render dev overlay\n        //  - catch runtime errors and display global-error when necessary\n        if (true) {\n            const { DevRootHTTPAccessFallbackBoundary } = __webpack_require__(/*! ./dev-root-http-access-fallback-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js\");\n            content = /*#__PURE__*/ (0, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {\n                children: content\n            });\n        }\n        const HotReloader = (__webpack_require__(/*! ../dev/hot-reloader/app/hot-reloader-app */ \"(app-pages-browser)/./node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js\")[\"default\"]);\n        content = /*#__PURE__*/ (0, _jsxruntime.jsx)(HotReloader, {\n            assetPrefix: assetPrefix,\n            globalError: globalError,\n            children: content\n        });\n    } else {}\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(HistoryUpdater, {\n                appRouterState: state\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(RuntimeStyles, {}),\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                value: pathParams,\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {\n                    value: pathname,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                        value: searchParams,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {\n                            value: globalLayoutRouterContext,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n                                value: _approuterinstance.publicAppRouterInstance,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n                                    value: layoutRouterContext,\n                                    children: content\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        ]\n    });\n}\n_c2 = Router;\nfunction AppRouter(param) {\n    let { actionQueue, globalErrorState, assetPrefix } = param;\n    (0, _navfailurehandler.useNavFailureHandler)();\n    const router = /*#__PURE__*/ (0, _jsxruntime.jsx)(Router, {\n        actionQueue: actionQueue,\n        assetPrefix: assetPrefix,\n        globalError: globalErrorState\n    });\n    // At the very top level, use the default GlobalError component as the final fallback.\n    // When the app router itself fails, which means the framework itself fails, we show the default error.\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_rooterrorboundary.default, {\n        errorComponent: _globalerror.default,\n        children: router\n    });\n}\n_c3 = AppRouter;\nconst runtimeStyles = new Set();\nlet runtimeStyleChanged = new Set();\nglobalThis._N_E_STYLE_LOAD = function(href) {\n    let len = runtimeStyles.size;\n    runtimeStyles.add(href);\n    if (runtimeStyles.size !== len) {\n        runtimeStyleChanged.forEach((cb)=>cb());\n    }\n    // TODO figure out how to get a promise here\n    // But maybe it's not necessary as react would block rendering until it's loaded\n    return Promise.resolve();\n};\nfunction RuntimeStyles() {\n    _s();\n    const [, forceUpdate] = _react.default.useState(0);\n    const renderedStylesSize = runtimeStyles.size;\n    (0, _react.useEffect)(()=>{\n        const changed = ()=>forceUpdate((c)=>c + 1);\n        runtimeStyleChanged.add(changed);\n        if (renderedStylesSize !== runtimeStyles.size) {\n            changed();\n        }\n        return ()=>{\n            runtimeStyleChanged.delete(changed);\n        };\n    }, [\n        renderedStylesSize,\n        forceUpdate\n    ]);\n    const dplId =  false ? 0 : '';\n    return [\n        ...runtimeStyles\n    ].map((href, i)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"stylesheet\",\n            href: \"\" + href + dplId,\n            // @ts-ignore\n            precedence: \"next\"\n        }, i));\n}\n_s(RuntimeStyles, \"Eht7Kgdrrgt5B4LSklQ7qDPo8Aw=\");\n_c4 = RuntimeStyles;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"HistoryUpdater\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Router\");\n$RefreshReg$(_c3, \"AppRouter\");\n$RefreshReg$(_c4, \"RuntimeStyles\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztJQTZJZ0JBLG9CQUFvQjtlQUFwQkE7O0lBOUVBQyxpQkFBaUI7ZUFBakJBOztJQXdmaEIsT0EwQkM7ZUExQnVCQzs7SUFuZ0JSQyxhQUFhO2VBQWJBOzs7Ozs7NkVBNUNUOzJEQUtBO2dEQUV3QjsrQ0FFRzs2REFLM0I7NENBQ2lEO21DQUNsQzt5Q0FDTTtnREFDTzs4Q0FDRjs2Q0FDRDtnREFDRzs0Q0FDSjt5Q0FDSDtnREFDTTsrQ0FFRzsrQ0FNOUI7c0NBQzJEOzJDQUNwQjttQ0FDYjt3RkFDSDtrRkFDQztnREFDSTtBQUVuQyxNQUFNQyxnQkFFRixDQUFDO0FBRUUsU0FBU0QsY0FBY0UsR0FBUTtJQUNwQyxPQUFPQSxJQUFJQyxNQUFNLEtBQUtDLE9BQU9DLFFBQVEsQ0FBQ0YsTUFBTTtBQUM5QztBQVNPLFNBQVNMLGtCQUFrQlEsSUFBWTtJQUM1QyxrREFBa0Q7SUFDbEQsSUFBSUMsQ0FBQUEsR0FBQUEsT0FBQUEsS0FBQUEsRUFBTUgsT0FBT0ksU0FBUyxDQUFDQyxTQUFTLEdBQUc7UUFDckMsT0FBTztJQUNUO0lBRUEsSUFBSVA7SUFDSixJQUFJO1FBQ0ZBLE1BQU0sSUFBSVEsSUFBSUMsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDTCxPQUFPRixPQUFPQyxRQUFRLENBQUNDLElBQUk7SUFDdkQsRUFBRSxPQUFPTSxHQUFHO1FBQ1YsMkVBQTJFO1FBQzNFLGtEQUFrRDtRQUNsRCxNQUFNLHFCQUVMLENBRkssSUFBSUMsTUFDUCxzQkFBbUJQLE9BQUssK0NBRHJCO21CQUFBO3dCQUFBOzBCQUFBO1FBRU47SUFDRjtJQUVBLHVFQUF1RTtJQUN2RSxJQUFJUSxJQUFvQixFQUFvQjtRQUMxQyxPQUFPO0lBQ1Q7SUFFQSxxREFBcUQ7SUFDckQsSUFBSWQsY0FBY0UsTUFB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VztXQUpOSDtBQVVYOztNQTdCU2xDIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvc3JjL2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QsIHtcbiAgdXNlRWZmZWN0LFxuICB1c2VNZW1vLFxuICBzdGFydFRyYW5zaXRpb24sXG4gIHVzZUluc2VydGlvbkVmZmVjdCxcbiAgdXNlRGVmZXJyZWRWYWx1ZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQge1xuICBBcHBSb3V0ZXJDb250ZXh0LFxuICBMYXlvdXRSb3V0ZXJDb250ZXh0LFxuICBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBBQ1RJT05fUkVTVE9SRSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEFwcFJvdXRlclN0YXRlIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7XG4gIFNlYXJjaFBhcmFtc0NvbnRleHQsXG4gIFBhdGhuYW1lQ29udGV4dCxcbiAgUGF0aFBhcmFtc0NvbnRleHQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbiwgdXNlQWN0aW9uUXVldWUgfSBmcm9tICcuL3VzZS1hY3Rpb24tcXVldWUnXG5pbXBvcnQgeyBpc0JvdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdCdcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi4vYWRkLWJhc2UtcGF0aCdcbmltcG9ydCB7IEFwcFJvdXRlckFubm91bmNlciB9IGZyb20gJy4vYXBwLXJvdXRlci1hbm5vdW5jZXInXG5pbXBvcnQgeyBSZWRpcmVjdEJvdW5kYXJ5IH0gZnJvbSAnLi9yZWRpcmVjdC1ib3VuZGFyeSdcbmltcG9ydCB7IGZpbmRIZWFkSW5DYWNoZSB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlJ1xuaW1wb3J0IHsgdW5yZXNvbHZlZFRoZW5hYmxlIH0gZnJvbSAnLi91bnJlc29sdmVkLXRoZW5hYmxlJ1xuaW1wb3J0IHsgcmVtb3ZlQmFzZVBhdGggfSBmcm9tICcuLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgZ2V0U2VsZWN0ZWRQYXJhbXMgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyL2NvbXB1dGUtY2hhbmdlZC1wYXRoJ1xuaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHsgdXNlTmF2RmFpbHVyZUhhbmRsZXIgfSBmcm9tICcuL25hdi1mYWlsdXJlLWhhbmRsZXInXG5pbXBvcnQge1xuICBkaXNwYXRjaFRyYXZlcnNlQWN0aW9uLFxuICBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgdHlwZSBBcHBSb3V0ZXJBY3Rpb25RdWV1ZSxcbiAgdHlwZSBHbG9iYWxFcnJvclN0YXRlLFxufSBmcm9tICcuL2FwcC1yb3V0ZXItaW5zdGFuY2UnXG5pbXBvcnQgeyBnZXRSZWRpcmVjdFR5cGVGcm9tRXJyb3IsIGdldFVSTEZyb21SZWRpcmVjdEVycm9yIH0gZnJvbSAnLi9yZWRpcmVjdCdcbmltcG9ydCB7IGlzUmVkaXJlY3RFcnJvciwgUmVkaXJlY3RUeXBlIH0gZnJvbSAnLi9yZWRpcmVjdC1lcnJvcidcbmltcG9ydCB7IHBpbmdWaXNpYmxlTGlua3MgfSBmcm9tICcuL2xpbmtzJ1xuaW1wb3J0IFJvb3RFcnJvckJvdW5kYXJ5IGZyb20gJy4vZXJyb3JzL3Jvb3QtZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgRGVmYXVsdEdsb2JhbEVycm9yIGZyb20gJy4vYnVpbHRpbi9nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBSb290TGF5b3V0Qm91bmRhcnkgfSBmcm9tICcuLi8uLi9saWIvZnJhbWV3b3JrL2JvdW5kYXJ5LWNvbXBvbmVudHMnXG5cbmNvbnN0IGdsb2JhbE11dGFibGU6IHtcbiAgcGVuZGluZ01wYVBhdGg/OiBzdHJpbmdcbn0gPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbFVSTCh1cmw6IFVSTCkge1xuICByZXR1cm4gdXJsLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpblxufVxuXG4vKipcbiAqIEdpdmVuIGEgbGluayBocmVmLCBjb25zdHJ1Y3RzIHRoZSBVUkwgdGhhdCBzaG91bGQgYmUgcHJlZmV0Y2hlZC4gUmV0dXJucyBudWxsXG4gKiBpbiBjYXNlcyB3aGVyZSBwcmVmZXRjaGluZyBzaG91bGQgYmUgZGlzYWJsZWQsIGxpa2UgZXh0ZXJuYWwgVVJMcywgb3JcbiAqIGR1cmluZyBkZXZlbG9wbWVudC5cbiAqIEBwYXJhbSBocmVmIFRoZSBocmVmIHBhc3NlZCB0byA8TGluaz4sIHJvdXRlci5wcmVmZXRjaCgpLCBvciBzaW1pbGFyXG4gKiBAcmV0dXJucyBBIFVSTCBvYmplY3QgdG8gcHJlZmV0Y2gsIG9yIG51bGwgaWYgcHJlZmV0Y2hpbmcgc2hvdWxkIGJlIGRpc2FibGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcmVmZXRjaFVSTChocmVmOiBzdHJpbmcpOiBVUkwgfCBudWxsIHtcbiAgLy8gRG9uJ3QgcHJlZmV0Y2ggZm9yIGJvdHMgYXMgdGhleSBkb24ndCBuYXZpZ2F0ZS5cbiAgaWYgKGlzQm90KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBsZXQgdXJsOiBVUkxcbiAgdHJ5IHtcbiAgICB1cmwgPSBuZXcgVVJMKGFkZEJhc2VQYXRoKGhyZWYpLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHRvIHRocm93IG9yIGNhbiB3ZSBqdXN0IGNvbnNvbGUuZXJyb3IgaW5zdGVhZD8gRG9lc1xuICAgIC8vIGFueW9uZSByZWx5IG9uIHRoaXMgdGhyb3dpbmc/IChTZWVtcyB1bmxpa2VseS4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBwcmVmZXRjaCAnJHtocmVmfScgYmVjYXVzZSBpdCBjYW5ub3QgYmUgY29udmVydGVkIHRvIGEgVVJMLmBcbiAgICApXG4gIH1cblxuICAvLyBEb24ndCBwcmVmZXRjaCBkdXJpbmcgZGV2ZWxvcG1lbnQgKGltcHJvdmVzIGNvbXBpbGF0aW9uIHBlcmZvcm1hbmNlKVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gRXh0ZXJuYWwgdXJscyBjYW4ndCBiZSBwcmVmZXRjaGVkIGluIHRoZSBzYW1lIHdheS5cbiAgaWYgKGlzRXh0ZXJuYWxVUkwodXJsKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIEhpc3RvcnlVcGRhdGVyKHtcbiAgYXBwUm91dGVyU3RhdGUsXG59OiB7XG4gIGFwcFJvdXRlclN0YXRlOiBBcHBSb3V0ZXJTdGF0ZVxufSkge1xuICB1c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQVBQX05BVl9GQUlMX0hBTkRMSU5HKSB7XG4gICAgICAvLyBjbGVhciBwZW5kaW5nIFVSTCBhcyBuYXZpZ2F0aW9uIGlzIG5vIGxvbmdlclxuICAgICAgLy8gaW4gZmxpZ2h0XG4gICAgICB3aW5kb3cubmV4dC5fX3BlbmRpbmdVcmwgPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCB7IHRyZWUsIHB1c2hSZWYsIGNhbm9uaWNhbFVybCB9ID0gYXBwUm91dGVyU3RhdGVcbiAgICBjb25zdCBoaXN0b3J5U3RhdGUgPSB7XG4gICAgICAuLi4ocHVzaFJlZi5wcmVzZXJ2ZUN1c3RvbUhpc3RvcnlTdGF0ZSA/IHdpbmRvdy5oaXN0b3J5LnN0YXRlIDoge30pLFxuICAgICAgLy8gSWRlbnRpZmllciBpcyBzaG9ydGVuZWQgaW50ZW50aW9uYWxseS5cbiAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgIC8vIF9fTiBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBvbGQgcm91dGVyLlxuICAgICAgX19OQTogdHJ1ZSxcbiAgICAgIF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUU6IHRyZWUsXG4gICAgfVxuICAgIGlmIChcbiAgICAgIHB1c2hSZWYucGVuZGluZ1B1c2ggJiZcbiAgICAgIC8vIFNraXAgcHVzaGluZyBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkgaWYgdGhlIGNhbm9uaWNhbFVybCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB1cmwuXG4gICAgICAvLyBUaGlzIG1pcnJvcnMgdGhlIGJyb3dzZXIgYmVoYXZpb3IgZm9yIG5vcm1hbCBuYXZpZ2F0aW9uLlxuICAgICAgY3JlYXRlSHJlZkZyb21VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBjYW5vbmljYWxVcmxcbiAgICApIHtcbiAgICAgIC8vIFRoaXMgaW50ZW50aW9uYWxseSBtdXRhdGVzIFJlYWN0IHN0YXRlLCBwdXNoUmVmIGlzIG92ZXJ3cml0dGVuIHRvIGVuc3VyZSBhZGRpdGlvbmFsIHB1c2gvcmVwbGFjZSBjYWxscyBkbyBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIGhpc3RvcnkgZW50cnkuXG4gICAgICBwdXNoUmVmLnBlbmRpbmdQdXNoID0gZmFsc2VcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCBjYW5vbmljYWxVcmwpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyU3RhdGVdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVGhlIE5leHQtVXJsIGFuZCB0aGUgYmFzZSB0cmVlIG1heSBhZmZlY3QgdGhlIHJlc3VsdCBvZiBhIHByZWZldGNoXG4gICAgLy8gdGFzay4gUmUtcHJlZmV0Y2ggYWxsIHZpc2libGUgbGlua3Mgd2l0aCB0aGUgdXBkYXRlZCB2YWx1ZXMuIEluIG1vc3RcbiAgICAvLyBjYXNlcywgdGhpcyB3aWxsIG5vdCByZXN1bHQgaW4gYW55IG5ldyBuZXR3b3JrIHJlcXVlc3RzLCBvbmx5IGlmXG4gICAgLy8gdGhlIHByZWZldGNoIHJlc3VsdCBhY3R1YWxseSB2YXJpZXMgb24gb25lIG9mIHRoZXNlIGlucHV0cy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgICBwaW5nVmlzaWJsZUxpbmtzKGFwcFJvdXRlclN0YXRlLm5leHRVcmwsIGFwcFJvdXRlclN0YXRlLnRyZWUpXG4gICAgfVxuICB9LCBbYXBwUm91dGVyU3RhdGUubmV4dFVybCwgYXBwUm91dGVyU3RhdGUudHJlZV0pXG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5Q2FjaGVOb2RlKCk6IENhY2hlTm9kZSB7XG4gIHJldHVybiB7XG4gICAgbGF6eURhdGE6IG51bGwsXG4gICAgcnNjOiBudWxsLFxuICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgIGhlYWQ6IG51bGwsXG4gICAgcHJlZmV0Y2hIZWFkOiBudWxsLFxuICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKCksXG4gICAgbG9hZGluZzogbnVsbCxcbiAgICBuYXZpZ2F0ZWRBdDogLTEsXG4gIH1cbn1cblxuZnVuY3Rpb24gY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlKGRhdGE6IGFueSkge1xuICBpZiAoZGF0YSA9PSBudWxsKSBkYXRhID0ge31cbiAgY29uc3QgY3VycmVudFN0YXRlID0gd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgY29uc3QgX19OQSA9IGN1cnJlbnRTdGF0ZT8uX19OQVxuICBpZiAoX19OQSkge1xuICAgIGRhdGEuX19OQSA9IF9fTkFcbiAgfVxuICBjb25zdCBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFID1cbiAgICBjdXJyZW50U3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcbiAgaWYgKF9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUpIHtcbiAgICBkYXRhLl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUgPSBfX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFXG4gIH1cblxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBIZWFkKHtcbiAgaGVhZENhY2hlTm9kZSxcbn06IHtcbiAgaGVhZENhY2hlTm9kZTogQ2FjaGVOb2RlIHwgbnVsbFxufSk6IFJlYWN0LlJlYWN0Tm9kZSB7XG4gIC8vIElmIHRoaXMgc2VnbWVudCBoYXMgYSBgcHJlZmV0Y2hIZWFkYCwgaXQncyB0aGUgc3RhdGljYWxseSBwcmVmZXRjaGVkIGRhdGEuXG4gIC8vIFdlIHNob3VsZCB1c2UgdGhhdCBvbiBpbml0aWFsIHJlbmRlciBpbnN0ZWFkIG9mIGBoZWFkYC4gVGhlbiB3ZSdsbCBzd2l0Y2hcbiAgLy8gdG8gYGhlYWRgIHdoZW4gdGhlIGR5bmFtaWMgcmVzcG9uc2Ugc3RyZWFtcyBpbi5cbiAgY29uc3QgaGVhZCA9IGhlYWRDYWNoZU5vZGUgIT09IG51bGwgPyBoZWFkQ2FjaGVOb2RlLmhlYWQgOiBudWxsXG4gIGNvbnN0IHByZWZldGNoSGVhZCA9XG4gICAgaGVhZENhY2hlTm9kZSAhPT0gbnVsbCA/IGhlYWRDYWNoZU5vZGUucHJlZmV0Y2hIZWFkIDogbnVsbFxuXG4gIC8vIElmIG5vIHByZWZldGNoIGRhdGEgaXMgYXZhaWxhYmxlLCB0aGVuIHdlIGdvIHN0cmFpZ2h0IHRvIHJlbmRlcmluZyBgaGVhZGAuXG4gIGNvbnN0IHJlc29sdmVkUHJlZmV0Y2hSc2MgPSBwcmVmZXRjaEhlYWQgIT09IG51bGwgPyBwcmVmZXRjaEhlYWQgOiBoZWFkXG5cbiAgLy8gV2UgdXNlIGB1c2VEZWZlcnJlZFZhbHVlYCB0byBoYW5kbGUgc3dpdGNoaW5nIGJldHdlZW4gdGhlIHByZWZldGNoZWQgYW5kXG4gIC8vIGZpbmFsIHZhbHVlcy4gVGhlIHNlY29uZCBhcmd1bWVudCBpcyByZXR1cm5lZCBvbiBpbml0aWFsIHJlbmRlciwgdGhlbiBpdFxuICAvLyByZS1yZW5kZXJzIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50LlxuICByZXR1cm4gdXNlRGVmZXJyZWRWYWx1ZShoZWFkLCByZXNvbHZlZFByZWZldGNoUnNjKVxufVxuXG4vKipcbiAqIFRoZSBnbG9iYWwgcm91dGVyIHRoYXQgd3JhcHMgdGhlIGFwcGxpY2F0aW9uIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIFJvdXRlcih7XG4gIGFjdGlvblF1ZXVlLFxuICBhc3NldFByZWZpeCxcbiAgZ2xvYmFsRXJyb3IsXG59OiB7XG4gIGFjdGlvblF1ZXVlOiBBcHBSb3V0ZXJBY3Rpb25RdWV1ZVxuICBhc3NldFByZWZpeDogc3RyaW5nXG4gIGdsb2JhbEVycm9yOiBHbG9iYWxFcnJvclN0YXRlXG59KSB7XG4gIGNvbnN0IHN0YXRlID0gdXNlQWN0aW9uUXVldWUoYWN0aW9uUXVldWUpXG4gIGNvbnN0IHsgY2Fub25pY2FsVXJsIH0gPSBzdGF0ZVxuICAvLyBBZGQgbWVtb2l6ZWQgcGF0aG5hbWUvcXVlcnkgZm9yIHVzZVNlYXJjaFBhcmFtcyBhbmQgdXNlUGF0aG5hbWUuXG4gIGNvbnN0IHsgc2VhcmNoUGFyYW1zLCBwYXRobmFtZSB9ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGNhbm9uaWNhbFVybCxcbiAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFRoaXMgaXMgdHVybmVkIGludG8gYSByZWFkb25seSBjbGFzcyBpbiBgdXNlU2VhcmNoUGFyYW1zYFxuICAgICAgc2VhcmNoUGFyYW1zOiB1cmwuc2VhcmNoUGFyYW1zLFxuICAgICAgcGF0aG5hbWU6IGhhc0Jhc2VQYXRoKHVybC5wYXRobmFtZSlcbiAgICAgICAgPyByZW1vdmVCYXNlUGF0aCh1cmwucGF0aG5hbWUpXG4gICAgICAgIDogdXJsLnBhdGhuYW1lLFxuICAgIH1cbiAgfSwgW2Nhbm9uaWNhbFVybF0pXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCB7IGNhY2hlLCBwcmVmZXRjaENhY2hlLCB0cmVlIH0gPSBzdGF0ZVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gQWRkIGB3aW5kb3cubmRgIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgICAvLyBUaGlzIGlzIG5vdCBtZWFudCBmb3IgdXNlIGluIGFwcGxpY2F0aW9ucyBhcyBjb25jdXJyZW50IHJlbmRlcmluZyB3aWxsIGFmZmVjdCB0aGUgY2FjaGUvdHJlZS9yb3V0ZXIuXG4gICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgZm9yIGRlYnVnZ2luZ1xuICAgICAgd2luZG93Lm5kID0ge1xuICAgICAgICByb3V0ZXI6IHB1YmxpY0FwcFJvdXRlckluc3RhbmNlLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgcHJlZmV0Y2hDYWNoZSxcbiAgICAgICAgdHJlZSxcbiAgICAgIH1cbiAgICB9LCBbY2FjaGUsIHByZWZldGNoQ2FjaGUsIHRyZWVdKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgYXBwIGlzIHJlc3RvcmVkIGZyb20gYmZjYWNoZSwgaXQncyBwb3NzaWJsZSB0aGF0XG4gICAgLy8gcHVzaFJlZi5tcGFOYXZpZ2F0aW9uIGlzIHRydWUsIHdoaWNoIHdvdWxkIG1lYW4gdGhhdCBhbnkgcmUtcmVuZGVyIG9mIHRoaXMgY29tcG9uZW50XG4gICAgLy8gd291bGQgdHJpZ2dlciB0aGUgbXBhIG5hdmlnYXRpb24gbG9naWMgYWdhaW4gZnJvbSB0aGUgbGluZXMgYmVsb3cuXG4gICAgLy8gVGhpcyB3aWxsIHJlc3RvcmUgdGhlIHJvdXRlciB0byB0aGUgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgYXBwIGlzIHJlc3RvcmVkIGZyb20gYmZjYWNoZS5cbiAgICBmdW5jdGlvbiBoYW5kbGVQYWdlU2hvdyhldmVudDogUGFnZVRyYW5zaXRpb25FdmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAhZXZlbnQucGVyc2lzdGVkIHx8XG4gICAgICAgICF3aW5kb3cuaGlzdG9yeS5zdGF0ZT8uX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBDbGVhciB0aGUgcGVuZGluZ01wYVBhdGggdmFsdWUgc28gdGhhdCBhIHN1YnNlcXVlbnQgTVBBIG5hdmlnYXRpb24gdG8gdGhlIHNhbWUgVVJMIGNhbiBiZSB0cmlnZ2VyZWQuXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGlmIHRoZSBicm93c2VyIHJlc3RvcmVkIGZyb20gYmZjYWNoZSwgdGhlIHBlbmRpbmdNcGFQYXRoIHdvdWxkIHN0aWxsIGJlIHNldCB0byB0aGUgdmFsdWVcbiAgICAgIC8vIG9mIHRoZSBsYXN0IE1QQSBuYXZpZ2F0aW9uLlxuICAgICAgZ2xvYmFsTXV0YWJsZS5wZW5kaW5nTXBhUGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgICBkaXNwYXRjaEFwcFJvdXRlckFjdGlvbih7XG4gICAgICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgICAgICB1cmw6IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpLFxuICAgICAgICB0cmVlOiB3aW5kb3cuaGlzdG9yeS5zdGF0ZS5fX1BSSVZBVEVfTkVYVEpTX0lOVEVSTkFMU19UUkVFLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBoYW5kbGVQYWdlU2hvdylcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBoYW5kbGVQYWdlU2hvdylcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRW5zdXJlIHRoYXQgYW55IHJlZGlyZWN0IGVycm9ycyB0aGF0IGJ1YmJsZSB1cCBvdXRzaWRlIG9mIHRoZSBSZWRpcmVjdEJvdW5kYXJ5XG4gICAgLy8gYXJlIGNhdWdodCBhbmQgaGFuZGxlZCBieSB0aGUgcm91dGVyLlxuICAgIGZ1bmN0aW9uIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KFxuICAgICAgZXZlbnQ6IEVycm9yRXZlbnQgfCBQcm9taXNlUmVqZWN0aW9uRXZlbnRcbiAgICApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gJ3JlYXNvbicgaW4gZXZlbnQgPyBldmVudC5yZWFzb24gOiBldmVudC5lcnJvclxuICAgICAgaWYgKGlzUmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBjb25zdCB1cmwgPSBnZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcilcbiAgICAgICAgY29uc3QgcmVkaXJlY3RUeXBlID0gZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yKGVycm9yKVxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBhY2Nlc3MgdGhlIHJvdXRlciBtZXRob2RzIGRpcmVjdGx5LCByYXRoZXIgdGhhblxuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICAgICAgICBpZiAocmVkaXJlY3RUeXBlID09PSBSZWRpcmVjdFR5cGUucHVzaCkge1xuICAgICAgICAgIHB1YmxpY0FwcFJvdXRlckluc3RhbmNlLnB1c2godXJsLCB7fSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdWJsaWNBcHBSb3V0ZXJJbnN0YW5jZS5yZXBsYWNlKHVybCwge30pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlVW5oYW5kbGVkUmVkaXJlY3QpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIGhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgLy8gV2hlbiBtcGFOYXZpZ2F0aW9uIGZsYWcgaXMgc2V0IGRvIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBuZXcgdXJsLlxuICAvLyBJbmZpbml0ZWx5IHN1c3BlbmQgYmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSB3YW50IHRvIHJlcmVuZGVyIGFueSBjaGlsZFxuICAvLyBjb21wb25lbnRzIHdpdGggdGhlIG5ldyBVUkwgYW5kIGFueSBlbnRhbmdsZWQgc3RhdGUgdXBkYXRlcyBzaG91bGRuJ3RcbiAgLy8gY29tbWl0IGVpdGhlciAoZWc6IHVzZVRyYW5zaXRpb24gaXNQZW5kaW5nIHNob3VsZCBzdGF5IHRydWUgdW50aWwgdGhlIHBhZ2VcbiAgLy8gdW5sb2FkcykuXG4gIC8vXG4gIC8vIFRoaXMgaXMgYSBzaWRlIGVmZmVjdCBpbiByZW5kZXIuIERvbid0IHRyeSB0aGlzIGF0IGhvbWUsIGtpZHMuIEl0J3NcbiAgLy8gcHJvYmFibHkgc2FmZSBiZWNhdXNlIHdlIGtub3cgdGhpcyBpcyBhIHNpbmdsZXRvbiBjb21wb25lbnQgYW5kIGl0J3MgbmV2ZXJcbiAgLy8gaW4gPE9mZnNjcmVlbj4uIEF0IGxlYXN0IEkgaG9wZSBzby4gKEl0IHdpbGwgcnVuIHR3aWNlIGluIGRldiBzdHJpY3QgbW9kZSxcbiAgLy8gYnV0IHRoYXQncy4uLiBmaW5lPylcbiAgY29uc3QgeyBwdXNoUmVmIH0gPSBzdGF0ZVxuICBpZiAocHVzaFJlZi5tcGFOYXZpZ2F0aW9uKSB7XG4gICAgLy8gaWYgdGhlcmUncyBhIHJlLXJlbmRlciwgd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyIGFub3RoZXIgcmVkaXJlY3QgaWYgb25lIGlzIGFscmVhZHkgaW4gZmxpZ2h0IHRvIHRoZSBzYW1lIFVSTFxuICAgIGlmIChnbG9iYWxNdXRhYmxlLnBlbmRpbmdNcGFQYXRoICE9PSBjYW5vbmljYWxVcmwpIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uXG4gICAgICBpZiAocHVzaFJlZi5wZW5kaW5nUHVzaCkge1xuICAgICAgICBsb2NhdGlvbi5hc3NpZ24oY2Fub25pY2FsVXJsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYXRpb24ucmVwbGFjZShjYW5vbmljYWxVcmwpXG4gICAgICB9XG5cbiAgICAgIGdsb2JhbE11dGFibGUucGVuZGluZ01wYVBhdGggPSBjYW5vbmljYWxVcmxcbiAgICB9XG4gICAgLy8gVE9ETy1BUFA6IFNob3VsZCB3ZSBsaXN0ZW4gdG8gbmF2aWdhdGVlcnJvciBoZXJlIHRvIGNhdGNoIGZhaWxlZFxuICAgIC8vIG5hdmlnYXRpb25zIHNvbWVob3c/IEFuZCBzaG91bGQgd2UgY2FsbCB3aW5kb3cuc3RvcCgpIGlmIGEgU1BBIG5hdmlnYXRpb25cbiAgICAvLyBzaG91bGQgaW50ZXJydXB0IGFuIE1QQSBvbmU/XG4gICAgLy8gTk9URTogVGhpcyBpcyBpbnRlbnRpb25hbGx5IHVzaW5nIGB0aHJvd2AgaW5zdGVhZCBvZiBgdXNlYCBiZWNhdXNlIHdlJ3JlXG4gICAgLy8gaW5zaWRlIGFuIGV4dGVybmFsbHkgbXV0YWJsZSBjb25kaXRpb24gKHB1c2hSZWYubXBhTmF2aWdhdGlvbiksIHdoaWNoXG4gICAgLy8gdmlvbGF0ZXMgdGhlIHJ1bGVzIG9mIGhvb2tzLlxuICAgIHRocm93IHVucmVzb2x2ZWRUaGVuYWJsZVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbFB1c2hTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZS5iaW5kKHdpbmRvdy5oaXN0b3J5KVxuICAgIGNvbnN0IG9yaWdpbmFsUmVwbGFjZVN0YXRlID0gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlLmJpbmQoXG4gICAgICB3aW5kb3cuaGlzdG9yeVxuICAgIClcblxuICAgIC8vIEVuc3VyZSB0aGUgY2Fub25pY2FsIFVSTCBpbiB0aGUgTmV4dC5qcyBSb3V0ZXIgaXMgdXBkYXRlZCB3aGVuIHRoZSBVUkwgaXMgY2hhbmdlZCBzbyB0aGF0IGB1c2VQYXRobmFtZWAgYW5kIGB1c2VTZWFyY2hQYXJhbXNgIGhvbGQgdGhlIHB1c2hlZCB2YWx1ZXMuXG4gICAgY29uc3QgYXBwbHlVcmxGcm9tSGlzdG9yeVB1c2hSZXBsYWNlID0gKFxuICAgICAgdXJsOiBzdHJpbmcgfCBVUkwgfCBudWxsIHwgdW5kZWZpbmVkXG4gICAgKSA9PiB7XG4gICAgICBjb25zdCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgIGNvbnN0IHRyZWU6IEZsaWdodFJvdXRlclN0YXRlIHwgdW5kZWZpbmVkID1cbiAgICAgICAgd2luZG93Lmhpc3Rvcnkuc3RhdGU/Ll9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUVcblxuICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24oe1xuICAgICAgICAgIHR5cGU6IEFDVElPTl9SRVNUT1JFLFxuICAgICAgICAgIHVybDogbmV3IFVSTCh1cmwgPz8gaHJlZiwgaHJlZiksXG4gICAgICAgICAgdHJlZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0Y2ggcHVzaFN0YXRlIHRvIGVuc3VyZSBleHRlcm5hbCBjaGFuZ2VzIHRvIHRoZSBoaXN0b3J5IGFyZSByZWZsZWN0ZWQgaW4gdGhlIE5leHQuanMgUm91dGVyLlxuICAgICAqIEVuc3VyZXMgTmV4dC5qcyBpbnRlcm5hbCBoaXN0b3J5IHN0YXRlIGlzIGNvcGllZCB0byB0aGUgbmV3IGhpc3RvcnkgZW50cnkuXG4gICAgICogRW5zdXJlcyB1c2VQYXRobmFtZSBhbmQgdXNlU2VhcmNoUGFyYW1zIGhvbGQgdGhlIG5ld2x5IHByb3ZpZGVkIHVybC5cbiAgICAgKi9cbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbiBwdXNoU3RhdGUoXG4gICAgICBkYXRhOiBhbnksXG4gICAgICBfdW51c2VkOiBzdHJpbmcsXG4gICAgICB1cmw/OiBzdHJpbmcgfCBVUkwgfCBudWxsXG4gICAgKTogdm9pZCB7XG4gICAgICAvLyBBdm9pZCBhIGxvb3Agd2hlbiBOZXh0LmpzIGludGVybmFscyB0cmlnZ2VyIHB1c2hTdGF0ZS9yZXBsYWNlU3RhdGVcbiAgICAgIGlmIChkYXRhPy5fX05BIHx8IGRhdGE/Ll9OKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFB1c2hTdGF0ZShkYXRhLCBfdW51c2VkLCB1cmwpXG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBjb3B5TmV4dEpzSW50ZXJuYWxIaXN0b3J5U3RhdGUoZGF0YSlcblxuICAgICAgaWYgKHVybCkge1xuICAgICAgICBhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UodXJsKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3JpZ2luYWxQdXNoU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhdGNoIHJlcGxhY2VTdGF0ZSB0byBlbnN1cmUgZXh0ZXJuYWwgY2hhbmdlcyB0byB0aGUgaGlzdG9yeSBhcmUgcmVmbGVjdGVkIGluIHRoZSBOZXh0LmpzIFJvdXRlci5cbiAgICAgKiBFbnN1cmVzIE5leHQuanMgaW50ZXJuYWwgaGlzdG9yeSBzdGF0ZSBpcyBjb3BpZWQgdG8gdGhlIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgICAqIEVuc3VyZXMgdXNlUGF0aG5hbWUgYW5kIHVzZVNlYXJjaFBhcmFtcyBob2xkIHRoZSBuZXdseSBwcm92aWRlZCB1cmwuXG4gICAgICovXG4gICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gcmVwbGFjZVN0YXRlKFxuICAgICAgZGF0YTogYW55LFxuICAgICAgX3VudXNlZDogc3RyaW5nLFxuICAgICAgdXJsPzogc3RyaW5nIHwgVVJMIHwgbnVsbFxuICAgICk6IHZvaWQge1xuICAgICAgLy8gQXZvaWQgYSBsb29wIHdoZW4gTmV4dC5qcyBpbnRlcm5hbHMgdHJpZ2dlciBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlXG4gICAgICBpZiAoZGF0YT8uX19OQSB8fCBkYXRhPy5fTikge1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXBsYWNlU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgICAgfVxuICAgICAgZGF0YSA9IGNvcHlOZXh0SnNJbnRlcm5hbEhpc3RvcnlTdGF0ZShkYXRhKVxuXG4gICAgICBpZiAodXJsKSB7XG4gICAgICAgIGFwcGx5VXJsRnJvbUhpc3RvcnlQdXNoUmVwbGFjZSh1cmwpXG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxSZXBsYWNlU3RhdGUoZGF0YSwgX3VudXNlZCwgdXJsKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBwb3BzdGF0ZSBldmVudCwgdGhpcyBpcyB1c2VkIHRvIGhhbmRsZSBiYWNrL2ZvcndhcmQgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQnkgZGVmYXVsdCBkaXNwYXRjaGVzIEFDVElPTl9SRVNUT1JFLCBob3dldmVyIGlmIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBub3QgcHVzaGVkL3JlcGxhY2VkIGJ5IGFwcC1yb3V0ZXIgaXQgd2lsbCByZWxvYWQgdGhlIHBhZ2UuXG4gICAgICogVGhhdCBjYXNlIGNhbiBoYXBwZW4gd2hlbiB0aGUgb2xkIHJvdXRlciBpbmplY3RlZCB0aGUgaGlzdG9yeSBlbnRyeS5cbiAgICAgKi9cbiAgICBjb25zdCBvblBvcFN0YXRlID0gKGV2ZW50OiBQb3BTdGF0ZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoIWV2ZW50LnN0YXRlKSB7XG4gICAgICAgIC8vIFRPRE8tQVBQOiB0aGlzIGNhc2Ugb25seSBoYXBwZW5zIHdoZW4gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSB3YXMgY2FsbGVkIG91dHNpZGUgb2YgTmV4dC5qcy4gSXQgc2hvdWxkIHByb2JhYmx5IHJlbG9hZCB0aGUgcGFnZSBpbiB0aGlzIGNhc2UuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBwdXNoZWQgYnkgdGhlIGBwYWdlc2Agcm91dGVyLlxuICAgICAgaWYgKCFldmVudC5zdGF0ZS5fX05BKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETy1BUFA6IElkZWFsbHkgdGhlIGJhY2sgYnV0dG9uIHNob3VsZCBub3QgdXNlIHN0YXJ0VHJhbnNpdGlvbiBhcyBpdCBzaG91bGQgYXBwbHkgdGhlIHVwZGF0ZXMgc3luY2hyb25vdXNseVxuICAgICAgLy8gV2l0aG91dCBzdGFydFRyYW5zaXRpb24gd29ya3MgaWYgdGhlIGNhY2hlIGlzIHRoZXJlIGZvciB0aGlzIHBhdGhcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoVHJhdmVyc2VBY3Rpb24oXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgZXZlbnQuc3RhdGUuX19QUklWQVRFX05FWFRKU19JTlRFUk5BTFNfVFJFRVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIHBvcHN0YXRlIGV2ZW50IHRvIGNhbGwgb25Qb3BzdGF0ZS5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBvblBvcFN0YXRlKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPSBvcmlnaW5hbFB1c2hTdGF0ZVxuICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gb3JpZ2luYWxSZXBsYWNlU3RhdGVcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIG9uUG9wU3RhdGUpXG4gICAgfVxuICB9LCBbXSlcblxuICBjb25zdCB7IGNhY2hlLCB0cmVlLCBuZXh0VXJsLCBmb2N1c0FuZFNjcm9sbFJlZiB9ID0gc3RhdGVcblxuICBjb25zdCBtYXRjaGluZ0hlYWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gZmluZEhlYWRJbkNhY2hlKGNhY2hlLCB0cmVlWzFdKVxuICB9LCBbY2FjaGUsIHRyZWVdKVxuXG4gIC8vIEFkZCBtZW1vaXplZCBwYXRoUGFyYW1zIGZvciB1c2VQYXJhbXMuXG4gIGNvbnN0IHBhdGhQYXJhbXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gZ2V0U2VsZWN0ZWRQYXJhbXModHJlZSlcbiAgfSwgW3RyZWVdKVxuXG4gIGNvbnN0IGxheW91dFJvdXRlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFyZW50VHJlZTogdHJlZSxcbiAgICAgIHBhcmVudENhY2hlTm9kZTogY2FjaGUsXG4gICAgICBwYXJlbnRTZWdtZW50UGF0aDogbnVsbCxcbiAgICAgIC8vIFJvb3Qgbm9kZSBhbHdheXMgaGFzIGB1cmxgXG4gICAgICAvLyBQcm92aWRlZCBpbiBBcHBUcmVlQ29udGV4dCB0byBlbnN1cmUgaXQgY2FuIGJlIG92ZXJ3cml0dGVuIGluIGxheW91dC1yb3V0ZXJcbiAgICAgIHVybDogY2Fub25pY2FsVXJsLFxuICAgIH1cbiAgfSwgW3RyZWUsIGNhY2hlLCBjYW5vbmljYWxVcmxdKVxuXG4gIGNvbnN0IGdsb2JhbExheW91dFJvdXRlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJlZSxcbiAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgbmV4dFVybCxcbiAgICB9XG4gIH0sIFt0cmVlLCBmb2N1c0FuZFNjcm9sbFJlZiwgbmV4dFVybF0pXG5cbiAgbGV0IGhlYWRcbiAgaWYgKG1hdGNoaW5nSGVhZCAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBoZWFkIGlzIHdyYXBwZWQgaW4gYW4gZXh0cmEgY29tcG9uZW50IHNvIHdlIGNhbiB1c2VcbiAgICAvLyBgdXNlRGVmZXJyZWRWYWx1ZWAgdG8gc3dhcCBiZXR3ZWVuIHRoZSBwcmVmZXRjaGVkIGFuZCBmaW5hbCB2ZXJzaW9ucyBvZlxuICAgIC8vIHRoZSBoZWFkLiAoVGhpcyBpcyB3aGF0IExheW91dFJvdXRlciBkb2VzIGZvciBzZWdtZW50IGRhdGEsIHRvby4pXG4gICAgLy9cbiAgICAvLyBUaGUgYGtleWAgaXMgdXNlZCB0byByZW1vdW50IHRoZSBjb21wb25lbnQgd2hlbmV2ZXIgdGhlIGhlYWQgbW92ZXMgdG9cbiAgICAvLyBhIGRpZmZlcmVudCBzZWdtZW50LlxuICAgIGNvbnN0IFtoZWFkQ2FjaGVOb2RlLCBoZWFkS2V5LCBoZWFkS2V5V2l0aG91dFNlYXJjaFBhcmFtc10gPSBtYXRjaGluZ0hlYWRcblxuICAgIGhlYWQgPSAoXG4gICAgICA8SGVhZFxuICAgICAgICBrZXk9e1xuICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgUFBSOiBvbWl0IHNlYXJjaCBwYXJhbXMgZnJvbSB0aGUga2V5IHRvIG1hdGNoIHByZXJlbmRlcmVkIGtleXNcbiAgICAgICAgICB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGhlYWRLZXlXaXRob3V0U2VhcmNoUGFyYW1zIDogaGVhZEtleVxuICAgICAgICB9XG4gICAgICAgIGhlYWRDYWNoZU5vZGU9e2hlYWRDYWNoZU5vZGV9XG4gICAgICAvPlxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBoZWFkID0gbnVsbFxuICB9XG5cbiAgbGV0IGNvbnRlbnQgPSAoXG4gICAgPFJlZGlyZWN0Qm91bmRhcnk+XG4gICAgICB7aGVhZH1cbiAgICAgIHsvKiBSb290TGF5b3V0Qm91bmRhcnkgZW5hYmxlcyBkZXRlY3Rpb24gb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhcm91bmQgdGhlIHJvb3QgbGF5b3V0LlxuICAgICAgICAgIFdoZW4gdXNlcnMgd3JhcCB0aGVpciBsYXlvdXQgaW4gPFN1c3BlbnNlPiwgdGhpcyBjcmVhdGVzIHRoZSBjb21wb25lbnQgc3RhY2sgcGF0dGVyblxuICAgICAgICAgIFwiU3VzcGVuc2UgLT4gUm9vdExheW91dEJvdW5kYXJ5XCIgd2hpY2ggZHluYW1pYy1yZW5kZXJpbmcudHMgdXNlcyB0byBhbGxvdyBkeW5hbWljIHJlbmRlcmluZy4gKi99XG4gICAgICA8Um9vdExheW91dEJvdW5kYXJ5PntjYWNoZS5yc2N9PC9Sb290TGF5b3V0Qm91bmRhcnk+XG4gICAgICA8QXBwUm91dGVyQW5ub3VuY2VyIHRyZWU9e3RyZWV9IC8+XG4gICAgPC9SZWRpcmVjdEJvdW5kYXJ5PlxuICApXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgYXBwbHkgZmV3IGVycm9yIGJvdW5kYXJpZXMgYW5kIGhvdC1yZWxvYWRlcjpcbiAgICAvLyAtIERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeTogYXZvaWQgdXNpbmcgbmF2aWdhdGlvbiBBUEkgbGlrZSBub3RGb3VuZCgpIGluIHJvb3QgbGF5b3V0XG4gICAgLy8gLSBIb3RSZWxvYWRlcjpcbiAgICAvLyAgLSBob3QtcmVsb2FkIHRoZSBhcHAgd2hlbiB0aGUgY29kZSBjaGFuZ2VzXG4gICAgLy8gIC0gcmVuZGVyIGRldiBvdmVybGF5XG4gICAgLy8gIC0gY2F0Y2ggcnVudGltZSBlcnJvcnMgYW5kIGRpc3BsYXkgZ2xvYmFsLWVycm9yIHdoZW4gbmVjZXNzYXJ5XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSB9ID1cbiAgICAgICAgcmVxdWlyZSgnLi9kZXYtcm9vdC1odHRwLWFjY2Vzcy1mYWxsYmFjay1ib3VuZGFyeScpIGFzIHR5cGVvZiBpbXBvcnQoJy4vZGV2LXJvb3QtaHR0cC1hY2Nlc3MtZmFsbGJhY2stYm91bmRhcnknKVxuICAgICAgY29udGVudCA9IChcbiAgICAgICAgPERldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeT5cbiAgICAgICAgICB7Y29udGVudH1cbiAgICAgICAgPC9EZXZSb290SFRUUEFjY2Vzc0ZhbGxiYWNrQm91bmRhcnk+XG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IEhvdFJlbG9hZGVyOiB0eXBlb2YgaW1wb3J0KCcuLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJykuZGVmYXVsdCA9XG4gICAgICAoXG4gICAgICAgIHJlcXVpcmUoJy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9kZXYvaG90LXJlbG9hZGVyL2FwcC9ob3QtcmVsb2FkZXItYXBwJylcbiAgICAgICkuZGVmYXVsdFxuXG4gICAgY29udGVudCA9IChcbiAgICAgIDxIb3RSZWxvYWRlciBhc3NldFByZWZpeD17YXNzZXRQcmVmaXh9IGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvcn0+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9Ib3RSZWxvYWRlcj5cbiAgICApXG4gIH0gZWxzZSB7XG4gICAgY29udGVudCA9IChcbiAgICAgIDxSb290RXJyb3JCb3VuZGFyeVxuICAgICAgICBlcnJvckNvbXBvbmVudD17Z2xvYmFsRXJyb3JbMF19XG4gICAgICAgIGVycm9yU3R5bGVzPXtnbG9iYWxFcnJvclsxXX1cbiAgICAgID5cbiAgICAgICAge2NvbnRlbnR9XG4gICAgICA8L1Jvb3RFcnJvckJvdW5kYXJ5PlxuICAgIClcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIaXN0b3J5VXBkYXRlciBhcHBSb3V0ZXJTdGF0ZT17c3RhdGV9IC8+XG4gICAgICA8UnVudGltZVN0eWxlcyAvPlxuICAgICAgPFBhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtwYXRoUGFyYW1zfT5cbiAgICAgICAgPFBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cGF0aG5hbWV9PlxuICAgICAgICAgIDxTZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtzZWFyY2hQYXJhbXN9PlxuICAgICAgICAgICAgPEdsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgICAgICAgdmFsdWU9e2dsb2JhbExheW91dFJvdXRlckNvbnRleHR9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHsvKiBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyBjb250ZXh0LiB1c2VSb3V0ZXJcbiAgICAgICAgICAgICAgICAgIHNob3VsZCBpbXBvcnQgZnJvbSBhcHAtcm91dGVyLWluc3RhbmNlIGluc3RlYWQuIEl0J3Mgb25seVxuICAgICAgICAgICAgICAgICAgbmVjZXNzYXJ5IGJlY2F1c2UgdXNlUm91dGVyIGlzIHNoYXJlZCBiZXR3ZWVuIFBhZ2VzIGFuZFxuICAgICAgICAgICAgICAgICAgQXBwIFJvdXRlci4gV2Ugc2hvdWxkIGZvcmsgdGhhdCBtb2R1bGUsIHRoZW4gcmVtb3ZlIHRoaXNcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQgcHJvdmlkZXIuICovfVxuICAgICAgICAgICAgICA8QXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17cHVibGljQXBwUm91dGVySW5zdGFuY2V9PlxuICAgICAgICAgICAgICAgIDxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtsYXlvdXRSb3V0ZXJDb250ZXh0fT5cbiAgICAgICAgICAgICAgICAgIHtjb250ZW50fVxuICAgICAgICAgICAgICAgIDwvTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgPC9BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgPC9HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9QYXRobmFtZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L1BhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvPlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcFJvdXRlcih7XG4gIGFjdGlvblF1ZXVlLFxuICBnbG9iYWxFcnJvclN0YXRlLFxuICBhc3NldFByZWZpeCxcbn06IHtcbiAgYWN0aW9uUXVldWU6IEFwcFJvdXRlckFjdGlvblF1ZXVlXG4gIGdsb2JhbEVycm9yU3RhdGU6IEdsb2JhbEVycm9yU3RhdGVcbiAgYXNzZXRQcmVmaXg6IHN0cmluZ1xufSkge1xuICB1c2VOYXZGYWlsdXJlSGFuZGxlcigpXG5cbiAgY29uc3Qgcm91dGVyID0gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGFjdGlvblF1ZXVlPXthY3Rpb25RdWV1ZX1cbiAgICAgIGFzc2V0UHJlZml4PXthc3NldFByZWZpeH1cbiAgICAgIGdsb2JhbEVycm9yPXtnbG9iYWxFcnJvclN0YXRlfVxuICAgIC8+XG4gIClcblxuICAvLyBBdCB0aGUgdmVyeSB0b3AgbGV2ZWwsIHVzZSB0aGUgZGVmYXVsdCBHbG9iYWxFcnJvciBjb21wb25lbnQgYXMgdGhlIGZpbmFsIGZhbGxiYWNrLlxuICAvLyBXaGVuIHRoZSBhcHAgcm91dGVyIGl0c2VsZiBmYWlscywgd2hpY2ggbWVhbnMgdGhlIGZyYW1ld29yayBpdHNlbGYgZmFpbHMsIHdlIHNob3cgdGhlIGRlZmF1bHQgZXJyb3IuXG4gIHJldHVybiAoXG4gICAgPFJvb3RFcnJvckJvdW5kYXJ5IGVycm9yQ29tcG9uZW50PXtEZWZhdWx0R2xvYmFsRXJyb3J9PlxuICAgICAge3JvdXRlcn1cbiAgICA8L1Jvb3RFcnJvckJvdW5kYXJ5PlxuICApXG59XG5cbmNvbnN0IHJ1bnRpbWVTdHlsZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxubGV0IHJ1bnRpbWVTdHlsZUNoYW5nZWQgPSBuZXcgU2V0PCgpID0+IHZvaWQ+KClcblxuZ2xvYmFsVGhpcy5fTl9FX1NUWUxFX0xPQUQgPSBmdW5jdGlvbiAoaHJlZjogc3RyaW5nKSB7XG4gIGxldCBsZW4gPSBydW50aW1lU3R5bGVzLnNpemVcbiAgcnVudGltZVN0eWxlcy5hZGQoaHJlZilcbiAgaWYgKHJ1bnRpbWVTdHlsZXMuc2l6ZSAhPT0gbGVuKSB7XG4gICAgcnVudGltZVN0eWxlQ2hhbmdlZC5mb3JFYWNoKChjYikgPT4gY2IoKSlcbiAgfVxuICAvLyBUT0RPIGZpZ3VyZSBvdXQgaG93IHRvIGdldCBhIHByb21pc2UgaGVyZVxuICAvLyBCdXQgbWF5YmUgaXQncyBub3QgbmVjZXNzYXJ5IGFzIHJlYWN0IHdvdWxkIGJsb2NrIHJlbmRlcmluZyB1bnRpbCBpdCdzIGxvYWRlZFxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbn1cblxuZnVuY3Rpb24gUnVudGltZVN0eWxlcygpIHtcbiAgY29uc3QgWywgZm9yY2VVcGRhdGVdID0gUmVhY3QudXNlU3RhdGUoMClcbiAgY29uc3QgcmVuZGVyZWRTdHlsZXNTaXplID0gcnVudGltZVN0eWxlcy5zaXplXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2hhbmdlZCA9ICgpID0+IGZvcmNlVXBkYXRlKChjKSA9PiBjICsgMSlcbiAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmFkZChjaGFuZ2VkKVxuICAgIGlmIChyZW5kZXJlZFN0eWxlc1NpemUgIT09IHJ1bnRpbWVTdHlsZXMuc2l6ZSkge1xuICAgICAgY2hhbmdlZCgpXG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBydW50aW1lU3R5bGVDaGFuZ2VkLmRlbGV0ZShjaGFuZ2VkKVxuICAgIH1cbiAgfSwgW3JlbmRlcmVkU3R5bGVzU2l6ZSwgZm9yY2VVcGRhdGVdKVxuXG4gIGNvbnN0IGRwbElkID0gcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEXG4gICAgPyBgP2RwbD0ke3Byb2Nlc3MuZW52Lk5FWFRfREVQTE9ZTUVOVF9JRH1gXG4gICAgOiAnJ1xuICByZXR1cm4gWy4uLnJ1bnRpbWVTdHlsZXNdLm1hcCgoaHJlZiwgaSkgPT4gKFxuICAgIDxsaW5rXG4gICAgICBrZXk9e2l9XG4gICAgICByZWw9XCJzdHlsZXNoZWV0XCJcbiAgICAgIGhyZWY9e2Ake2hyZWZ9JHtkcGxJZH1gfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcHJlY2VkZW5jZT1cIm5leHRcIlxuICAgICAgLy8gVE9ETyBmaWd1cmUgb3V0IGNyb3NzT3JpZ2luIGFuZCBub25jZVxuICAgICAgLy8gY3Jvc3NPcmlnaW49e1RPRE99XG4gICAgICAvLyBub25jZT17VE9ET31cbiAgICAvPlxuICApKVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZUVtcHR5Q2FjaGVOb2RlIiwiY3JlYXRlUHJlZmV0Y2hVUkwiLCJBcHBSb3V0ZXIiLCJpc0V4dGVybmFsVVJMIiwiZ2xvYmFsTXV0YWJsZSIsInVybCIsIm9yaWdpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiVVJMIiwiYWRkQmFzZVBhdGgiLCJfIiwiRXJyb3IiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJIaXN0b3J5VXBkYXRlciIsImFwcFJvdXRlclN0YXRlIiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwiX19ORVhUX0FQUF9OQVZfRkFJTF9IQU5ETElORyIsIm5leHQiLCJfX3BlbmRpbmdVcmwiLCJ1bmRlZmluZWQiLCJ0cmVlIiwicHVzaFJlZiIsImNhbm9uaWNhbFVybCIsImhpc3RvcnlTdGF0ZSIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiaGlzdG9yeSIsInN0YXRlIiwiX19OQSIsIl9fUFJJVkFURV9ORVhUSlNfSU5URVJOQUxTX1RSRUUiLCJwZW5kaW5nUHVzaCIsImNyZWF0ZUhyZWZGcm9tVXJsIiwicHVzaFN0YXRlIiwicmVwbGFjZVN0YXRlIiwidXNlRWZmZWN0IiwiX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFIiwicGluZ1Zpc2libGVMaW5rcyIsIm5leHRVcmwiLCJsYXp5RGF0YSIsInJzYyIsInByZWZldGNoUnNjIiwiaGVhZCIsInByZWZldGNoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiTWFwIiwibG9hZGluZyIsIm5hdmlnYXRlZEF0IiwiY29weU5leHRKc0ludGVybmFsSGlzdG9yeVN0YXRlIiwiZGF0YSIsImN1cnJlbnRTdGF0ZSIsIkhlYWQiLCJoZWFkQ2FjaGVOb2RlIiwicmVzb2x2ZWRQcmVmZXRjaFJzYyIsInVzZURlZmVycmVkVmFsdWUiLCJSb3V0ZXIiLCJhY3Rpb25RdWV1ZSIsImFzc2V0UHJlZml4IiwiZ2xvYmFsRXJyb3IiLCJ1c2VBY3Rpb25RdWV1ZSIsInNlYXJjaFBhcmFtcyIsInBhdGhuYW1lIiwidXNlTWVtbyIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJjYWNoZSIsInByZWZldGNoQ2FjaGUiLCJuZCIsInJvdXRlciIsInB1YmxpY0FwcFJvdXRlckluc3RhbmNlIiwiaGFuZGxlUGFnZVNob3ciLCJldmVudCIsInBlcnNpc3RlZCIsInBlbmRpbmdNcGFQYXRoIiwiZGlzcGF0Y2hBcHBSb3V0ZXJBY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX1JFU1RPUkUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVVuaGFuZGxlZFJlZGlyZWN0IiwiZXJyb3IiLCJyZWFzb24iLCJpc1JlZGlyZWN0RXJyb3IiLCJwcmV2ZW50RGVmYXVsdCIsImdldFVSTEZyb21SZWRpcmVjdEVycm9yIiwicmVkaXJlY3RUeXBlIiwiZ2V0UmVkaXJlY3RUeXBlRnJvbUVycm9yIiwiUmVkaXJlY3RUeXBlIiwicHVzaCIsInJlcGxhY2UiLCJtcGFOYXZpZ2F0aW9uIiwiYXNzaWduIiwidW5yZXNvbHZlZFRoZW5hYmxlIiwib3JpZ2luYWxQdXNoU3RhdGUiLCJiaW5kIiwib3JpZ2luYWxSZXBsYWNlU3RhdGUiLCJhcHBseVVybEZyb21IaXN0b3J5UHVzaFJlcGxhY2UiLCJzdGFydFRyYW5zaXRpb24iLCJfdW51c2VkIiwiX04iLCJvblBvcFN0YXRlIiwicmVsb2FkIiwiZGlzcGF0Y2hUcmF2ZXJzZUFjdGlvbiIsImZvY3VzQW5kU2Nyb2xsUmVmIiwibWF0Y2hpbmdIZWFkIiwiZmluZEhlYWRJbkNhY2hlIiwicGF0aFBhcmFtcyIsImdldFNlbGVjdGVkUGFyYW1zIiwibGF5b3V0Um91dGVyQ29udGV4dCIsInBhcmVudFRyZWUiLCJwYXJlbnRDYWNoZU5vZGUiLCJwYXJlbnRTZWdtZW50UGF0aCIsImdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJoZWFkS2V5IiwiaGVhZEtleVdpdGhvdXRTZWFyY2hQYXJhbXMiLCJjb250ZW50IiwiUmVkaXJlY3RCb3VuZGFyeSIsIlJvb3RMYXlvdXRCb3VuZGFyeSIsIkFwcFJvdXRlckFubm91bmNlciIsIkRldlJvb3RIVFRQQWNjZXNzRmFsbGJhY2tCb3VuZGFyeSIsInJlcXVpcmUiLCJIb3RSZWxvYWRlciIsImRlZmF1bHQiLCJSb290RXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiZXJyb3JTdHlsZXMiLCJSdW50aW1lU3R5bGVzIiwiUGF0aFBhcmFtc0NvbnRleHQiLCJQcm92aWRlciIsInZhbHVlIiwiUGF0aG5hbWVDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJBcHBSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsImdsb2JhbEVycm9yU3RhdGUiLCJ1c2VOYXZGYWlsdXJlSGFuZGxlciIsIkRlZmF1bHRHbG9iYWxFcnJvciIsInJ1bnRpbWVTdHlsZXMiLCJTZXQiLCJydW50aW1lU3R5bGVDaGFuZ2VkIiwiZ2xvYmFsVGhpcyIsIl9OX0VfU1RZTEVfTE9BRCIsImxlbiIsInNpemUiLCJhZGQiLCJmb3JFYWNoIiwiY2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZvcmNlVXBkYXRlIiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInJlbmRlcmVkU3R5bGVzU2l6ZSIsImNoYW5nZWQiLCJjIiwiZGVsZXRlIiwiZHBsSWQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJtYXAiLCJpIiwibGluayIsInJlbCIsInByZWNlZGVuY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/links.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/components/links.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    IDLE_LINK_STATUS: function() {\n        return IDLE_LINK_STATUS;\n    },\n    PENDING_LINK_STATUS: function() {\n        return PENDING_LINK_STATUS;\n    },\n    mountFormInstance: function() {\n        return mountFormInstance;\n    },\n    mountLinkInstance: function() {\n        return mountLinkInstance;\n    },\n    onLinkVisibilityChanged: function() {\n        return onLinkVisibilityChanged;\n    },\n    onNavigationIntent: function() {\n        return onNavigationIntent;\n    },\n    pingVisibleLinks: function() {\n        return pingVisibleLinks;\n    },\n    setLinkForCurrentNavigation: function() {\n        return setLinkForCurrentNavigation;\n    },\n    unmountLinkForCurrentNavigation: function() {\n        return unmountLinkForCurrentNavigation;\n    },\n    unmountPrefetchableInstance: function() {\n        return unmountPrefetchableInstance;\n    }\n});\nconst _approuterinstance = __webpack_require__(/*! ./app-router-instance */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-instance.js\");\nconst _approuter = __webpack_require__(/*! ./app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _segmentcache = __webpack_require__(/*! ./segment-cache */ \"(app-pages-browser)/./node_modules/next/dist/client/components/segment-cache.js\");\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _invarianterror = __webpack_require__(/*! ../../shared/lib/invariant-error */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/invariant-error.js\");\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation = null;\nconst PENDING_LINK_STATUS = {\n    pending: true\n};\nconst IDLE_LINK_STATUS = {\n    pending: false\n};\nfunction setLinkForCurrentNavigation(link) {\n    (0, _react.startTransition)(()=>{\n        linkForMostRecentNavigation == null ? void 0 : linkForMostRecentNavigation.setOptimisticLinkStatus(IDLE_LINK_STATUS);\n        link == null ? void 0 : link.setOptimisticLinkStatus(PENDING_LINK_STATUS);\n        linkForMostRecentNavigation = link;\n    });\n}\nfunction unmountLinkForCurrentNavigation(link) {\n    if (linkForMostRecentNavigation === link) {\n        linkForMostRecentNavigation = null;\n    }\n}\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable = typeof WeakMap === 'function' ? new WeakMap() : new Map();\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible = new Set();\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer = typeof IntersectionObserver === 'function' ? new IntersectionObserver(handleIntersect, {\n    rootMargin: '200px'\n}) : null;\nfunction observeVisibility(element, instance) {\n    const existingInstance = prefetchable.get(element);\n    if (existingInstance !== undefined) {\n        // This shouldn't happen because each <Link> component should have its own\n        // anchor tag instance, but it's defensive coding to avoid a memory leak in\n        // case there's a logical error somewhere else.\n        unmountPrefetchableInstance(element);\n    }\n    // Only track prefetchable links that have a valid prefetch URL\n    prefetchable.set(element, instance);\n    if (observer !== null) {\n        observer.observe(element);\n    }\n}\nfunction coercePrefetchableUrl(href) {\n    try {\n        return (0, _approuter.createPrefetchURL)(href);\n    } catch (e) {\n        // createPrefetchURL sometimes throws an error if an invalid URL is\n        // provided, though I'm not sure if it's actually necessary.\n        // TODO: Consider removing the throw from the inner function, or change it\n        // to reportError. Or maybe the error isn't even necessary for automatic\n        // prefetches, just navigations.\n        const reportErrorFn = typeof reportError === 'function' ? reportError : console.error;\n        reportErrorFn(\"Cannot prefetch '\" + href + \"' because it cannot be converted to a URL.\");\n        return null;\n    }\n}\nfunction mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {\n    if (prefetchEnabled) {\n        const prefetchURL = coercePrefetchableUrl(href);\n        if (prefetchURL !== null) {\n            const instance = {\n                router,\n                fetchStrategy,\n                isVisible: false,\n                prefetchTask: null,\n                prefetchHref: prefetchURL.href,\n                setOptimisticLinkStatus\n            };\n            // We only observe the link's visibility if it's prefetchable. For\n            // example, this excludes links to external URLs.\n            observeVisibility(element, instance);\n            return instance;\n        }\n    }\n    // If the link is not prefetchable, we still create an instance so we can\n    // track its optimistic state (i.e. useLinkStatus).\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: null,\n        setOptimisticLinkStatus\n    };\n    return instance;\n}\nfunction mountFormInstance(element, href, router, fetchStrategy) {\n    const prefetchURL = coercePrefetchableUrl(href);\n    if (prefetchURL === null) {\n        // This href is not prefetchable, so we don't track it.\n        // TODO: We currently observe/unobserve a form every time its href changes.\n        // For Links, this isn't a big deal because the href doesn't usually change,\n        // but for forms it's extremely common. We should optimize this.\n        return;\n    }\n    const instance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus: null\n    };\n    observeVisibility(element, instance);\n}\nfunction unmountPrefetchableInstance(element) {\n    const instance = prefetchable.get(element);\n    if (instance !== undefined) {\n        prefetchable.delete(element);\n        prefetchableAndVisible.delete(instance);\n        const prefetchTask = instance.prefetchTask;\n        if (prefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(prefetchTask);\n        }\n    }\n    if (observer !== null) {\n        observer.unobserve(element);\n    }\n}\nfunction handleIntersect(entries) {\n    for (const entry of entries){\n        // Some extremely old browsers or polyfills don't reliably support\n        // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n        // really. But whatever this is fine.)\n        const isVisible = entry.intersectionRatio > 0;\n        onLinkVisibilityChanged(entry.target, isVisible);\n    }\n}\nfunction onLinkVisibilityChanged(element, isVisible) {\n    if (true) {\n        // Prefetching on viewport is disabled in development for performance\n        // reasons, because it requires compiling the target page.\n        // TODO: Investigate re-enabling this.\n        return;\n    }\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    instance.isVisible = isVisible;\n    if (isVisible) {\n        prefetchableAndVisible.add(instance);\n    } else {\n        prefetchableAndVisible.delete(instance);\n    }\n    rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Default);\n}\nfunction onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {\n    const instance = prefetchable.get(element);\n    if (instance === undefined) {\n        return;\n    }\n    // Prefetch the link on hover/touchstart.\n    if (instance !== undefined) {\n        if (false) {}\n        rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Intent);\n    }\n}\nfunction rescheduleLinkPrefetch(instance, priority) {\n    const existingPrefetchTask = instance.prefetchTask;\n    if (!instance.isVisible) {\n        // Cancel any in-progress prefetch task. (If it already finished then this\n        // is a no-op.)\n        if (existingPrefetchTask !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);\n        }\n        // We don't need to reset the prefetchTask to null upon cancellation; an\n        // old task object can be rescheduled with reschedulePrefetchTask. This is a\n        // micro-optimization but also makes the code simpler (don't need to\n        // worry about whether an old task object is stale).\n        return;\n    }\n    if (true) {\n        // The old prefetch implementation does not have different priority levels.\n        // Just schedule a new prefetch task.\n        prefetchWithOldCacheImplementation(instance);\n        return;\n    }\n    const appRouterState = (0, _approuterinstance.getCurrentAppRouterState)();\n    if (appRouterState !== null) {\n        const treeAtTimeOfPrefetch = appRouterState.tree;\n        if (existingPrefetchTask === null) {\n            // Initiate a prefetch task.\n            const nextUrl = appRouterState.nextUrl;\n            const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n            instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, treeAtTimeOfPrefetch, instance.fetchStrategy, priority, null);\n        } else {\n            // We already have an old task object that we can reschedule. This is\n            // effectively the same as canceling the old task and creating a new one.\n            (0, _segmentcache.reschedulePrefetchTask)(existingPrefetchTask, treeAtTimeOfPrefetch, instance.fetchStrategy, priority);\n        }\n    }\n}\nfunction pingVisibleLinks(nextUrl, tree) {\n    // For each currently visible link, cancel the existing prefetch task (if it\n    // exists) and schedule a new one. This is effectively the same as if all the\n    // visible links left and then re-entered the viewport.\n    //\n    // This is called when the Next-Url or the base tree changes, since those\n    // may affect the result of a prefetch task. It's also called after a\n    // cache invalidation.\n    for (const instance of prefetchableAndVisible){\n        const task = instance.prefetchTask;\n        if (task !== null && !(0, _segmentcache.isPrefetchTaskDirty)(task, nextUrl, tree)) {\n            continue;\n        }\n        // Something changed. Cancel the existing prefetch task and schedule a\n        // new one.\n        if (task !== null) {\n            (0, _segmentcache.cancelPrefetchTask)(task);\n        }\n        const cacheKey = (0, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);\n        instance.prefetchTask = (0, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _segmentcache.PrefetchPriority.Default, null);\n    }\n}\nfunction prefetchWithOldCacheImplementation(instance) {\n    // This is the path used when the Segment Cache is not enabled.\n    if (false) {}\n    const doPrefetch = async ()=>{\n        // note that `appRouter.prefetch()` is currently sync,\n        // so we have to wrap this call in an async function to be able to catch() errors below.\n        let prefetchKind;\n        switch(instance.fetchStrategy){\n            case _segmentcache.FetchStrategy.PPR:\n                {\n                    prefetchKind = _routerreducertypes.PrefetchKind.AUTO;\n                    break;\n                }\n            case _segmentcache.FetchStrategy.Full:\n                {\n                    prefetchKind = _routerreducertypes.PrefetchKind.FULL;\n                    break;\n                }\n            case _segmentcache.FetchStrategy.PPRRuntime:\n                {\n                    // We can only get here if Client Segment Cache is off, and in that case\n                    // it shouldn't be possible for a link to request a runtime prefetch.\n                    throw Object.defineProperty(new _invarianterror.InvariantError('FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'), \"__NEXT_ERROR_CODE\", {\n                        value: \"E772\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            default:\n                {\n                    instance.fetchStrategy;\n                    // Unreachable, but otherwise typescript will consider the variable unassigned\n                    prefetchKind = undefined;\n                }\n        }\n        return instance.router.prefetch(instance.prefetchHref, {\n            kind: prefetchKind\n        });\n    };\n    // Prefetch the page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=links.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGlua3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBb0VhQSxnQkFBZ0I7ZUFBaEJBOztJQUhBQyxtQkFBbUI7ZUFBbkJBOztJQW9IR0MsaUJBQWlCO2VBQWpCQTs7SUF0Q0FDLGlCQUFpQjtlQUFqQkE7O0lBd0ZBQyx1QkFBdUI7ZUFBdkJBOztJQXNCQUMsa0JBQWtCO2VBQWxCQTs7SUEwRUFDLGdCQUFnQjtlQUFoQkE7O0lBN1BBQywyQkFBMkI7ZUFBM0JBOztJQVNBQywrQkFBK0I7ZUFBL0JBOztJQTJIQUMsMkJBQTJCO2VBQTNCQTs7OytDQTVNeUI7dUNBQ1A7MENBSzNCO21DQVN5QjtnREFDSDs0Q0FDRTtBQXlDL0IseUVBQXlFO0FBQ3pFLDREQUE0RDtBQUM1RCxJQUFJQyw4QkFBbUQ7QUFHaEQsTUFBTVQsc0JBQXNCO0lBQUVVLFNBQVM7QUFBSztBQUc1QyxNQUFNWCxtQkFBbUI7SUFBRVcsU0FBUztBQUFNO0FBTTFDLFNBQVNKLDRCQUE0QkssSUFBeUI7SUFDbkVDLENBQUFBLEdBQUFBLE9BQUFBLGVBQUFBLEVBQWdCO1FBQ2RILCtCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSw0QkFBNkJJLHVCQUF1QixDQUFDZDtRQUNyRFksUUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsS0FBTUUsdUJBQXVCLENBQUNiO1FBQzlCUyw4QkFBOEJFO0lBQ2hDO0FBQ0Y7QUFHTyxTQUFTSixnQ0FBZ0NJLElBQWtCO0lBQ2hFLElBQUlGLGdDQUFnQ0UsTUFBTTtRQUN4Q0YsOEJBQThCO0lBQ2hDO0FBQ0Y7QUFFQSwyRUFBMkU7QUFDM0UsbUVBQW1FO0FBQ25FLE1BQU1LLGVBR0osT0FBT0MsWUFBWSxhQUFhLElBQUlBLFlBQVksSUFBSUM7QUFFdEQsNkVBQTZFO0FBQzdFLDRFQUE0RTtBQUM1RSwwRUFBMEU7QUFDMUUsaUJBQWlCO0FBQ2pCLE1BQU1DLHlC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LElBdkJJLElBdUJvQixFQUFtQjtZQUN6QyxxQ0FBcUM7WUFDckMsTUFBTUE7UUFDUjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNtaW5pL0RvY3VtZW50cy9Qcm9qZWN0cy9zcmMvY2xpZW50L2NvbXBvbmVudHMvbGlua3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBGbGlnaHRSb3V0ZXJTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBBcHBSb3V0ZXJJbnN0YW5jZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgZ2V0Q3VycmVudEFwcFJvdXRlclN0YXRlIH0gZnJvbSAnLi9hcHAtcm91dGVyLWluc3RhbmNlJ1xuaW1wb3J0IHsgY3JlYXRlUHJlZmV0Y2hVUkwgfSBmcm9tICcuL2FwcC1yb3V0ZXInXG5pbXBvcnQge1xuICBGZXRjaFN0cmF0ZWd5LFxuICBpc1ByZWZldGNoVGFza0RpcnR5LFxuICB0eXBlIFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3ksXG59IGZyb20gJy4vc2VnbWVudC1jYWNoZSdcbmltcG9ydCB7IGNyZWF0ZUNhY2hlS2V5IH0gZnJvbSAnLi9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHtcbiAgdHlwZSBQcmVmZXRjaFRhc2ssXG4gIFByZWZldGNoUHJpb3JpdHksXG4gIHNjaGVkdWxlUHJlZmV0Y2hUYXNrIGFzIHNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayxcbiAgY2FuY2VsUHJlZmV0Y2hUYXNrLFxuICByZXNjaGVkdWxlUHJlZmV0Y2hUYXNrLFxufSBmcm9tICcuL3NlZ21lbnQtY2FjaGUnXG5pbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFByZWZldGNoS2luZCB9IGZyb20gJy4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBJbnZhcmlhbnRFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvaW52YXJpYW50LWVycm9yJ1xuXG50eXBlIExpbmtFbGVtZW50ID0gSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudFxuXG50eXBlIEVsZW1lbnQgPSBMaW5rRWxlbWVudCB8IEhUTUxGb3JtRWxlbWVudFxuXG4vLyBQcm9wZXJ0aWVzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIExpbmsgYW5kIEZvcm0gaW5zdGFuY2VzLiBXZSB1c2UgdGhlIHNhbWVcbi8vIHNoYXBlIGZvciBib3RoIHRvIHByZXZlbnQgYSBwb2x5bW9ycGhpYyBkZS1vcHQgaW4gdGhlIFZNLlxudHlwZSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgPSB7XG4gIHJvdXRlcjogQXBwUm91dGVySW5zdGFuY2VcbiAgZmV0Y2hTdHJhdGVneTogUHJlZmV0Y2hUYXNrRmV0Y2hTdHJhdGVneVxuXG4gIGlzVmlzaWJsZTogYm9vbGVhblxuXG4gIC8vIFRoZSBtb3N0IHJlY2VudGx5IGluaXRpYXRlZCBwcmVmZXRjaCB0YXNrLiBJdCBtYXkgb3IgbWF5IG5vdCBoYXZlXG4gIC8vIGFscmVhZHkgY29tcGxldGVkLiBUaGUgc2FtZSBwcmVmZXRjaCB0YXNrIG9iamVjdCBjYW4gYmUgcmV1c2VkIGFjcm9zc1xuICAvLyBtdWx0aXBsZSBwcmVmZXRjaGVzIG9mIHRoZSBzYW1lIGxpbmsuXG4gIHByZWZldGNoVGFzazogUHJlZmV0Y2hUYXNrIHwgbnVsbFxufVxuXG5leHBvcnQgdHlwZSBGb3JtSW5zdGFuY2UgPSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgJiB7XG4gIHByZWZldGNoSHJlZjogc3RyaW5nXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiBudWxsXG59XG5cbnR5cGUgUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlID0gTGlua09yRm9ybUluc3RhbmNlU2hhcmVkICYge1xuICBwcmVmZXRjaEhyZWY6IHN0cmluZ1xuICBzZXRPcHRpbWlzdGljTGlua1N0YXR1czogKHN0YXR1czogeyBwZW5kaW5nOiBib29sZWFuIH0pID0+IHZvaWRcbn1cblxudHlwZSBOb25QcmVmZXRjaGFibGVMaW5rSW5zdGFuY2UgPSBMaW5rT3JGb3JtSW5zdGFuY2VTaGFyZWQgJiB7XG4gIHByZWZldGNoSHJlZjogbnVsbFxuICBzZXRPcHRpbWlzdGljTGlua1N0YXR1czogKHN0YXR1czogeyBwZW5kaW5nOiBib29sZWFuIH0pID0+IHZvaWRcbn1cblxudHlwZSBQcmVmZXRjaGFibGVJbnN0YW5jZSA9IFByZWZldGNoYWJsZUxpbmtJbnN0YW5jZSB8IEZvcm1JbnN0YW5jZVxuXG5leHBvcnQgdHlwZSBMaW5rSW5zdGFuY2UgPVxuICB8IFByZWZldGNoYWJsZUxpbmtJbnN0YW5jZVxuICB8IE5vblByZWZldGNoYWJsZUxpbmtJbnN0YW5jZVxuXG4vLyBUcmFja3MgdGhlIG1vc3QgcmVjZW50bHkgbmF2aWdhdGVkIGxpbmsgaW5zdGFuY2UuIFdoZW4gbnVsbCwgaW5kaWNhdGVzXG4vLyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBub3QgaW5pdGlhdGVkIGJ5IGEgbGluayBjbGljay5cbmxldCBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb246IExpbmtJbnN0YW5jZSB8IG51bGwgPSBudWxsXG5cbi8vIFN0YXR1cyBvYmplY3QgaW5kaWNhdGluZyBsaW5rIGlzIHBlbmRpbmdcbmV4cG9ydCBjb25zdCBQRU5ESU5HX0xJTktfU1RBVFVTID0geyBwZW5kaW5nOiB0cnVlIH1cblxuLy8gU3RhdHVzIG9iamVjdCBpbmRpY2F0aW5nIGxpbmsgaXMgaWRsZVxuZXhwb3J0IGNvbnN0IElETEVfTElOS19TVEFUVVMgPSB7IHBlbmRpbmc6IGZhbHNlIH1cblxuLy8gVXBkYXRlcyB0aGUgbG9hZGluZyBzdGF0ZSB3aGVuIG5hdmlnYXRpbmcgYmV0d2VlbiBsaW5rc1xuLy8gLSBSZXNldHMgdGhlIHByZXZpb3VzIGxpbmsncyBsb2FkaW5nIHN0YXRlXG4vLyAtIFNldHMgdGhlIG5ldyBsaW5rJ3MgbG9hZGluZyBzdGF0ZVxuLy8gLSBVcGRhdGVzIHRyYWNraW5nIG9mIGN1cnJlbnQgbmF2aWdhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHNldExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbihsaW5rOiBMaW5rSW5zdGFuY2UgfCBudWxsKSB7XG4gIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgbGlua0Zvck1vc3RSZWNlbnROYXZpZ2F0aW9uPy5zZXRPcHRpbWlzdGljTGlua1N0YXR1cyhJRExFX0xJTktfU1RBVFVTKVxuICAgIGxpbms/LnNldE9wdGltaXN0aWNMaW5rU3RhdHVzKFBFTkRJTkdfTElOS19TVEFUVVMpXG4gICAgbGlua0Zvck1vc3RSZWNlbnROYXZpZ2F0aW9uID0gbGlua1xuICB9KVxufVxuXG4vLyBVbm1vdW50cyB0aGUgY3VycmVudCBsaW5rIGluc3RhbmNlIGZyb20gbmF2aWdhdGlvbiB0cmFja2luZ1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnRMaW5rRm9yQ3VycmVudE5hdmlnYXRpb24obGluazogTGlua0luc3RhbmNlKSB7XG4gIGlmIChsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24gPT09IGxpbmspIHtcbiAgICBsaW5rRm9yTW9zdFJlY2VudE5hdmlnYXRpb24gPSBudWxsXG4gIH1cbn1cblxuLy8gVXNlIGEgV2Vha01hcCB0byBhc3NvY2lhdGUgYSBMaW5rIGluc3RhbmNlIHdpdGggaXRzIERPTSBlbGVtZW50LiBUaGlzIGlzXG4vLyB1c2VkIGJ5IHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciB0byB0cmFjayB0aGUgbGluaydzIHZpc2liaWxpdHkuXG5jb25zdCBwcmVmZXRjaGFibGU6XG4gIHwgV2Vha01hcDxFbGVtZW50LCBQcmVmZXRjaGFibGVJbnN0YW5jZT5cbiAgfCBNYXA8RWxlbWVudCwgUHJlZmV0Y2hhYmxlSW5zdGFuY2U+ID1cbiAgdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcCgpXG5cbi8vIEEgU2V0IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBsaW5rcy4gV2UgcmUtcHJlZmV0Y2ggdmlzaWJsZSBsaW5rcyBhZnRlciBhXG4vLyBjYWNoZSBpbnZhbGlkYXRpb24sIG9yIHdoZW4gdGhlIGN1cnJlbnQgVVJMIGNoYW5nZXMuIEl0J3MgYSBzZXBhcmF0ZSBkYXRhXG4vLyBzdHJ1Y3R1cmUgZnJvbSB0aGUgV2Vha01hcCBhYm92ZSBiZWNhdXNlIG9ubHkgdGhlIHZpc2libGUgbGlua3MgbmVlZCB0b1xuLy8gYmUgZW51bWVyYXRlZC5cbmNvbnN0IHByZWZldGNoYWJsZUFuZFZpc2libGU6IFNldDxQcmVmZXRjaGFibGVJbnN0YW5jZT4gPSBuZXcgU2V0KClcblxuLy8gQSBzaW5nbGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaW5zdGFuY2Ugc2hhcmVkIGJ5IGFsbCA8TGluaz4gY29tcG9uZW50cy5cbmNvbnN0IG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlciB8IG51bGwgPVxuICB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09ICdmdW5jdGlvbidcbiAgICA/IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVJbnRlcnNlY3QsIHtcbiAgICAgICAgcm9vdE1hcmdpbjogJzIwMHB4JyxcbiAgICAgIH0pXG4gICAgOiBudWxsXG5cbmZ1bmN0aW9uIG9ic2VydmVWaXNpYmlsaXR5KGVsZW1lbnQ6IEVsZW1lbnQsIGluc3RhbmNlOiBQcmVmZXRjaGFibGVJbnN0YW5jZSkge1xuICBjb25zdCBleGlzdGluZ0luc3RhbmNlID0gcHJlZmV0Y2hhYmxlLmdldChlbGVtZW50KVxuICBpZiAoZXhpc3RpbmdJbnN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgZWFjaCA8TGluaz4gY29tcG9uZW50IHNob3VsZCBoYXZlIGl0cyBvd25cbiAgICAvLyBhbmNob3IgdGFnIGluc3RhbmNlLCBidXQgaXQncyBkZWZlbnNpdmUgY29kaW5nIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW5cbiAgICAvLyBjYXNlIHRoZXJlJ3MgYSBsb2dpY2FsIGVycm9yIHNvbWV3aGVyZSBlbHNlLlxuICAgIHVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZShlbGVtZW50KVxuICB9XG4gIC8vIE9ubHkgdHJhY2sgcHJlZmV0Y2hhYmxlIGxpbmtzIHRoYXQgaGF2ZSBhIHZhbGlkIHByZWZldGNoIFVSTFxuICBwcmVmZXRjaGFibGUuc2V0KGVsZW1lbnQsIGluc3RhbmNlKVxuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlUHJlZmV0Y2hhYmxlVXJsKGhyZWY6IHN0cmluZyk6IFVSTCB8IG51bGwge1xuICB0cnkge1xuICAgIHJldHVybiBjcmVhdGVQcmVmZXRjaFVSTChocmVmKVxuICB9IGNhdGNoIHtcbiAgICAvLyBjcmVhdGVQcmVmZXRjaFVSTCBzb21ldGltZXMgdGhyb3dzIGFuIGVycm9yIGlmIGFuIGludmFsaWQgVVJMIGlzXG4gICAgLy8gcHJvdmlkZWQsIHRob3VnaCBJJ20gbm90IHN1cmUgaWYgaXQncyBhY3R1YWxseSBuZWNlc3NhcnkuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHRocm93IGZyb20gdGhlIGlubmVyIGZ1bmN0aW9uLCBvciBjaGFuZ2UgaXRcbiAgICAvLyB0byByZXBvcnRFcnJvci4gT3IgbWF5YmUgdGhlIGVycm9yIGlzbid0IGV2ZW4gbmVjZXNzYXJ5IGZvciBhdXRvbWF0aWNcbiAgICAvLyBwcmVmZXRjaGVzLCBqdXN0IG5hdmlnYXRpb25zLlxuICAgIGNvbnN0IHJlcG9ydEVycm9yRm4gPVxuICAgICAgdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID8gcmVwb3J0RXJyb3IgOiBjb25zb2xlLmVycm9yXG4gICAgcmVwb3J0RXJyb3JGbihcbiAgICAgIGBDYW5ub3QgcHJlZmV0Y2ggJyR7aHJlZn0nIGJlY2F1c2UgaXQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIFVSTC5gXG4gICAgKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdW50TGlua0luc3RhbmNlKFxuICBlbGVtZW50OiBMaW5rRWxlbWVudCxcbiAgaHJlZjogc3RyaW5nLFxuICByb3V0ZXI6IEFwcFJvdXRlckluc3RhbmNlLFxuICBmZXRjaFN0cmF0ZWd5OiBQcmVmZXRjaFRhc2tGZXRjaFN0cmF0ZWd5LFxuICBwcmVmZXRjaEVuYWJsZWQ6IGJvb2xlYW4sXG4gIHNldE9wdGltaXN0aWNMaW5rU3RhdHVzOiAoc3RhdHVzOiB7IHBlbmRpbmc6IGJvb2xlYW4gfSkgPT4gdm9pZFxuKTogTGlua0luc3RhbmNlIHtcbiAgaWYgKHByZWZldGNoRW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZldGNoVVJMID0gY29lcmNlUHJlZmV0Y2hhYmxlVXJsKGhyZWYpXG4gICAgaWYgKHByZWZldGNoVVJMICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZTogUHJlZmV0Y2hhYmxlTGlua0luc3RhbmNlID0ge1xuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGZldGNoU3RyYXRlZ3ksXG4gICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgIHByZWZldGNoVGFzazogbnVsbCxcbiAgICAgICAgcHJlZmV0Y2hIcmVmOiBwcmVmZXRjaFVSTC5ocmVmLFxuICAgICAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1cyxcbiAgICAgIH1cbiAgICAgIC8vIFdlIG9ubHkgb2JzZXJ2ZSB0aGUgbGluaydzIHZpc2liaWxpdHkgaWYgaXQncyBwcmVmZXRjaGFibGUuIEZvclxuICAgICAgLy8gZXhhbXBsZSwgdGhpcyBleGNsdWRlcyBsaW5rcyB0byBleHRlcm5hbCBVUkxzLlxuICAgICAgb2JzZXJ2ZVZpc2liaWxpdHkoZWxlbWVudCwgaW5zdGFuY2UpXG4gICAgICByZXR1cm4gaW5zdGFuY2VcbiAgICB9XG4gIH1cbiAgLy8gSWYgdGhlIGxpbmsgaXMgbm90IHByZWZldGNoYWJsZSwgd2Ugc3RpbGwgY3JlYXRlIGFuIGluc3RhbmNlIHNvIHdlIGNhblxuICAvLyB0cmFjayBpdHMgb3B0aW1pc3RpYyBzdGF0ZSAoaS5lLiB1c2VMaW5rU3RhdHVzKS5cbiAgY29uc3QgaW5zdGFuY2U6IE5vblByZWZldGNoYWJsZUxpbmtJbnN0YW5jZSA9IHtcbiAgICByb3V0ZXIsXG4gICAgZmV0Y2hTdHJhdGVneSxcbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIHByZWZldGNoVGFzazogbnVsbCxcbiAgICBwcmVmZXRjaEhyZWY6IG51bGwsXG4gICAgc2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMsXG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3VudEZvcm1JbnN0YW5jZShcbiAgZWxlbWVudDogSFRNTEZvcm1FbGVtZW50LFxuICBocmVmOiBzdHJpbmcsXG4gIHJvdXRlcjogQXBwUm91dGVySW5zdGFuY2UsXG4gIGZldGNoU3RyYXRlZ3k6IFByZWZldGNoVGFza0ZldGNoU3RyYXRlZ3lcbik6IHZvaWQge1xuICBjb25zdCBwcmVmZXRjaFVSTCA9IGNvZXJjZVByZWZldGNoYWJsZVVybChocmVmKVxuICBpZiAocHJlZmV0Y2hVUkwgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGhyZWYgaXMgbm90IHByZWZldGNoYWJsZSwgc28gd2UgZG9uJ3QgdHJhY2sgaXQuXG4gICAgLy8gVE9ETzogV2UgY3VycmVudGx5IG9ic2VydmUvdW5vYnNlcnZlIGEgZm9ybSBldmVyeSB0aW1lIGl0cyBocmVmIGNoYW5nZXMuXG4gICAgLy8gRm9yIExpbmtzLCB0aGlzIGlzbid0IGEgYmlnIGRlYWwgYmVjYXVzZSB0aGUgaHJlZiBkb2Vzbid0IHVzdWFsbHkgY2hhbmdlLFxuICAgIC8vIGJ1dCBmb3IgZm9ybXMgaXQncyBleHRyZW1lbHkgY29tbW9uLiBXZSBzaG91bGQgb3B0aW1pemUgdGhpcy5cbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBpbnN0YW5jZTogRm9ybUluc3RhbmNlID0ge1xuICAgIHJvdXRlcixcbiAgICBmZXRjaFN0cmF0ZWd5LFxuICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgcHJlZmV0Y2hUYXNrOiBudWxsLFxuICAgIHByZWZldGNoSHJlZjogcHJlZmV0Y2hVUkwuaHJlZixcbiAgICBzZXRPcHRpbWlzdGljTGlua1N0YXR1czogbnVsbCxcbiAgfVxuICBvYnNlcnZlVmlzaWJpbGl0eShlbGVtZW50LCBpbnN0YW5jZSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZShlbGVtZW50OiBFbGVtZW50KSB7XG4gIGNvbnN0IGluc3RhbmNlID0gcHJlZmV0Y2hhYmxlLmdldChlbGVtZW50KVxuICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHByZWZldGNoYWJsZS5kZWxldGUoZWxlbWVudClcbiAgICBwcmVmZXRjaGFibGVBbmRWaXNpYmxlLmRlbGV0ZShpbnN0YW5jZSlcbiAgICBjb25zdCBwcmVmZXRjaFRhc2sgPSBpbnN0YW5jZS5wcmVmZXRjaFRhc2tcbiAgICBpZiAocHJlZmV0Y2hUYXNrICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxQcmVmZXRjaFRhc2socHJlZmV0Y2hUYXNrKVxuICAgIH1cbiAgfVxuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudClcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3QoZW50cmllczogQXJyYXk8SW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeT4pIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgLy8gU29tZSBleHRyZW1lbHkgb2xkIGJyb3dzZXJzIG9yIHBvbHlmaWxscyBkb24ndCByZWxpYWJseSBzdXBwb3J0XG4gICAgLy8gaXNJbnRlcnNlY3Rpbmcgc28gd2UgY2hlY2sgaW50ZXJzZWN0aW9uUmF0aW8gaW5zdGVhZC4gKERvIHdlIGNhcmU/IE5vdFxuICAgIC8vIHJlYWxseS4gQnV0IHdoYXRldmVyIHRoaXMgaXMgZmluZS4pXG4gICAgY29uc3QgaXNWaXNpYmxlID0gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPiAwXG4gICAgb25MaW5rVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkudGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50LCBpc1Zpc2libGUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTGlua1Zpc2liaWxpdHlDaGFuZ2VkKGVsZW1lbnQ6IEVsZW1lbnQsIGlzVmlzaWJsZTogYm9vbGVhbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFByZWZldGNoaW5nIG9uIHZpZXdwb3J0IGlzIGRpc2FibGVkIGluIGRldmVsb3BtZW50IGZvciBwZXJmb3JtYW5jZVxuICAgIC8vIHJlYXNvbnMsIGJlY2F1c2UgaXQgcmVxdWlyZXMgY29tcGlsaW5nIHRoZSB0YXJnZXQgcGFnZS5cbiAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSByZS1lbmFibGluZyB0aGlzLlxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgaW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpbnN0YW5jZS5pc1Zpc2libGUgPSBpc1Zpc2libGVcbiAgaWYgKGlzVmlzaWJsZSkge1xuICAgIHByZWZldGNoYWJsZUFuZFZpc2libGUuYWRkKGluc3RhbmNlKVxuICB9IGVsc2Uge1xuICAgIHByZWZldGNoYWJsZUFuZFZpc2libGUuZGVsZXRlKGluc3RhbmNlKVxuICB9XG4gIHJlc2NoZWR1bGVMaW5rUHJlZmV0Y2goaW5zdGFuY2UsIFByZWZldGNoUHJpb3JpdHkuRGVmYXVsdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uTmF2aWdhdGlvbkludGVudChcbiAgZWxlbWVudDogSFRNTEFuY2hvckVsZW1lbnQgfCBTVkdBRWxlbWVudCxcbiAgdW5zdGFibGVfdXBncmFkZVRvRHluYW1pY1ByZWZldGNoOiBib29sZWFuXG4pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBwcmVmZXRjaGFibGUuZ2V0KGVsZW1lbnQpXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gUHJlZmV0Y2ggdGhlIGxpbmsgb24gaG92ZXIvdG91Y2hzdGFydC5cbiAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfRFlOQU1JQ19PTl9IT1ZFUiAmJlxuICAgICAgdW5zdGFibGVfdXBncmFkZVRvRHluYW1pY1ByZWZldGNoXG4gICAgKSB7XG4gICAgICAvLyBTd2l0Y2ggdG8gYSBmdWxsIHByZWZldGNoXG4gICAgICBpbnN0YW5jZS5mZXRjaFN0cmF0ZWd5ID0gRmV0Y2hTdHJhdGVneS5GdWxsXG4gICAgfVxuICAgIHJlc2NoZWR1bGVMaW5rUHJlZmV0Y2goaW5zdGFuY2UsIFByZWZldGNoUHJpb3JpdHkuSW50ZW50KVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2NoZWR1bGVMaW5rUHJlZmV0Y2goXG4gIGluc3RhbmNlOiBQcmVmZXRjaGFibGVJbnN0YW5jZSxcbiAgcHJpb3JpdHk6IFByZWZldGNoUHJpb3JpdHkuRGVmYXVsdCB8IFByZWZldGNoUHJpb3JpdHkuSW50ZW50XG4pIHtcbiAgY29uc3QgZXhpc3RpbmdQcmVmZXRjaFRhc2sgPSBpbnN0YW5jZS5wcmVmZXRjaFRhc2tcblxuICBpZiAoIWluc3RhbmNlLmlzVmlzaWJsZSkge1xuICAgIC8vIENhbmNlbCBhbnkgaW4tcHJvZ3Jlc3MgcHJlZmV0Y2ggdGFzay4gKElmIGl0IGFscmVhZHkgZmluaXNoZWQgdGhlbiB0aGlzXG4gICAgLy8gaXMgYSBuby1vcC4pXG4gICAgaWYgKGV4aXN0aW5nUHJlZmV0Y2hUYXNrICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxQcmVmZXRjaFRhc2soZXhpc3RpbmdQcmVmZXRjaFRhc2spXG4gICAgfVxuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gcmVzZXQgdGhlIHByZWZldGNoVGFzayB0byBudWxsIHVwb24gY2FuY2VsbGF0aW9uOyBhblxuICAgIC8vIG9sZCB0YXNrIG9iamVjdCBjYW4gYmUgcmVzY2hlZHVsZWQgd2l0aCByZXNjaGVkdWxlUHJlZmV0Y2hUYXNrLiBUaGlzIGlzIGFcbiAgICAvLyBtaWNyby1vcHRpbWl6YXRpb24gYnV0IGFsc28gbWFrZXMgdGhlIGNvZGUgc2ltcGxlciAoZG9uJ3QgbmVlZCB0b1xuICAgIC8vIHdvcnJ5IGFib3V0IHdoZXRoZXIgYW4gb2xkIHRhc2sgb2JqZWN0IGlzIHN0YWxlKS5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICghcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9TRUdNRU5UX0NBQ0hFKSB7XG4gICAgLy8gVGhlIG9sZCBwcmVmZXRjaCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBoYXZlIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMuXG4gICAgLy8gSnVzdCBzY2hlZHVsZSBhIG5ldyBwcmVmZXRjaCB0YXNrLlxuICAgIHByZWZldGNoV2l0aE9sZENhY2hlSW1wbGVtZW50YXRpb24oaW5zdGFuY2UpXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBhcHBSb3V0ZXJTdGF0ZSA9IGdldEN1cnJlbnRBcHBSb3V0ZXJTdGF0ZSgpXG4gIGlmIChhcHBSb3V0ZXJTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHRyZWVBdFRpbWVPZlByZWZldGNoID0gYXBwUm91dGVyU3RhdGUudHJlZVxuICAgIGlmIChleGlzdGluZ1ByZWZldGNoVGFzayA9PT0gbnVsbCkge1xuICAgICAgLy8gSW5pdGlhdGUgYSBwcmVmZXRjaCB0YXNrLlxuICAgICAgY29uc3QgbmV4dFVybCA9IGFwcFJvdXRlclN0YXRlLm5leHRVcmxcbiAgICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlQ2FjaGVLZXkoaW5zdGFuY2UucHJlZmV0Y2hIcmVmLCBuZXh0VXJsKVxuICAgICAgaW5zdGFuY2UucHJlZmV0Y2hUYXNrID0gc2NoZWR1bGVTZWdtZW50UHJlZmV0Y2hUYXNrKFxuICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgdHJlZUF0VGltZU9mUHJlZmV0Y2gsXG4gICAgICAgIGluc3RhbmNlLmZldGNoU3RyYXRlZ3ksXG4gICAgICAgIHByaW9yaXR5LFxuICAgICAgICBudWxsXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBvbGQgdGFzayBvYmplY3QgdGhhdCB3ZSBjYW4gcmVzY2hlZHVsZS4gVGhpcyBpc1xuICAgICAgLy8gZWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgY2FuY2VsaW5nIHRoZSBvbGQgdGFzayBhbmQgY3JlYXRpbmcgYSBuZXcgb25lLlxuICAgICAgcmVzY2hlZHVsZVByZWZldGNoVGFzayhcbiAgICAgICAgZXhpc3RpbmdQcmVmZXRjaFRhc2ssXG4gICAgICAgIHRyZWVBdFRpbWVPZlByZWZldGNoLFxuICAgICAgICBpbnN0YW5jZS5mZXRjaFN0cmF0ZWd5LFxuICAgICAgICBwcmlvcml0eVxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGluZ1Zpc2libGVMaW5rcyhcbiAgbmV4dFVybDogc3RyaW5nIHwgbnVsbCxcbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbikge1xuICAvLyBGb3IgZWFjaCBjdXJyZW50bHkgdmlzaWJsZSBsaW5rLCBjYW5jZWwgdGhlIGV4aXN0aW5nIHByZWZldGNoIHRhc2sgKGlmIGl0XG4gIC8vIGV4aXN0cykgYW5kIHNjaGVkdWxlIGEgbmV3IG9uZS4gVGhpcyBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBpZiBhbGwgdGhlXG4gIC8vIHZpc2libGUgbGlua3MgbGVmdCBhbmQgdGhlbiByZS1lbnRlcmVkIHRoZSB2aWV3cG9ydC5cbiAgLy9cbiAgLy8gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgTmV4dC1Vcmwgb3IgdGhlIGJhc2UgdHJlZSBjaGFuZ2VzLCBzaW5jZSB0aG9zZVxuICAvLyBtYXkgYWZmZWN0IHRoZSByZXN1bHQgb2YgYSBwcmVmZXRjaCB0YXNrLiBJdCdzIGFsc28gY2FsbGVkIGFmdGVyIGFcbiAgLy8gY2FjaGUgaW52YWxpZGF0aW9uLlxuICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIHByZWZldGNoYWJsZUFuZFZpc2libGUpIHtcbiAgICBjb25zdCB0YXNrID0gaW5zdGFuY2UucHJlZmV0Y2hUYXNrXG4gICAgaWYgKHRhc2sgIT09IG51bGwgJiYgIWlzUHJlZmV0Y2hUYXNrRGlydHkodGFzaywgbmV4dFVybCwgdHJlZSkpIHtcbiAgICAgIC8vIFRoZSBjYWNoZSBoYXMgbm90IGJlZW4gaW52YWxpZGF0ZWQsIGFuZCBub25lIG9mIHRoZSBpbnB1dHMgaGF2ZVxuICAgICAgLy8gY2hhbmdlZC4gQmFpbCBvdXQuXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICAvLyBTb21ldGhpbmcgY2hhbmdlZC4gQ2FuY2VsIHRoZSBleGlzdGluZyBwcmVmZXRjaCB0YXNrIGFuZCBzY2hlZHVsZSBhXG4gICAgLy8gbmV3IG9uZS5cbiAgICBpZiAodGFzayAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsUHJlZmV0Y2hUYXNrKHRhc2spXG4gICAgfVxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY3JlYXRlQ2FjaGVLZXkoaW5zdGFuY2UucHJlZmV0Y2hIcmVmLCBuZXh0VXJsKVxuICAgIGluc3RhbmNlLnByZWZldGNoVGFzayA9IHNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayhcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgdHJlZSxcbiAgICAgIGluc3RhbmNlLmZldGNoU3RyYXRlZ3ksXG4gICAgICBQcmVmZXRjaFByaW9yaXR5LkRlZmF1bHQsXG4gICAgICBudWxsXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZWZldGNoV2l0aE9sZENhY2hlSW1wbGVtZW50YXRpb24oaW5zdGFuY2U6IFByZWZldGNoYWJsZUluc3RhbmNlKSB7XG4gIC8vIFRoaXMgaXMgdGhlIHBhdGggdXNlZCB3aGVuIHRoZSBTZWdtZW50IENhY2hlIGlzIG5vdCBlbmFibGVkLlxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGRvUHJlZmV0Y2ggPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gbm90ZSB0aGF0IGBhcHBSb3V0ZXIucHJlZmV0Y2goKWAgaXMgY3VycmVudGx5IHN5bmMsXG4gICAgLy8gc28gd2UgaGF2ZSB0byB3cmFwIHRoaXMgY2FsbCBpbiBhbiBhc3luYyBmdW5jdGlvbiB0byBiZSBhYmxlIHRvIGNhdGNoKCkgZXJyb3JzIGJlbG93LlxuXG4gICAgbGV0IHByZWZldGNoS2luZDogUHJlZmV0Y2hLaW5kXG4gICAgc3dpdGNoIChpbnN0YW5jZS5mZXRjaFN0cmF0ZWd5KSB7XG4gICAgICBjYXNlIEZldGNoU3RyYXRlZ3kuUFBSOiB7XG4gICAgICAgIHByZWZldGNoS2luZCA9IFByZWZldGNoS2luZC5BVVRPXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlIEZldGNoU3RyYXRlZ3kuRnVsbDoge1xuICAgICAgICBwcmVmZXRjaEtpbmQgPSBQcmVmZXRjaEtpbmQuRlVMTFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY2FzZSBGZXRjaFN0cmF0ZWd5LlBQUlJ1bnRpbWU6IHtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgZ2V0IGhlcmUgaWYgQ2xpZW50IFNlZ21lbnQgQ2FjaGUgaXMgb2ZmLCBhbmQgaW4gdGhhdCBjYXNlXG4gICAgICAgIC8vIGl0IHNob3VsZG4ndCBiZSBwb3NzaWJsZSBmb3IgYSBsaW5rIHRvIHJlcXVlc3QgYSBydW50aW1lIHByZWZldGNoLlxuICAgICAgICB0aHJvdyBuZXcgSW52YXJpYW50RXJyb3IoXG4gICAgICAgICAgJ0ZldGNoU3RyYXRlZ3kuUFBSUnVudGltZSBzaG91bGQgbmV2ZXIgYmUgdXNlZCB3aGVuIGBleHBlcmltZW50YWwuY2xpZW50U2VnbWVudENhY2hlYCBpcyBkaXNhYmxlZCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpbnN0YW5jZS5mZXRjaFN0cmF0ZWd5IHNhdGlzZmllcyBuZXZlclxuICAgICAgICAvLyBVbnJlYWNoYWJsZSwgYnV0IG90aGVyd2lzZSB0eXBlc2NyaXB0IHdpbGwgY29uc2lkZXIgdGhlIHZhcmlhYmxlIHVuYXNzaWduZWRcbiAgICAgICAgcHJlZmV0Y2hLaW5kID0gdW5kZWZpbmVkIVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZS5yb3V0ZXIucHJlZmV0Y2goaW5zdGFuY2UucHJlZmV0Y2hIcmVmLCB7XG4gICAgICBraW5kOiBwcmVmZXRjaEtpbmQsXG4gICAgfSlcbiAgfVxuXG4gIC8vIFByZWZldGNoIHRoZSBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICBkb1ByZWZldGNoKCkuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG59XG4iXSwibmFtZXMiOlsiSURMRV9MSU5LX1NUQVRVUyIsIlBFTkRJTkdfTElOS19TVEFUVVMiLCJtb3VudEZvcm1JbnN0YW5jZSIsIm1vdW50TGlua0luc3RhbmNlIiwib25MaW5rVmlzaWJpbGl0eUNoYW5nZWQiLCJvbk5hdmlnYXRpb25JbnRlbnQiLCJwaW5nVmlzaWJsZUxpbmtzIiwic2V0TGlua0ZvckN1cnJlbnROYXZpZ2F0aW9uIiwidW5tb3VudExpbmtGb3JDdXJyZW50TmF2aWdhdGlvbiIsInVubW91bnRQcmVmZXRjaGFibGVJbnN0YW5jZSIsImxpbmtGb3JNb3N0UmVjZW50TmF2aWdhdGlvbiIsInBlbmRpbmciLCJsaW5rIiwic3RhcnRUcmFuc2l0aW9uIiwic2V0T3B0aW1pc3RpY0xpbmtTdGF0dXMiLCJwcmVmZXRjaGFibGUiLCJXZWFrTWFwIiwiTWFwIiwicHJlZmV0Y2hhYmxlQW5kVmlzaWJsZSIsIlNldCIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJoYW5kbGVJbnRlcnNlY3QiLCJyb290TWFyZ2luIiwib2JzZXJ2ZVZpc2liaWxpdHkiLCJlbGVtZW50IiwiaW5zdGFuY2UiLCJleGlzdGluZ0luc3RhbmNlIiwiZ2V0IiwidW5kZWZpbmVkIiwic2V0Iiwib2JzZXJ2ZSIsImNvZXJjZVByZWZldGNoYWJsZVVybCIsImhyZWYiLCJjcmVhdGVQcmVmZXRjaFVSTCIsInJlcG9ydEVycm9yRm4iLCJyZXBvcnRFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsInJvdXRlciIsImZldGNoU3RyYXRlZ3kiLCJwcmVmZXRjaEVuYWJsZWQiLCJwcmVmZXRjaFVSTCIsImlzVmlzaWJsZSIsInByZWZldGNoVGFzayIsInByZWZldGNoSHJlZiIsImRlbGV0ZSIsImNhbmNlbFByZWZldGNoVGFzayIsInVub2JzZXJ2ZSIsImVudHJpZXMiLCJlbnRyeSIsImludGVyc2VjdGlvblJhdGlvIiwidGFyZ2V0IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiYWRkIiwicmVzY2hlZHVsZUxpbmtQcmVmZXRjaCIsIlByZWZldGNoUHJpb3JpdHkiLCJEZWZhdWx0IiwidW5zdGFibGVfdXBncmFkZVRvRHluYW1pY1ByZWZldGNoIiwiX19ORVhUX0RZTkFNSUNfT05fSE9WRVIiLCJGZXRjaFN0cmF0ZWd5IiwiRnVsbCIsIkludGVudCIsInByaW9yaXR5IiwiZXhpc3RpbmdQcmVmZXRjaFRhc2siLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJwcmVmZXRjaFdpdGhPbGRDYWNoZUltcGxlbWVudGF0aW9uIiwiYXBwUm91dGVyU3RhdGUiLCJnZXRDdXJyZW50QXBwUm91dGVyU3RhdGUiLCJ0cmVlQXRUaW1lT2ZQcmVmZXRjaCIsInRyZWUiLCJuZXh0VXJsIiwiY2FjaGVLZXkiLCJjcmVhdGVDYWNoZUtleSIsInNjaGVkdWxlU2VnbWVudFByZWZldGNoVGFzayIsInJlc2NoZWR1bGVQcmVmZXRjaFRhc2siLCJ0YXNrIiwiaXNQcmVmZXRjaFRhc2tEaXJ0eSIsIndpbmRvdyIsImRvUHJlZmV0Y2giLCJwcmVmZXRjaEtpbmQiLCJQUFIiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiRlVMTCIsIlBQUlJ1bnRpbWUiLCJJbnZhcmlhbnRFcnJvciIsInByZWZldGNoIiwia2luZCIsImNhdGNoIiwiZXJyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/links.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"createInitialRouterState\", ({\n    enumerable: true,\n    get: function() {\n        return createInitialRouterState;\n    }\n}));\nconst _createhreffromurl = __webpack_require__(/*! ./create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _filllazyitemstillleafwithhead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nconst _computechangedpath = __webpack_require__(/*! ./compute-changed-path */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/compute-changed-path.js\");\nconst _prefetchcacheutils = __webpack_require__(/*! ./prefetch-cache-utils */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _refetchinactiveparallelsegments = __webpack_require__(/*! ./refetch-inactive-parallel-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nfunction createInitialRouterState(param) {\n    let { navigatedAt, initialFlightData, initialCanonicalUrlParts, initialParallelRoutes, location, couldBeIntercepted, postponed, prerendered } = param;\n    // When initialized on the server, the canonical URL is provided as an array of parts.\n    // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n    // as a URL that should be crawled.\n    const initialCanonicalUrl = initialCanonicalUrlParts.join('/');\n    const normalizedFlightData = (0, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[0]);\n    const { tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;\n    // For the SSR render, seed data should always be available (we only send back a `null` response\n    // in the case of a `loading` segment, pre-PPR.)\n    const rsc = initialSeedData == null ? void 0 : initialSeedData[1];\n    var _initialSeedData_;\n    const loading = (_initialSeedData_ = initialSeedData == null ? void 0 : initialSeedData[3]) != null ? _initialSeedData_ : null;\n    const cache = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: initialParallelRoutes,\n        loading,\n        navigatedAt\n    };\n    const canonicalUrl = // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location ? (0, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;\n    (0, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);\n    const prefetchCache = new Map();\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, initialTree, initialSeedData, initialHead, undefined);\n    }\n    var _ref;\n    const initialState = {\n        tree: initialTree,\n        cache,\n        prefetchCache,\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false,\n            // First render needs to preserve the previous window.history.state\n            // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n            preserveCustomHistoryState: true\n        },\n        focusAndScrollRef: {\n            apply: false,\n            onlyHashChange: false,\n            hashFragment: null,\n            segmentPaths: []\n        },\n        canonicalUrl,\n        nextUrl: (_ref = (0, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == null ? void 0 : location.pathname)) != null ? _ref : null\n    };\n    if (false) {}\n    return initialState;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLmpzIiwibWFwcGluZ3MiOiI7Ozs7NERBeUJnQkE7OztlQUFBQTs7OytDQXRCa0I7MkRBQ1k7Z0RBQ0c7Z0RBSTFDO2dEQUMrQzs2REFDRzsrQ0FDZDtBQWFwQyxTQUFTQSx5QkFBeUIsS0FTVjtJQVRVLE1BQ3ZDQyxXQUFXLEVBQ1hDLGlCQUFpQixFQUNqQkMsd0JBQXdCLEVBQ3hCQyxxQkFBcUIsRUFDckJDLFFBQVEsRUFDUkMsa0JBQWtCLEVBQ2xCQyxTQUFTLEVBQ1RDLFdBQVcsRUFDa0IsR0FUVTtJQVV2QyxzRkFBc0Y7SUFDdEYsa0dBQWtHO0lBQ2xHLG1DQUFtQztJQUNuQyxNQUFNQyxzQkFBc0JOLHlCQUF5Qk8sSUFBSSxDQUFDO0lBRTFELE1BQU1DLHVCQUF1QkMsQ0FBQUEsR0FBQUEsbUJBQUFBLDBCQUFBQSxFQUEyQlYsaUJBQWlCLENBQUMsRUFBRTtJQUM1RSxNQUFNLEVBQ0pXLE1BQU1DLFdBQVcsRUFDakJDLFVBQVVDLGVBQWUsRUFDekJDLE1BQU1DLFdBQVcsRUFDbEIsR0FBR1A7SUFDSixnR0FBZ0c7SUFDaEcsZ0RBQWdEO0lBQ2hELE1BQU1RLE1BQU1ILG1CQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxlQUFpQixDQUFDLEVBQUU7UUFDaEJBO0lBQWhCLE1BQU1JLFVBQVVKLENBQUFBLG9CQUFBQSxtQkFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsZUFBaUIsQ0FBQyxPQUFFLE9BQXBCQSxvQkFBd0I7SUFFeEMsTUFBTUssUUFBbUI7UUFDdkJDLFVBQVU7UUFDVkg7UUFDQUksYUFBYTtRQUNiTixNQUFNO1FBQ05PLGNBQWM7UUFDZCxvSkFBb0o7UUFDcEpDLGdCQUFnQnJCO1FBQ2hCZ0I7UUFDQW5CO0lBQ0Y7SUFFQSxNQUFNeUIsZUFDSiw2RUFBNkUscUVBQ3FFO0lBQ2xKckIsV0FFSXNCLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ3RCLFlBQ2xCSTtJQUVObUIsQ0FBQUEsR0FBQUEsaUNBQUFBLHdDQUFBQSxFQUF5Q2QsYUFBYVk7SUFFdEQsTUFBTUcsZ0JBQWdCLElBQUlDO0lBRTFCLHlFQUF5RTtJQUN6RSxJQUFJMUIsMEJBQTBCLFFBQVFBLHNCQUFzQjJCLElBQUksS0FBSyxHQUFHO1FBQ3RFQyxDQUFBQSxHQUFBQSwrQkFBQUEsNkJBQUFBLEVBQ0UvQixhQUNBb0IsT0FDQVksV0FDQW5CLGFBQ0FFLGlCQUNBRSxhQUNBZTtJQUVKO1FBc0JLQztJQXBCTCxNQUFNQyxlQUFlO1FBQ25CdEIsTUFBTUM7UUFDTk87UUFDQVE7UUFDQU8sU0FBUztZQUNQQyxhQUFhO1lBQ2JDLGVBQWU7WUFDZixtRUFBbUU7WUFDbkUsZ0ZBQWdGO1lBQ2hGQyw0QkFBNEI7UUFDOUI7UUFDQUMsbUJBQW1CO1lBQ2pCQyxPQUFPO1lBQ1BDLGdCQUFnQjtZQUNoQkMsY0FBYztZQUNkQyxjQUFjLEVBQUU7UUFDbEI7UUFDQWxCO1FBQ0FtQixTQUVFLENBQUNYLE9BQUFBLENBQUFBLEdBQUFBLG9CQUFBQSxnQ0FBQUEsRUFBaUNwQixpQkFBZ0JULFlBQUFBLE9BQUFBLEtBQUFBLElBQUFBLFNBQVV5QyxRQUFBQSxDQUFRLFlBQW5FWixPQUNEO0lBQ0o7SUFFQSxJQUFJYSxLQUFrRDFDLEVBQUUsRUF1Q3ZEO0lBRUQsT0FBTzhCO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNtaW5pL0RvY3VtZW50cy9zcmMvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEZsaWdodERhdGFQYXRoIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2FwcC1yZW5kZXIvdHlwZXMnXG5cbmltcG9ydCB7IGNyZWF0ZUhyZWZGcm9tVXJsIH0gZnJvbSAnLi9jcmVhdGUtaHJlZi1mcm9tLXVybCdcbmltcG9ydCB7IGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIH0gZnJvbSAnLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZCdcbmltcG9ydCB7IGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIH0gZnJvbSAnLi9jb21wdXRlLWNoYW5nZWQtcGF0aCdcbmltcG9ydCB7XG4gIGNyZWF0ZVNlZWRlZFByZWZldGNoQ2FjaGVFbnRyeSxcbiAgU1RBVElDX1NUQUxFVElNRV9NUyxcbn0gZnJvbSAnLi9wcmVmZXRjaC1jYWNoZS11dGlscydcbmltcG9ydCB7IFByZWZldGNoS2luZCwgdHlwZSBQcmVmZXRjaENhY2hlRW50cnkgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgYWRkUmVmcmVzaE1hcmtlclRvQWN0aXZlUGFyYWxsZWxTZWdtZW50cyB9IGZyb20gJy4vcmVmZXRjaC1pbmFjdGl2ZS1wYXJhbGxlbC1zZWdtZW50cydcbmltcG9ydCB7IGdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoIH0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcblxuZXhwb3J0IGludGVyZmFjZSBJbml0aWFsUm91dGVyU3RhdGVQYXJhbWV0ZXJzIHtcbiAgbmF2aWdhdGVkQXQ6IG51bWJlclxuICBpbml0aWFsQ2Fub25pY2FsVXJsUGFydHM6IHN0cmluZ1tdXG4gIGluaXRpYWxQYXJhbGxlbFJvdXRlczogQ2FjaGVOb2RlWydwYXJhbGxlbFJvdXRlcyddXG4gIGluaXRpYWxGbGlnaHREYXRhOiBGbGlnaHREYXRhUGF0aFtdXG4gIGxvY2F0aW9uOiBMb2NhdGlvbiB8IG51bGxcbiAgY291bGRCZUludGVyY2VwdGVkOiBib29sZWFuXG4gIHBvc3Rwb25lZDogYm9vbGVhblxuICBwcmVyZW5kZXJlZDogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlKHtcbiAgbmF2aWdhdGVkQXQsXG4gIGluaXRpYWxGbGlnaHREYXRhLFxuICBpbml0aWFsQ2Fub25pY2FsVXJsUGFydHMsXG4gIGluaXRpYWxQYXJhbGxlbFJvdXRlcyxcbiAgbG9jYXRpb24sXG4gIGNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgcG9zdHBvbmVkLFxuICBwcmVyZW5kZXJlZCxcbn06IEluaXRpYWxSb3V0ZXJTdGF0ZVBhcmFtZXRlcnMpIHtcbiAgLy8gV2hlbiBpbml0aWFsaXplZCBvbiB0aGUgc2VydmVyLCB0aGUgY2Fub25pY2FsIFVSTCBpcyBwcm92aWRlZCBhcyBhbiBhcnJheSBvZiBwYXJ0cy5cbiAgLy8gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB3aGVuIHRoZSBSU0MgcGF5bG9hZCBzdHJlYW1lZCB0byB0aGUgY2xpZW50LCBjcmF3bGVycyBkb24ndCBpbnRlcnByZXQgaXRcbiAgLy8gYXMgYSBVUkwgdGhhdCBzaG91bGQgYmUgY3Jhd2xlZC5cbiAgY29uc3QgaW5pdGlhbENhbm9uaWNhbFVybCA9IGluaXRpYWxDYW5vbmljYWxVcmxQYXJ0cy5qb2luKCcvJylcblxuICBjb25zdCBub3JtYWxpemVkRmxpZ2h0RGF0YSA9IGdldEZsaWdodERhdGFQYXJ0c0Zyb21QYXRoKGluaXRpYWxGbGlnaHREYXRhWzBdKVxuICBjb25zdCB7XG4gICAgdHJlZTogaW5pdGlhbFRyZWUsXG4gICAgc2VlZERhdGE6IGluaXRpYWxTZWVkRGF0YSxcbiAgICBoZWFkOiBpbml0aWFsSGVhZCxcbiAgfSA9IG5vcm1hbGl6ZWRGbGlnaHREYXRhXG4gIC8vIEZvciB0aGUgU1NSIHJlbmRlciwgc2VlZCBkYXRhIHNob3VsZCBhbHdheXMgYmUgYXZhaWxhYmxlICh3ZSBvbmx5IHNlbmQgYmFjayBhIGBudWxsYCByZXNwb25zZVxuICAvLyBpbiB0aGUgY2FzZSBvZiBhIGBsb2FkaW5nYCBzZWdtZW50LCBwcmUtUFBSLilcbiAgY29uc3QgcnNjID0gaW5pdGlhbFNlZWREYXRhPy5bMV1cbiAgY29uc3QgbG9hZGluZyA9IGluaXRpYWxTZWVkRGF0YT8uWzNdID8/IG51bGxcblxuICBjb25zdCBjYWNoZTogQ2FjaGVOb2RlID0ge1xuICAgIGxhenlEYXRhOiBudWxsLFxuICAgIHJzYyxcbiAgICBwcmVmZXRjaFJzYzogbnVsbCxcbiAgICBoZWFkOiBudWxsLFxuICAgIHByZWZldGNoSGVhZDogbnVsbCxcbiAgICAvLyBUaGUgY2FjaGUgZ2V0cyBzZWVkZWQgZHVyaW5nIHRoZSBmaXJzdCByZW5kZXIuIGBpbml0aWFsUGFyYWxsZWxSb3V0ZXNgIGVuc3VyZXMgdGhlIGNhY2hlIGZyb20gdGhlIGZpcnN0IHJlbmRlciBpcyB0aGVyZSBkdXJpbmcgdGhlIHNlY29uZCByZW5kZXIuXG4gICAgcGFyYWxsZWxSb3V0ZXM6IGluaXRpYWxQYXJhbGxlbFJvdXRlcyxcbiAgICBsb2FkaW5nLFxuICAgIG5hdmlnYXRlZEF0LFxuICB9XG5cbiAgY29uc3QgY2Fub25pY2FsVXJsID1cbiAgICAvLyBsb2NhdGlvbi5ocmVmIGlzIHJlYWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgZm9yIGNhbm9uaWNhbFVybCBpbiB0aGUgYnJvd3NlclxuICAgIC8vIFRoaXMgaXMgc2FmZSB0byBkbyBhcyBjYW5vbmljYWxVcmwgY2FuJ3QgYmUgcmVuZGVyZWQsIGl0J3Mgb25seSB1c2VkIHRvIGNvbnRyb2wgdGhlIGhpc3RvcnkgdXBkYXRlcyBpbiB0aGUgdXNlRWZmZWN0IGZ1cnRoZXIgZG93biBpbiB0aGlzIGZpbGUuXG4gICAgbG9jYXRpb25cbiAgICAgID8gLy8gd2luZG93LmxvY2F0aW9uIGRvZXMgbm90IGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBVUkwgYnV0IGhhcyBhbGwgdGhlIGZpZWxkcyBjcmVhdGVIcmVmRnJvbVVybCBuZWVkcy5cbiAgICAgICAgY3JlYXRlSHJlZkZyb21VcmwobG9jYXRpb24pXG4gICAgICA6IGluaXRpYWxDYW5vbmljYWxVcmxcblxuICBhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzKGluaXRpYWxUcmVlLCBjYW5vbmljYWxVcmwpXG5cbiAgY29uc3QgcHJlZmV0Y2hDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBQcmVmZXRjaENhY2hlRW50cnk+KClcblxuICAvLyBXaGVuIHRoZSBjYWNoZSBoYXNuJ3QgYmVlbiBzZWVkZWQgeWV0IHdlIGZpbGwgdGhlIGNhY2hlIHdpdGggdGhlIGhlYWQuXG4gIGlmIChpbml0aWFsUGFyYWxsZWxSb3V0ZXMgPT09IG51bGwgfHwgaW5pdGlhbFBhcmFsbGVsUm91dGVzLnNpemUgPT09IDApIHtcbiAgICBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChcbiAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgY2FjaGUsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBpbml0aWFsVHJlZSxcbiAgICAgIGluaXRpYWxTZWVkRGF0YSxcbiAgICAgIGluaXRpYWxIZWFkLFxuICAgICAgdW5kZWZpbmVkXG4gICAgKVxuICB9XG5cbiAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgIHRyZWU6IGluaXRpYWxUcmVlLFxuICAgIGNhY2hlLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAgcHVzaFJlZjoge1xuICAgICAgcGVuZGluZ1B1c2g6IGZhbHNlLFxuICAgICAgbXBhTmF2aWdhdGlvbjogZmFsc2UsXG4gICAgICAvLyBGaXJzdCByZW5kZXIgbmVlZHMgdG8gcHJlc2VydmUgdGhlIHByZXZpb3VzIHdpbmRvdy5oaXN0b3J5LnN0YXRlXG4gICAgICAvLyB0byBhdm9pZCBpdCBiZWluZyBvdmVyd3JpdHRlbiBvbiBuYXZpZ2F0aW9uIGJhY2svZm9yd2FyZCB3aXRoIE1QQSBOYXZpZ2F0aW9uLlxuICAgICAgcHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGU6IHRydWUsXG4gICAgfSxcbiAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgYXBwbHk6IGZhbHNlLFxuICAgICAgb25seUhhc2hDaGFuZ2U6IGZhbHNlLFxuICAgICAgaGFzaEZyYWdtZW50OiBudWxsLFxuICAgICAgc2VnbWVudFBhdGhzOiBbXSxcbiAgICB9LFxuICAgIGNhbm9uaWNhbFVybCxcbiAgICBuZXh0VXJsOlxuICAgICAgLy8gdGhlIHx8IG9wZXJhdG9yIGlzIGludGVudGlvbmFsLCB0aGUgcGF0aG5hbWUgY2FuIGJlIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgKGV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlKGluaXRpYWxUcmVlKSB8fCBsb2NhdGlvbj8ucGF0aG5hbWUpID8/XG4gICAgICBudWxsLFxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmIGxvY2F0aW9uKSB7XG4gICAgLy8gU2VlZCB0aGUgcHJlZmV0Y2ggY2FjaGUgd2l0aCB0aGlzIHBhZ2UncyBkYXRhLlxuICAgIC8vIFRoaXMgaXMgdG8gcHJldmVudCBuZWVkbGVzc2x5IHJlLXByZWZldGNoaW5nIGEgcGFnZSB0aGF0IGlzIGFscmVhZHkgcmV1c2FibGUsXG4gICAgLy8gYW5kIHdpbGwgYXZvaWQgdHJpZ2dlcmluZyBhIGxvYWRpbmcgc3RhdGUvZGF0YSBmZXRjaCBzdGFsbCB3aGVuIG5hdmlnYXRpbmcgYmFjayB0byB0aGUgcGFnZS5cbiAgICAvLyBXZSBkb24ndCBjdXJyZW50bHkgZG8gdGhpcyBpbiBkZXZlbG9wbWVudCBiZWNhdXNlIGxpbmtzIGFyZW4ndCBwcmVmZXRjaGVkIGluIGRldmVsb3BtZW50XG4gICAgLy8gc28gaGF2aW5nIGEgbWlzbWF0Y2ggYmV0d2VlbiBwcmVmZXRjaC9ubyBwcmVmZXRjaCBwcm92aWRlcyBpbmNvbnNpc3RlbnQgYmVoYXZpb3IgYmFzZWQgb24gd2hpY2ggcGFnZVxuICAgIC8vIHdhcyBsb2FkZWQgZmlyc3QuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChcbiAgICAgIGAke2xvY2F0aW9uLnBhdGhuYW1lfSR7bG9jYXRpb24uc2VhcmNofWAsXG4gICAgICBsb2NhdGlvbi5vcmlnaW5cbiAgICApXG5cbiAgICBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YToge1xuICAgICAgICBmbGlnaHREYXRhOiBbbm9ybWFsaXplZEZsaWdodERhdGFdLFxuICAgICAgICBjYW5vbmljYWxVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgY291bGRCZUludGVyY2VwdGVkOiAhIWNvdWxkQmVJbnRlcmNlcHRlZCxcbiAgICAgICAgcHJlcmVuZGVyZWQsXG4gICAgICAgIHBvc3Rwb25lZCxcbiAgICAgICAgLy8gVE9ETzogVGhlIGluaXRpYWwgUlNDIHBheWxvYWQgaW5jbHVkZXMgYm90aCBzdGF0aWMgYW5kIGR5bmFtaWMgZGF0YVxuICAgICAgICAvLyBpbiB0aGUgc2FtZSByZXNwb25zZSwgZXZlbiBpZiBQUFIgaXMgZW5hYmxlZC4gU28gaWYgdGhlcmUncyBhbnlcbiAgICAgICAgLy8gZHluYW1pYyBkYXRhIGF0IGFsbCwgd2UgY2FuJ3Qgc2V0IGEgc3RhbGUgdGltZS4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXlcbiAgICAgICAgLy8gYWRkIGEgd2F5IHRvIHNwbGl0IGEgc2luZ2xlIEZsaWdodCBzdHJlYW0gaW50byBzdGF0aWMgYW5kIGR5bmFtaWNcbiAgICAgICAgLy8gcGFydHMuIEJ1dCBpbiB0aGUgbWVhbnRpbWUgd2Ugc2hvdWxkIGF0IGxlYXN0IG1ha2UgdGhpcyB3b3JrIGZvclxuICAgICAgICAvLyBmdWxseSBzdGF0aWMgcGFnZXMuXG4gICAgICAgIHN0YWxlVGltZTpcbiAgICAgICAgICAvLyBJbiB0aGUgb2xkIHJvdXRlciwgdGhlcmUgd2FzIG9ubHkgYSBzaW5nbGUgY29uZmlndXJhYmxlIHN0YWxlVGltZSAoZXhwZXJpbWVudGFsLnN0YWxlVGltZXMpXG4gICAgICAgICAgLy8gQXMgYW4gYWJ1bmRhbmNlIG9mIGNhdXRpb24sIHRoaXMgd2lsbCBvbmx5IHNldCB0aGUgaW5pdGlhbCBzdGFsZVRpbWUgdG8gdGhlIGNvbmZpZ3VyZWQgdmFsdWVcbiAgICAgICAgICAvLyBpZiB3ZSdyZSBub3QgbGV2ZXJhZ2luZyB0aGUgc2VnbWVudCBjYWNoZSwgd2hpY2ggaGFzIGl0cyBvd24gcHJlZmV0Y2hpbmcgc2VtYW50aWNzLlxuICAgICAgICAgIHByZXJlbmRlcmVkICYmICFwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEVcbiAgICAgICAgICAgID8gU1RBVElDX1NUQUxFVElNRV9NU1xuICAgICAgICAgICAgOiAtMSxcbiAgICAgIH0sXG4gICAgICB0cmVlOiBpbml0aWFsU3RhdGUudHJlZSxcbiAgICAgIHByZWZldGNoQ2FjaGU6IGluaXRpYWxTdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgbmV4dFVybDogaW5pdGlhbFN0YXRlLm5leHRVcmwsXG4gICAgICBraW5kOiBwcmVyZW5kZXJlZCA/IFByZWZldGNoS2luZC5GVUxMIDogUHJlZmV0Y2hLaW5kLkFVVE8sXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBpbml0aWFsU3RhdGVcbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVJbml0aWFsUm91dGVyU3RhdGUiLCJuYXZpZ2F0ZWRBdCIsImluaXRpYWxGbGlnaHREYXRhIiwiaW5pdGlhbENhbm9uaWNhbFVybFBhcnRzIiwiaW5pdGlhbFBhcmFsbGVsUm91dGVzIiwibG9jYXRpb24iLCJjb3VsZEJlSW50ZXJjZXB0ZWQiLCJwb3N0cG9uZWQiLCJwcmVyZW5kZXJlZCIsImluaXRpYWxDYW5vbmljYWxVcmwiLCJqb2luIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJnZXRGbGlnaHREYXRhUGFydHNGcm9tUGF0aCIsInRyZWUiLCJpbml0aWFsVHJlZSIsInNlZWREYXRhIiwiaW5pdGlhbFNlZWREYXRhIiwiaGVhZCIsImluaXRpYWxIZWFkIiwicnNjIiwibG9hZGluZyIsImNhY2hlIiwibGF6eURhdGEiLCJwcmVmZXRjaFJzYyIsInByZWZldGNoSGVhZCIsInBhcmFsbGVsUm91dGVzIiwiY2Fub25pY2FsVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJhZGRSZWZyZXNoTWFya2VyVG9BY3RpdmVQYXJhbGxlbFNlZ21lbnRzIiwicHJlZmV0Y2hDYWNoZSIsIk1hcCIsInNpemUiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsInVuZGVmaW5lZCIsImV4dHJhY3RQYXRoRnJvbUZsaWdodFJvdXRlclN0YXRlIiwiaW5pdGlhbFN0YXRlIiwicHVzaFJlZiIsInBlbmRpbmdQdXNoIiwibXBhTmF2aWdhdGlvbiIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsIm9ubHlIYXNoQ2hhbmdlIiwiaGFzaEZyYWdtZW50Iiwic2VnbWVudFBhdGhzIiwibmV4dFVybCIsInBhdGhuYW1lIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwidXJsIiwiVVJMIiwic2VhcmNoIiwib3JpZ2luIiwiY3JlYXRlU2VlZGVkUHJlZmV0Y2hDYWNoZUVudHJ5IiwiZGF0YSIsImZsaWdodERhdGEiLCJzdGFsZVRpbWUiLCJfX05FWFRfQ0xJRU5UX1NFR01FTlRfQ0FDSEUiLCJTVEFUSUNfU1RBTEVUSU1FX01TIiwia2luZCIsIlByZWZldGNoS2luZCIsIkZVTEwiLCJBVVRPIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createFetch: function() {\n        return createFetch;\n    },\n    createFromNextReadableStream: function() {\n        return createFromNextReadableStream;\n    },\n    fetchServerResponse: function() {\n        return fetchServerResponse;\n    }\n});\nconst _client = __webpack_require__(/*! react-server-dom-webpack/client */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.browser.js\");\nconst _approuterheaders = __webpack_require__(/*! ../app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nconst _appcallserver = __webpack_require__(/*! ../../app-call-server */ \"(app-pages-browser)/./node_modules/next/dist/client/app-call-server.js\");\nconst _appfindsourcemapurl = __webpack_require__(/*! ../../app-find-source-map-url */ \"(app-pages-browser)/./node_modules/next/dist/client/app-find-source-map-url.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _flightdatahelpers = __webpack_require__(/*! ../../flight-data-helpers */ \"(app-pages-browser)/./node_modules/next/dist/client/flight-data-helpers.js\");\nconst _appbuildid = __webpack_require__(/*! ../../app-build-id */ \"(app-pages-browser)/./node_modules/next/dist/client/app-build-id.js\");\nconst _setcachebustingsearchparam = __webpack_require__(/*! ./set-cache-busting-search-param */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js\");\nconst _routeparams = __webpack_require__(/*! ../../route-params */ \"(app-pages-browser)/./node_modules/next/dist/client/route-params.js\");\nconst createFromReadableStream = _client.createFromReadableStream;\nfunction doMpaNavigation(url) {\n    return {\n        flightData: (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(url, location.origin)).toString(),\n        canonicalUrl: undefined,\n        couldBeIntercepted: false,\n        prerendered: false,\n        postponed: false,\n        staleTime: -1\n    };\n}\nlet abortController = new AbortController();\nif (true) {\n    // Abort any in-flight requests when the page is unloaded, e.g. due to\n    // reloading the page or performing hard navigations. This allows us to ignore\n    // what would otherwise be a thrown TypeError when the browser cancels the\n    // requests.\n    window.addEventListener('pagehide', ()=>{\n        abortController.abort();\n    });\n    // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n    // and the JavaScript execution context is restored by the browser.\n    window.addEventListener('pageshow', ()=>{\n        abortController = new AbortController();\n    });\n}\nasync function fetchServerResponse(url, options) {\n    const { flightRouterState, nextUrl, prefetchKind } = options;\n    const headers = {\n        // Enable flight response\n        [_approuterheaders.RSC_HEADER]: '1',\n        // Provide the current router state\n        [_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (0, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)\n    };\n    /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */ if (prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {\n        headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = '1';\n    }\n    if ( true && options.isHmrRefresh) {\n        headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = '1';\n    }\n    if (nextUrl) {\n        headers[_approuterheaders.NEXT_URL] = nextUrl;\n    }\n    try {\n        var _res_headers_get;\n        // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n        // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n        // Otherwise, all other prefetches are sent with a \"low\" priority.\n        // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n        const fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? 'high' : 'low' : 'auto';\n        if (false) {}\n        const res = await createFetch(url, headers, fetchPriority, abortController.signal);\n        const responseUrl = (0, _routeparams.urlToUrlWithoutFlightMarker)(new URL(res.url));\n        const canonicalUrl = res.redirected ? responseUrl : undefined;\n        const contentType = res.headers.get('content-type') || '';\n        const interception = !!((_res_headers_get = res.headers.get('vary')) == null ? void 0 : _res_headers_get.includes(_approuterheaders.NEXT_URL));\n        const postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);\n        const staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);\n        const staleTime = staleTimeHeaderSeconds !== null ? parseInt(staleTimeHeaderSeconds, 10) * 1000 : -1;\n        let isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);\n        if (false) {}\n        // If fetch returns something different than flight response handle it like a mpa navigation\n        // If the fetch was not 200, we also handle it like a mpa navigation\n        if (!isFlightResponse || !res.ok || !res.body) {\n            // in case the original URL came with a hash, preserve it before redirecting to the new URL\n            if (url.hash) {\n                responseUrl.hash = url.hash;\n            }\n            return doMpaNavigation(responseUrl.toString());\n        }\n        // We may navigate to a page that requires a different Webpack runtime.\n        // In prod, every page will have the same Webpack runtime.\n        // In dev, the Webpack runtime is minimal for each page.\n        // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n        if (true) {\n            await (__webpack_require__(/*! ../../dev/hot-reloader/app/hot-reloader-app */ \"(app-pages-browser)/./node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js\").waitForWebpackRuntimeHotUpdate)();\n        }\n        // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n        const flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;\n        const response = await createFromNextReadableStream(flightStream);\n        if ((0, _appbuildid.getAppBuildId)() !== response.b) {\n            return doMpaNavigation(res.url);\n        }\n        return {\n            flightData: (0, _flightdatahelpers.normalizeFlightData)(response.f),\n            canonicalUrl: canonicalUrl,\n            couldBeIntercepted: interception,\n            prerendered: response.S,\n            postponed,\n            staleTime\n        };\n    } catch (err) {\n        if (!abortController.signal.aborted) {\n            console.error(\"Failed to fetch RSC payload for \" + url + \". Falling back to browser navigation.\", err);\n        }\n        // If fetch fails handle it like a mpa navigation\n        // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n        // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n        return {\n            flightData: url.toString(),\n            canonicalUrl: undefined,\n            couldBeIntercepted: false,\n            prerendered: false,\n            postponed: false,\n            staleTime: -1\n        };\n    }\n}\nasync function createFetch(url, headers, fetchPriority, signal) {\n    // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n    // cache busting search param) from the request so they're\n    // maximally cacheable.\n    if (false) {}\n    if (false) {}\n    const fetchOptions = {\n        // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n        credentials: 'same-origin',\n        headers,\n        priority: fetchPriority || undefined,\n        signal\n    };\n    // `fetchUrl` is slightly different from `url` because we add a cache-busting\n    // search param to it. This should not leak outside of this function, so we\n    // track them separately.\n    let fetchUrl = new URL(url);\n    (0, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);\n    let browserResponse = await fetch(fetchUrl, fetchOptions);\n    // If the server responds with a redirect (e.g. 307), and the redirected\n    // location does not contain the cache busting search param set in the\n    // original request, the response is likely invalid  when following the\n    // redirect, the browser forwards the request headers, but since the cache\n    // busting search param is missing, the server will reject the request due to\n    // a mismatch.\n    //\n    // Ideally, we would be able to intercept the redirect response and perform it\n    // manually, instead of letting the browser automatically follow it, but this\n    // is not allowed by the fetch API.\n    //\n    // So instead, we must \"replay\" the redirect by fetching the new location\n    // again, but this time we'll append the cache busting search param to prevent\n    // a mismatch.\n    //\n    // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n    // custom status code, to prevent the browser from automatically following it.\n    //\n    // This does not affect Server Action-based redirects; those are encoded\n    // differently, as part of the Flight body. It only affects redirects that\n    // occur in a middleware or a third-party proxy.\n    let redirected = browserResponse.redirected;\n    if (false) {}\n    // Remove the cache busting search param from the response URL, to prevent it\n    // from leaking outside of this function.\n    const responseUrl = new URL(browserResponse.url, fetchUrl);\n    responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    const rscResponse = {\n        url: responseUrl.href,\n        // This is true if any redirects occurred, either automatically by the\n        // browser, or manually by us. So it's different from\n        // `browserResponse.redirected`, which only tells us whether the browser\n        // followed a redirect, and only for the last response in the chain.\n        redirected,\n        // These can be copied from the last browser response we received. We\n        // intentionally only expose the subset of fields that are actually used\n        // elsewhere in the codebase.\n        ok: browserResponse.ok,\n        headers: browserResponse.headers,\n        body: browserResponse.body,\n        status: browserResponse.status\n    };\n    return rscResponse;\n}\nfunction createFromNextReadableStream(flightStream) {\n    return createFromReadableStream(flightStream, {\n        callServer: _appcallserver.callServer,\n        findSourceMapURL: _appfindsourcemapurl.findSourceMapURL\n    });\n}\nfunction createUnclosingPrefetchStream(originalFlightStream) {\n    // When PPR is enabled, prefetch streams may contain references that never\n    // resolve, because that's how we encode dynamic data access. In the decoded\n    // object returned by the Flight client, these are reified into hanging\n    // promises that suspend during render, which is effectively what we want.\n    // The UI resolves when it switches to the dynamic data stream\n    // (via useDeferredValue(dynamic, static)).\n    //\n    // However, the Flight implementation currently errors if the server closes\n    // the response before all the references are resolved. As a cheat to work\n    // around this, we wrap the original stream in a new stream that never closes,\n    // and therefore doesn't error.\n    const reader = originalFlightStream.getReader();\n    return new ReadableStream({\n        async pull (controller) {\n            while(true){\n                const { done, value } = await reader.read();\n                if (!done) {\n                    // Pass to the target stream and keep consuming the Flight response\n                    // from the server.\n                    controller.enqueue(value);\n                    continue;\n                }\n                // The server stream has closed. Exit, but intentionally do not close\n                // the target stream.\n                return;\n            }\n        }\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQTJRc0JBLFdBQVc7ZUFBWEE7O0lBcUhOQyw0QkFBNEI7ZUFBNUJBOztJQTNSTUMsbUJBQW1CO2VBQW5CQTs7O29DQWpHc0Q7OENBa0JyRTsyQ0FDb0I7aURBQ007Z0RBQ0o7K0NBS3RCO3dDQUN1Qjt3REFDYTt5Q0FDQztBQUU1QyxNQUFNQywyQkFDSkMsUUFBQUEsd0JBQStCO0FBOEJqQyxTQUFTQyxnQkFBZ0JDLEdBQVc7SUFDbEMsT0FBTztRQUNMQyxZQUFZQyxDQUFBQSxHQUFBQSxhQUFBQSwyQkFBQUEsRUFDVixJQUFJQyxJQUFJSCxLQUFLSSxTQUFTQyxNQUFNLEdBQzVCQyxRQUFRO1FBQ1ZDLGNBQWNDO1FBQ2RDLG9CQUFvQjtRQUNwQkMsYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLFdBQVcsQ0FBQztJQUNkO0FBQ0Y7QUFFQSxJQUFJQyxrQkFBa0IsSUFBSUM7QUFFMUIsSUFBSSxJQUE2QixFQUFFO0lBQ2pDLHNFQUFzRTtJQUN0RSw4RUFBOEU7SUFDOUUsMEVBQTBFO0lBQzFFLFlBQVk7SUFDWkMsT0FBT0MsZ0JBQWdCLENBQUMsWUFBWTtRQUNsQ0gsZ0JBQWdCSSxLQUFLO0lBQ3ZCO0lBRUEsOEVBQThFO0lBQzlFLG1FQUFtRTtJQUNuRUYsT0FBT0MsZ0JBQWdCLENBQUMsWUFBWTtRQUNsQ0gsa0JBQWtCLElBQUlDO0lBQ3hCO0FBQ0Y7QUFNTyxlQUFlbEIsb0JBQ3BCSSxHQUFRLEVBQ1JrQixPQUFtQztJQUVuQyxNQUFNLEVBQUVDLGlCQUFpQixFQUFFQyxPQUFPLEVBQUVDLFlBQVksRUFBRSxHQUFHSDtJQUVyRCxNQUFNSSxVQUEwQjtRQUM5Qix5QkFBeUI7UUFDekIsQ0FBQ0Msa0JBQUFBLFVBQVUsQ0FBQyxFQUFFO1FB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LEtBQU07Z0JBQ1gsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRSxHQUFHLE1BQU1OLE9BQU9PLElBQUk7Z0JBQ3pDLElBQUksQ0FBQ0YsTUFBTTtvQkFDVCxtRUFBbUU7b0JBQ25FLG1CQUFtQjtvQkFDbkJELFdBQVdJLE9BQU8sQ0FBQ0Y7b0JBQ25CO2dCQUNGO2dCQUNBLHFFQUFxRTtnQkFDckUscUJBQXFCO2dCQUNyQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvc3JjL2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuLy8gVE9ETzogRXhwbGljaXRseSBpbXBvcnQgZnJvbSBjbGllbnQuYnJvd3NlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0IHsgY3JlYXRlRnJvbVJlYWRhYmxlU3RyZWFtIGFzIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbUJyb3dzZXIgfSBmcm9tICdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50J1xuXG5pbXBvcnQgdHlwZSB7XG4gIEZsaWdodFJvdXRlclN0YXRlLFxuICBOYXZpZ2F0aW9uRmxpZ2h0UmVzcG9uc2UsXG59IGZyb20gJy4uLy4uLy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuXG5pbXBvcnQgdHlwZSB7IE5FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSIH0gZnJvbSAnLi4vYXBwLXJvdXRlci1oZWFkZXJzJ1xuaW1wb3J0IHtcbiAgTkVYVF9ST1VURVJfUFJFRkVUQ0hfSEVBREVSLFxuICBORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUixcbiAgTkVYVF9SU0NfVU5JT05fUVVFUlksXG4gIE5FWFRfVVJMLFxuICBSU0NfSEVBREVSLFxuICBSU0NfQ09OVEVOVF9UWVBFX0hFQURFUixcbiAgTkVYVF9ITVJfUkVGUkVTSF9IRUFERVIsXG4gIE5FWFRfRElEX1BPU1RQT05FX0hFQURFUixcbiAgTkVYVF9ST1VURVJfU1RBTEVfVElNRV9IRUFERVIsXG59IGZyb20gJy4uL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB7IGNhbGxTZXJ2ZXIgfSBmcm9tICcuLi8uLi9hcHAtY2FsbC1zZXJ2ZXInXG5pbXBvcnQgeyBmaW5kU291cmNlTWFwVVJMIH0gZnJvbSAnLi4vLi4vYXBwLWZpbmQtc291cmNlLW1hcC11cmwnXG5pbXBvcnQgeyBQcmVmZXRjaEtpbmQgfSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHtcbiAgbm9ybWFsaXplRmxpZ2h0RGF0YSxcbiAgcHJlcGFyZUZsaWdodFJvdXRlclN0YXRlRm9yUmVxdWVzdCxcbiAgdHlwZSBOb3JtYWxpemVkRmxpZ2h0RGF0YSxcbn0gZnJvbSAnLi4vLi4vZmxpZ2h0LWRhdGEtaGVscGVycydcbmltcG9ydCB7IGdldEFwcEJ1aWxkSWQgfSBmcm9tICcuLi8uLi9hcHAtYnVpbGQtaWQnXG5pbXBvcnQgeyBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSB9IGZyb20gJy4vc2V0LWNhY2hlLWJ1c3Rpbmctc2VhcmNoLXBhcmFtJ1xuaW1wb3J0IHsgdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIH0gZnJvbSAnLi4vLi4vcm91dGUtcGFyYW1zJ1xuXG5jb25zdCBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW0gPVxuICBjcmVhdGVGcm9tUmVhZGFibGVTdHJlYW1Ccm93c2VyIGFzICh0eXBlb2YgaW1wb3J0KCdyZWFjdC1zZXJ2ZXItZG9tLXdlYnBhY2svY2xpZW50LmJyb3dzZXInKSlbJ2NyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSddXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmV0Y2hTZXJ2ZXJSZXNwb25zZU9wdGlvbnMge1xuICByZWFkb25seSBmbGlnaHRSb3V0ZXJTdGF0ZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgcmVhZG9ubHkgbmV4dFVybDogc3RyaW5nIHwgbnVsbFxuICByZWFkb25seSBwcmVmZXRjaEtpbmQ/OiBQcmVmZXRjaEtpbmRcbiAgcmVhZG9ubHkgaXNIbXJSZWZyZXNoPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0ID0ge1xuICBmbGlnaHREYXRhOiBOb3JtYWxpemVkRmxpZ2h0RGF0YVtdIHwgc3RyaW5nXG4gIGNhbm9uaWNhbFVybDogVVJMIHwgdW5kZWZpbmVkXG4gIGNvdWxkQmVJbnRlcmNlcHRlZDogYm9vbGVhblxuICBwcmVyZW5kZXJlZDogYm9vbGVhblxuICBwb3N0cG9uZWQ6IGJvb2xlYW5cbiAgc3RhbGVUaW1lOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgUmVxdWVzdEhlYWRlcnMgPSB7XG4gIFtSU0NfSEVBREVSXT86ICcxJ1xuICBbTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVJdPzogc3RyaW5nXG4gIFtORVhUX1VSTF0/OiBzdHJpbmdcbiAgW05FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUl0/OiAnMScgfCAnMidcbiAgW05FWFRfUk9VVEVSX1NFR01FTlRfUFJFRkVUQ0hfSEVBREVSXT86IHN0cmluZ1xuICAneC1kZXBsb3ltZW50LWlkJz86IHN0cmluZ1xuICBbTkVYVF9ITVJfUkVGUkVTSF9IRUFERVJdPzogJzEnXG4gIC8vIEEgaGVhZGVyIHRoYXQgaXMgb25seSBhZGRlZCBpbiB0ZXN0IG1vZGUgdG8gYXNzZXJ0IG9uIGZldGNoIHByaW9yaXR5XG4gICdOZXh0LVRlc3QtRmV0Y2gtUHJpb3JpdHknPzogUmVxdWVzdEluaXRbJ3ByaW9yaXR5J11cbn1cblxuZnVuY3Rpb24gZG9NcGFOYXZpZ2F0aW9uKHVybDogc3RyaW5nKTogRmV0Y2hTZXJ2ZXJSZXNwb25zZVJlc3VsdCB7XG4gIHJldHVybiB7XG4gICAgZmxpZ2h0RGF0YTogdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKFxuICAgICAgbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbilcbiAgICApLnRvU3RyaW5nKCksXG4gICAgY2Fub25pY2FsVXJsOiB1bmRlZmluZWQsXG4gICAgY291bGRCZUludGVyY2VwdGVkOiBmYWxzZSxcbiAgICBwcmVyZW5kZXJlZDogZmFsc2UsXG4gICAgcG9zdHBvbmVkOiBmYWxzZSxcbiAgICBzdGFsZVRpbWU6IC0xLFxuICB9XG59XG5cbmxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEFib3J0IGFueSBpbi1mbGlnaHQgcmVxdWVzdHMgd2hlbiB0aGUgcGFnZSBpcyB1bmxvYWRlZCwgZS5nLiBkdWUgdG9cbiAgLy8gcmVsb2FkaW5nIHRoZSBwYWdlIG9yIHBlcmZvcm1pbmcgaGFyZCBuYXZpZ2F0aW9ucy4gVGhpcyBhbGxvd3MgdXMgdG8gaWdub3JlXG4gIC8vIHdoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGEgdGhyb3duIFR5cGVFcnJvciB3aGVuIHRoZSBicm93c2VyIGNhbmNlbHMgdGhlXG4gIC8vIHJlcXVlc3RzLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCAoKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyLmFib3J0KClcbiAgfSlcblxuICAvLyBVc2UgYSBmcmVzaCBBYm9ydENvbnRyb2xsZXIgaW5zdGFuY2Ugb24gcGFnZXNob3csIGUuZy4gd2hlbiBuYXZpZ2F0aW5nIGJhY2tcbiAgLy8gYW5kIHRoZSBKYXZhU2NyaXB0IGV4ZWN1dGlvbiBjb250ZXh0IGlzIHJlc3RvcmVkIGJ5IHRoZSBicm93c2VyLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCAoKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG4gIH0pXG59XG5cbi8qKlxuICogRmV0Y2ggdGhlIGZsaWdodCBkYXRhIGZvciB0aGUgcHJvdmlkZWQgdXJsLiBUYWtlcyBpbiB0aGUgY3VycmVudCByb3V0ZXIgc3RhdGVcbiAqIHRvIGRlY2lkZSB3aGF0IHRvIHJlbmRlciBzZXJ2ZXItc2lkZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoU2VydmVyUmVzcG9uc2UoXG4gIHVybDogVVJMLFxuICBvcHRpb25zOiBGZXRjaFNlcnZlclJlc3BvbnNlT3B0aW9uc1xuKTogUHJvbWlzZTxGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0PiB7XG4gIGNvbnN0IHsgZmxpZ2h0Um91dGVyU3RhdGUsIG5leHRVcmwsIHByZWZldGNoS2luZCB9ID0gb3B0aW9uc1xuXG4gIGNvbnN0IGhlYWRlcnM6IFJlcXVlc3RIZWFkZXJzID0ge1xuICAgIC8vIEVuYWJsZSBmbGlnaHQgcmVzcG9uc2VcbiAgICBbUlNDX0hFQURFUl06ICcxJyxcbiAgICAvLyBQcm92aWRlIHRoZSBjdXJyZW50IHJvdXRlciBzdGF0ZVxuICAgIFtORVhUX1JPVVRFUl9TVEFURV9UUkVFX0hFQURFUl06IHByZXBhcmVGbGlnaHRSb3V0ZXJTdGF0ZUZvclJlcXVlc3QoXG4gICAgICBmbGlnaHRSb3V0ZXJTdGF0ZSxcbiAgICAgIG9wdGlvbnMuaXNIbXJSZWZyZXNoXG4gICAgKSxcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJlZSBjYXNlczpcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgdW5kZWZpbmVkYCwgaXQgbWVhbnMgaXQncyBhIG5vcm1hbCBuYXZpZ2F0aW9uLCBzbyB3ZSB3YW50IHRvIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgZnVsbHlcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgZnVsbGAgLSB3ZSB3YW50IHRvIHByZWZldGNoIHRoZSB3aG9sZSBwYWdlIHNvIHNhbWUgYXMgYWJvdmVcbiAgICogLSBgcHJlZmV0Y2hLaW5kYCBpcyBgYXV0b2AgLSBpZiB0aGUgcGFnZSBpcyBkeW5hbWljLCBwcmVmZXRjaCB0aGUgcGFnZSBkYXRhIHBhcnRpYWxseSwgaWYgc3RhdGljIHByZWZldGNoIHRoZSBwYWdlIGRhdGEgZnVsbHlcbiAgICovXG4gIGlmIChwcmVmZXRjaEtpbmQgPT09IFByZWZldGNoS2luZC5BVVRPKSB7XG4gICAgaGVhZGVyc1tORVhUX1JPVVRFUl9QUkVGRVRDSF9IRUFERVJdID0gJzEnXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgb3B0aW9ucy5pc0htclJlZnJlc2gpIHtcbiAgICBoZWFkZXJzW05FWFRfSE1SX1JFRlJFU0hfSEVBREVSXSA9ICcxJ1xuICB9XG5cbiAgaWYgKG5leHRVcmwpIHtcbiAgICBoZWFkZXJzW05FWFRfVVJMXSA9IG5leHRVcmxcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gV2hlbiBjcmVhdGluZyBhIFwidGVtcG9yYXJ5XCIgcHJlZmV0Y2ggKHRoZSBcIm9uLWRlbWFuZFwiIHByZWZldGNoIHRoYXQgZ2V0cyBjcmVhdGVkIG9uIG5hdmlnYXRpb24sIGlmIG9uZSBkb2Vzbid0IGV4aXN0KVxuICAgIC8vIHdlIHNlbmQgdGhlIHJlcXVlc3Qgd2l0aCBhIFwiaGlnaFwiIHByaW9yaXR5IGFzIGl0J3MgaW4gcmVzcG9uc2UgdG8gYSB1c2VyIGludGVyYWN0aW9uIHRoYXQgY291bGQgYmUgYmxvY2tpbmcgYSB0cmFuc2l0aW9uLlxuICAgIC8vIE90aGVyd2lzZSwgYWxsIG90aGVyIHByZWZldGNoZXMgYXJlIHNlbnQgd2l0aCBhIFwibG93XCIgcHJpb3JpdHkuXG4gICAgLy8gV2UgdXNlIFwiYXV0b1wiIGZvciBpbiBhbGwgb3RoZXIgY2FzZXMgdG8gbWF0Y2ggdGhlIGV4aXN0aW5nIGRlZmF1bHQsIGFzIHRoaXMgZnVuY3Rpb24gaXMgc2hhcmVkIG91dHNpZGUgb2YgcHJlZmV0Y2hpbmcuXG4gICAgY29uc3QgZmV0Y2hQcmlvcml0eSA9IHByZWZldGNoS2luZFxuICAgICAgPyBwcmVmZXRjaEtpbmQgPT09IFByZWZldGNoS2luZC5URU1QT1JBUllcbiAgICAgICAgPyAnaGlnaCdcbiAgICAgICAgOiAnbG93J1xuICAgICAgOiAnYXV0bydcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIC8vIEluIFwib3V0cHV0OiBleHBvcnRcIiBtb2RlLCB3ZSBjYW4ndCByZWx5IG9uIGhlYWRlcnMgdG8gZGlzdGluZ3Vpc2hcbiAgICAgICAgLy8gYmV0d2VlbiBIVE1MIGFuZCBSU0MgcmVxdWVzdHMuIEluc3RlYWQsIHdlIGFwcGVuZCBhbiBleHRyYSBwcmVmaXhcbiAgICAgICAgLy8gdG8gdGhlIHJlcXVlc3QuXG4gICAgICAgIHVybCA9IG5ldyBVUkwodXJsKVxuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICB1cmwucGF0aG5hbWUgKz0gJ2luZGV4LnR4dCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwucGF0aG5hbWUgKz0gJy50eHQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBjcmVhdGVGZXRjaChcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBmZXRjaFByaW9yaXR5LFxuICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIClcblxuICAgIGNvbnN0IHJlc3BvbnNlVXJsID0gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKG5ldyBVUkwocmVzLnVybCkpXG4gICAgY29uc3QgY2Fub25pY2FsVXJsID0gcmVzLnJlZGlyZWN0ZWQgPyByZXNwb25zZVVybCA6IHVuZGVmaW5lZFxuXG4gICAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpIHx8ICcnXG4gICAgY29uc3QgaW50ZXJjZXB0aW9uID0gISFyZXMuaGVhZGVycy5nZXQoJ3ZhcnknKT8uaW5jbHVkZXMoTkVYVF9VUkwpXG4gICAgY29uc3QgcG9zdHBvbmVkID0gISFyZXMuaGVhZGVycy5nZXQoTkVYVF9ESURfUE9TVFBPTkVfSEVBREVSKVxuICAgIGNvbnN0IHN0YWxlVGltZUhlYWRlclNlY29uZHMgPSByZXMuaGVhZGVycy5nZXQoXG4gICAgICBORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUlxuICAgIClcbiAgICBjb25zdCBzdGFsZVRpbWUgPVxuICAgICAgc3RhbGVUaW1lSGVhZGVyU2Vjb25kcyAhPT0gbnVsbFxuICAgICAgICA/IHBhcnNlSW50KHN0YWxlVGltZUhlYWRlclNlY29uZHMsIDEwKSAqIDEwMDBcbiAgICAgICAgOiAtMVxuICAgIGxldCBpc0ZsaWdodFJlc3BvbnNlID0gY29udGVudFR5cGUuc3RhcnRzV2l0aChSU0NfQ09OVEVOVF9UWVBFX0hFQURFUilcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIGlmICghaXNGbGlnaHRSZXNwb25zZSkge1xuICAgICAgICAgIGlzRmxpZ2h0UmVzcG9uc2UgPSBjb250ZW50VHlwZS5zdGFydHNXaXRoKCd0ZXh0L3BsYWluJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGZldGNoIHJldHVybnMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIGZsaWdodCByZXNwb25zZSBoYW5kbGUgaXQgbGlrZSBhIG1wYSBuYXZpZ2F0aW9uXG4gICAgLy8gSWYgdGhlIGZldGNoIHdhcyBub3QgMjAwLCB3ZSBhbHNvIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UgfHwgIXJlcy5vayB8fCAhcmVzLmJvZHkpIHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9yaWdpbmFsIFVSTCBjYW1lIHdpdGggYSBoYXNoLCBwcmVzZXJ2ZSBpdCBiZWZvcmUgcmVkaXJlY3RpbmcgdG8gdGhlIG5ldyBVUkxcbiAgICAgIGlmICh1cmwuaGFzaCkge1xuICAgICAgICByZXNwb25zZVVybC5oYXNoID0gdXJsLmhhc2hcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvTXBhTmF2aWdhdGlvbihyZXNwb25zZVVybC50b1N0cmluZygpKVxuICAgIH1cblxuICAgIC8vIFdlIG1heSBuYXZpZ2F0ZSB0byBhIHBhZ2UgdGhhdCByZXF1aXJlcyBhIGRpZmZlcmVudCBXZWJwYWNrIHJ1bnRpbWUuXG4gICAgLy8gSW4gcHJvZCwgZXZlcnkgcGFnZSB3aWxsIGhhdmUgdGhlIHNhbWUgV2VicGFjayBydW50aW1lLlxuICAgIC8vIEluIGRldiwgdGhlIFdlYnBhY2sgcnVudGltZSBpcyBtaW5pbWFsIGZvciBlYWNoIHBhZ2UuXG4gICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhlIFdlYnBhY2sgcnVudGltZSBpcyB1cGRhdGVkIGJlZm9yZSBleGVjdXRpbmcgY2xpZW50LXNpZGUgSlMgb2YgdGhlIG5ldyBwYWdlLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFwcm9jZXNzLmVudi5UVVJCT1BBQ0spIHtcbiAgICAgIGF3YWl0IChcbiAgICAgICAgcmVxdWlyZSgnLi4vLi4vZGV2L2hvdC1yZWxvYWRlci9hcHAvaG90LXJlbG9hZGVyLWFwcCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL2Rldi9ob3QtcmVsb2FkZXIvYXBwL2hvdC1yZWxvYWRlci1hcHAnKVxuICAgICAgKS53YWl0Rm9yV2VicGFja1J1bnRpbWVIb3RVcGRhdGUoKVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgYGZldGNoYCByZWFkYWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdW53cmFwcGVkIGJ5IGBSZWFjdC51c2VgLlxuICAgIGNvbnN0IGZsaWdodFN0cmVhbSA9IHBvc3Rwb25lZFxuICAgICAgPyBjcmVhdGVVbmNsb3NpbmdQcmVmZXRjaFN0cmVhbShyZXMuYm9keSlcbiAgICAgIDogcmVzLmJvZHlcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IChjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtKFxuICAgICAgZmxpZ2h0U3RyZWFtXG4gICAgKSBhcyBQcm9taXNlPE5hdmlnYXRpb25GbGlnaHRSZXNwb25zZT4pXG5cbiAgICBpZiAoZ2V0QXBwQnVpbGRJZCgpICE9PSByZXNwb25zZS5iKSB7XG4gICAgICByZXR1cm4gZG9NcGFOYXZpZ2F0aW9uKHJlcy51cmwpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZsaWdodERhdGE6IG5vcm1hbGl6ZUZsaWdodERhdGEocmVzcG9uc2UuZiksXG4gICAgICBjYW5vbmljYWxVcmw6IGNhbm9uaWNhbFVybCxcbiAgICAgIGNvdWxkQmVJbnRlcmNlcHRlZDogaW50ZXJjZXB0aW9uLFxuICAgICAgcHJlcmVuZGVyZWQ6IHJlc3BvbnNlLlMsXG4gICAgICBwb3N0cG9uZWQsXG4gICAgICBzdGFsZVRpbWUsXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIWFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBmZXRjaCBSU0MgcGF5bG9hZCBmb3IgJHt1cmx9LiBGYWxsaW5nIGJhY2sgdG8gYnJvd3NlciBuYXZpZ2F0aW9uLmAsXG4gICAgICAgIGVyclxuICAgICAgKVxuICAgIH1cblxuICAgIC8vIElmIGZldGNoIGZhaWxzIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAvLyBUT0RPLUFQUDogQWRkIGEgdGVzdCBmb3IgdGhlIGNhc2Ugd2hlcmUgYSBDT1JTIHJlcXVlc3QgZmFpbHMsIGUuZy4gZXh0ZXJuYWwgdXJsIHJlZGlyZWN0IGNvbWluZyBmcm9tIHRoZSByZXNwb25zZS5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy80MzYwNSNpc3N1ZWNvbW1lbnQtMTQ1MTYxNzUyMSBmb3IgYSByZXByb2R1Y3Rpb24uXG4gICAgcmV0dXJuIHtcbiAgICAgIGZsaWdodERhdGE6IHVybC50b1N0cmluZygpLFxuICAgICAgY2Fub25pY2FsVXJsOiB1bmRlZmluZWQsXG4gICAgICBjb3VsZEJlSW50ZXJjZXB0ZWQ6IGZhbHNlLFxuICAgICAgcHJlcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgcG9zdHBvbmVkOiBmYWxzZSxcbiAgICAgIHN0YWxlVGltZTogLTEsXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBzdWJzZXQgb2YgdGhlIHN0YW5kYXJkIFJlc3BvbnNlIHR5cGUuIFdlIHVzZSBhIGN1c3RvbSB0eXBlIGZvclxuLy8gdGhpcyBzbyB3ZSBjYW4gbGltaXQgd2hpY2ggZGV0YWlscyBhYm91dCB0aGUgcmVzcG9uc2UgbGVhayBpbnRvIHRoZSByZXN0IG9mXG4vLyB0aGUgY29kZWJhc2UuIEZvciBleGFtcGxlLCB0aGVyZSdzIHNvbWUgY3VzdG9tIGxvZ2ljIGZvciBtYW51YWxseSBmb2xsb3dpbmdcbi8vIHJlZGlyZWN0cywgc28gXCJyZWRpcmVjdGVkXCIgaW4gdGhpcyB0eXBlIGNvdWxkIGJlIGEgY29tcG9zaXRlIG9mIG11bHRpcGxlXG4vLyBicm93c2VyIGZldGNoIGNhbGxzOyBob3dldmVyLCB0aGlzIGZhY3Qgc2hvdWxkIG5vdCBsZWFrIHRvIHRoZSBjYWxsZXIuXG5leHBvcnQgdHlwZSBSU0NSZXNwb25zZSA9IHtcbiAgb2s6IGJvb2xlYW5cbiAgcmVkaXJlY3RlZDogYm9vbGVhblxuICBoZWFkZXJzOiBIZWFkZXJzXG4gIGJvZHk6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHwgbnVsbFxuICBzdGF0dXM6IG51bWJlclxuICB1cmw6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRmV0Y2goXG4gIHVybDogVVJMLFxuICBoZWFkZXJzOiBSZXF1ZXN0SGVhZGVycyxcbiAgZmV0Y2hQcmlvcml0eTogJ2F1dG8nIHwgJ2hpZ2gnIHwgJ2xvdycgfCBudWxsLFxuICBzaWduYWw/OiBBYm9ydFNpZ25hbFxuKTogUHJvbWlzZTxSU0NSZXNwb25zZT4ge1xuICAvLyBUT0RPOiBJbiBvdXRwdXQ6IFwiZXhwb3J0XCIgbW9kZSwgdGhlIGhlYWRlcnMgZG8gbm90aGluZy4gT21pdCB0aGVtIChhbmQgdGhlXG4gIC8vIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtKSBmcm9tIHRoZSByZXF1ZXN0IHNvIHRoZXkncmVcbiAgLy8gbWF4aW1hbGx5IGNhY2hlYWJsZS5cblxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RFU1RfTU9ERSAmJiBmZXRjaFByaW9yaXR5ICE9PSBudWxsKSB7XG4gICAgaGVhZGVyc1snTmV4dC1UZXN0LUZldGNoLVByaW9yaXR5J10gPSBmZXRjaFByaW9yaXR5XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEKSB7XG4gICAgaGVhZGVyc1sneC1kZXBsb3ltZW50LWlkJ10gPSBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgfVxuXG4gIGNvbnN0IGZldGNoT3B0aW9uczogUmVxdWVzdEluaXQgPSB7XG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3Igb2xkZXIgYnJvd3NlcnMuIGBzYW1lLW9yaWdpbmAgaXMgdGhlIGRlZmF1bHQgaW4gbW9kZXJuIGJyb3dzZXJzLlxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgIGhlYWRlcnMsXG4gICAgcHJpb3JpdHk6IGZldGNoUHJpb3JpdHkgfHwgdW5kZWZpbmVkLFxuICAgIHNpZ25hbCxcbiAgfVxuICAvLyBgZmV0Y2hVcmxgIGlzIHNsaWdodGx5IGRpZmZlcmVudCBmcm9tIGB1cmxgIGJlY2F1c2Ugd2UgYWRkIGEgY2FjaGUtYnVzdGluZ1xuICAvLyBzZWFyY2ggcGFyYW0gdG8gaXQuIFRoaXMgc2hvdWxkIG5vdCBsZWFrIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiwgc28gd2VcbiAgLy8gdHJhY2sgdGhlbSBzZXBhcmF0ZWx5LlxuICBsZXQgZmV0Y2hVcmwgPSBuZXcgVVJMKHVybClcbiAgc2V0Q2FjaGVCdXN0aW5nU2VhcmNoUGFyYW0oZmV0Y2hVcmwsIGhlYWRlcnMpXG4gIGxldCBicm93c2VyUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwgZmV0Y2hPcHRpb25zKVxuXG4gIC8vIElmIHRoZSBzZXJ2ZXIgcmVzcG9uZHMgd2l0aCBhIHJlZGlyZWN0IChlLmcuIDMwNyksIGFuZCB0aGUgcmVkaXJlY3RlZFxuICAvLyBsb2NhdGlvbiBkb2VzIG5vdCBjb250YWluIHRoZSBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbSBzZXQgaW4gdGhlXG4gIC8vIG9yaWdpbmFsIHJlcXVlc3QsIHRoZSByZXNwb25zZSBpcyBsaWtlbHkgaW52YWxpZCDigJQgd2hlbiBmb2xsb3dpbmcgdGhlXG4gIC8vIHJlZGlyZWN0LCB0aGUgYnJvd3NlciBmb3J3YXJkcyB0aGUgcmVxdWVzdCBoZWFkZXJzLCBidXQgc2luY2UgdGhlIGNhY2hlXG4gIC8vIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtIGlzIG1pc3NpbmcsIHRoZSBzZXJ2ZXIgd2lsbCByZWplY3QgdGhlIHJlcXVlc3QgZHVlIHRvXG4gIC8vIGEgbWlzbWF0Y2guXG4gIC8vXG4gIC8vIElkZWFsbHksIHdlIHdvdWxkIGJlIGFibGUgdG8gaW50ZXJjZXB0IHRoZSByZWRpcmVjdCByZXNwb25zZSBhbmQgcGVyZm9ybSBpdFxuICAvLyBtYW51YWxseSwgaW5zdGVhZCBvZiBsZXR0aW5nIHRoZSBicm93c2VyIGF1dG9tYXRpY2FsbHkgZm9sbG93IGl0LCBidXQgdGhpc1xuICAvLyBpcyBub3QgYWxsb3dlZCBieSB0aGUgZmV0Y2ggQVBJLlxuICAvL1xuICAvLyBTbyBpbnN0ZWFkLCB3ZSBtdXN0IFwicmVwbGF5XCIgdGhlIHJlZGlyZWN0IGJ5IGZldGNoaW5nIHRoZSBuZXcgbG9jYXRpb25cbiAgLy8gYWdhaW4sIGJ1dCB0aGlzIHRpbWUgd2UnbGwgYXBwZW5kIHRoZSBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbSB0byBwcmV2ZW50XG4gIC8vIGEgbWlzbWF0Y2guXG4gIC8vXG4gIC8vIFRPRE86IFdlIGNhbiBvcHRpbWl6ZSBOZXh0LmpzJ3MgYnVpbHQtaW4gbWlkZGxld2FyZSBBUElzIGJ5IHJldHVybmluZyBhXG4gIC8vIGN1c3RvbSBzdGF0dXMgY29kZSwgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGF1dG9tYXRpY2FsbHkgZm9sbG93aW5nIGl0LlxuICAvL1xuICAvLyBUaGlzIGRvZXMgbm90IGFmZmVjdCBTZXJ2ZXIgQWN0aW9uLWJhc2VkIHJlZGlyZWN0czsgdGhvc2UgYXJlIGVuY29kZWRcbiAgLy8gZGlmZmVyZW50bHksIGFzIHBhcnQgb2YgdGhlIEZsaWdodCBib2R5LiBJdCBvbmx5IGFmZmVjdHMgcmVkaXJlY3RzIHRoYXRcbiAgLy8gb2NjdXIgaW4gYSBtaWRkbGV3YXJlIG9yIGEgdGhpcmQtcGFydHkgcHJveHkuXG5cbiAgbGV0IHJlZGlyZWN0ZWQgPSBicm93c2VyUmVzcG9uc2UucmVkaXJlY3RlZFxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9WQUxJREFURV9SU0NfUkVRVUVTVF9IRUFERVJTKSB7XG4gICAgLy8gVGhpcyBpcyB0byBwcmV2ZW50IGEgcmVkaXJlY3QgbG9vcC4gU2FtZSBsaW1pdCB1c2VkIGJ5IENocm9tZS5cbiAgICBjb25zdCBNQVhfUkVESVJFQ1RTID0gMjBcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IE1BWF9SRURJUkVDVFM7IG4rKykge1xuICAgICAgaWYgKCFicm93c2VyUmVzcG9uc2UucmVkaXJlY3RlZCkge1xuICAgICAgICAvLyBUaGUgc2VydmVyIGRpZCBub3QgcGVyZm9ybSBhIHJlZGlyZWN0LlxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2VVcmwgPSBuZXcgVVJMKGJyb3dzZXJSZXNwb25zZS51cmwsIGZldGNoVXJsKVxuICAgICAgaWYgKHJlc3BvbnNlVXJsLm9yaWdpbiAhPT0gZmV0Y2hVcmwub3JpZ2luKSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgcmVkaXJlY3RlZCB0byBhbiBleHRlcm5hbCBVUkwuIFRoZSByZXN0IG9mIHRoZSBsb2dpYyBiZWxvd1xuICAgICAgICAvLyBpcyBub3QgcmVsZXZhbnQsIGJlY2F1c2UgaXQgb25seSBhcHBsaWVzIHRvIGludGVybmFsIHJlZGlyZWN0cy5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgcmVzcG9uc2VVcmwuc2VhcmNoUGFyYW1zLmdldChORVhUX1JTQ19VTklPTl9RVUVSWSkgPT09XG4gICAgICAgIGZldGNoVXJsLnNlYXJjaFBhcmFtcy5nZXQoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG4gICAgICApIHtcbiAgICAgICAgLy8gVGhlIHJlZGlyZWN0ZWQgVVJMIGFscmVhZHkgaW5jbHVkZXMgdGhlIGNhY2hlIGJ1c3Rpbmcgc2VhcmNoIHBhcmFtLlxuICAgICAgICAvLyBUaGlzIHdhcyBwcm9iYWJseSBpbnRlbnRpb25hbC4gUmVnYXJkbGVzcywgdGhlcmUncyBubyByZWFzb24gdG9cbiAgICAgICAgLy8gaXNzdWUgYW5vdGhlciByZXF1ZXN0IHRvIHRoaXMgVVJMIGJlY2F1c2UgaXQgYWxyZWFkeSBoYXMgdGhlIHBhcmFtXG4gICAgICAgIC8vIHZhbHVlIHRoYXQgd2Ugd291bGQgaGF2ZSBhZGRlZCBiZWxvdy5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBSU0MgcmVxdWVzdCB3YXMgcmVkaXJlY3RlZC4gQXNzdW1lIHRoZSByZXNwb25zZSBpcyBpbnZhbGlkLlxuICAgICAgLy9cbiAgICAgIC8vIEFwcGVuZCB0aGUgY2FjaGUgYnVzdGluZyBzZWFyY2ggcGFyYW0gdG8gdGhlIHJlZGlyZWN0ZWQgVVJMIGFuZFxuICAgICAgLy8gZmV0Y2ggYWdhaW4uXG4gICAgICBmZXRjaFVybCA9IG5ldyBVUkwocmVzcG9uc2VVcmwpXG4gICAgICBzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbShmZXRjaFVybCwgaGVhZGVycylcbiAgICAgIGJyb3dzZXJSZXNwb25zZSA9IGF3YWl0IGZldGNoKGZldGNoVXJsLCBmZXRjaE9wdGlvbnMpXG4gICAgICAvLyBXZSBqdXN0IHBlcmZvcm1lZCBhIG1hbnVhbCByZWRpcmVjdCwgc28gdGhpcyBpcyBub3cgdHJ1ZS5cbiAgICAgIHJlZGlyZWN0ZWQgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHRoZSBjYWNoZSBidXN0aW5nIHNlYXJjaCBwYXJhbSBmcm9tIHRoZSByZXNwb25zZSBVUkwsIHRvIHByZXZlbnQgaXRcbiAgLy8gZnJvbSBsZWFraW5nIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbiAgY29uc3QgcmVzcG9uc2VVcmwgPSBuZXcgVVJMKGJyb3dzZXJSZXNwb25zZS51cmwsIGZldGNoVXJsKVxuICByZXNwb25zZVVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKE5FWFRfUlNDX1VOSU9OX1FVRVJZKVxuXG4gIGNvbnN0IHJzY1Jlc3BvbnNlOiBSU0NSZXNwb25zZSA9IHtcbiAgICB1cmw6IHJlc3BvbnNlVXJsLmhyZWYsXG5cbiAgICAvLyBUaGlzIGlzIHRydWUgaWYgYW55IHJlZGlyZWN0cyBvY2N1cnJlZCwgZWl0aGVyIGF1dG9tYXRpY2FsbHkgYnkgdGhlXG4gICAgLy8gYnJvd3Nlciwgb3IgbWFudWFsbHkgYnkgdXMuIFNvIGl0J3MgZGlmZmVyZW50IGZyb21cbiAgICAvLyBgYnJvd3NlclJlc3BvbnNlLnJlZGlyZWN0ZWRgLCB3aGljaCBvbmx5IHRlbGxzIHVzIHdoZXRoZXIgdGhlIGJyb3dzZXJcbiAgICAvLyBmb2xsb3dlZCBhIHJlZGlyZWN0LCBhbmQgb25seSBmb3IgdGhlIGxhc3QgcmVzcG9uc2UgaW4gdGhlIGNoYWluLlxuICAgIHJlZGlyZWN0ZWQsXG5cbiAgICAvLyBUaGVzZSBjYW4gYmUgY29waWVkIGZyb20gdGhlIGxhc3QgYnJvd3NlciByZXNwb25zZSB3ZSByZWNlaXZlZC4gV2VcbiAgICAvLyBpbnRlbnRpb25hbGx5IG9ubHkgZXhwb3NlIHRoZSBzdWJzZXQgb2YgZmllbGRzIHRoYXQgYXJlIGFjdHVhbGx5IHVzZWRcbiAgICAvLyBlbHNld2hlcmUgaW4gdGhlIGNvZGViYXNlLlxuICAgIG9rOiBicm93c2VyUmVzcG9uc2Uub2ssXG4gICAgaGVhZGVyczogYnJvd3NlclJlc3BvbnNlLmhlYWRlcnMsXG4gICAgYm9keTogYnJvd3NlclJlc3BvbnNlLmJvZHksXG4gICAgc3RhdHVzOiBicm93c2VyUmVzcG9uc2Uuc3RhdHVzLFxuICB9XG5cbiAgcmV0dXJuIHJzY1Jlc3BvbnNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtKFxuICBmbGlnaHRTdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgcmV0dXJuIGNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbShmbGlnaHRTdHJlYW0sIHtcbiAgICBjYWxsU2VydmVyLFxuICAgIGZpbmRTb3VyY2VNYXBVUkwsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuY2xvc2luZ1ByZWZldGNoU3RyZWFtKFxuICBvcmlnaW5hbEZsaWdodFN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbik6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+IHtcbiAgLy8gV2hlbiBQUFIgaXMgZW5hYmxlZCwgcHJlZmV0Y2ggc3RyZWFtcyBtYXkgY29udGFpbiByZWZlcmVuY2VzIHRoYXQgbmV2ZXJcbiAgLy8gcmVzb2x2ZSwgYmVjYXVzZSB0aGF0J3MgaG93IHdlIGVuY29kZSBkeW5hbWljIGRhdGEgYWNjZXNzLiBJbiB0aGUgZGVjb2RlZFxuICAvLyBvYmplY3QgcmV0dXJuZWQgYnkgdGhlIEZsaWdodCBjbGllbnQsIHRoZXNlIGFyZSByZWlmaWVkIGludG8gaGFuZ2luZ1xuICAvLyBwcm9taXNlcyB0aGF0IHN1c3BlbmQgZHVyaW5nIHJlbmRlciwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgd2hhdCB3ZSB3YW50LlxuICAvLyBUaGUgVUkgcmVzb2x2ZXMgd2hlbiBpdCBzd2l0Y2hlcyB0byB0aGUgZHluYW1pYyBkYXRhIHN0cmVhbVxuICAvLyAodmlhIHVzZURlZmVycmVkVmFsdWUoZHluYW1pYywgc3RhdGljKSkuXG4gIC8vXG4gIC8vIEhvd2V2ZXIsIHRoZSBGbGlnaHQgaW1wbGVtZW50YXRpb24gY3VycmVudGx5IGVycm9ycyBpZiB0aGUgc2VydmVyIGNsb3Nlc1xuICAvLyB0aGUgcmVzcG9uc2UgYmVmb3JlIGFsbCB0aGUgcmVmZXJlbmNlcyBhcmUgcmVzb2x2ZWQuIEFzIGEgY2hlYXQgdG8gd29ya1xuICAvLyBhcm91bmQgdGhpcywgd2Ugd3JhcCB0aGUgb3JpZ2luYWwgc3RyZWFtIGluIGEgbmV3IHN0cmVhbSB0aGF0IG5ldmVyIGNsb3NlcyxcbiAgLy8gYW5kIHRoZXJlZm9yZSBkb2Vzbid0IGVycm9yLlxuICBjb25zdCByZWFkZXIgPSBvcmlnaW5hbEZsaWdodFN0cmVhbS5nZXRSZWFkZXIoKVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgLy8gUGFzcyB0byB0aGUgdGFyZ2V0IHN0cmVhbSBhbmQga2VlcCBjb25zdW1pbmcgdGhlIEZsaWdodCByZXNwb25zZVxuICAgICAgICAgIC8vIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgc2VydmVyIHN0cmVhbSBoYXMgY2xvc2VkLiBFeGl0LCBidXQgaW50ZW50aW9uYWxseSBkbyBub3QgY2xvc2VcbiAgICAgICAgLy8gdGhlIHRhcmdldCBzdHJlYW0uXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0sXG4gIH0pXG59XG4iXSwibmFtZXMiOlsiY3JlYXRlRmV0Y2giLCJjcmVhdGVGcm9tTmV4dFJlYWRhYmxlU3RyZWFtIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbSIsImNyZWF0ZUZyb21SZWFkYWJsZVN0cmVhbUJyb3dzZXIiLCJkb01wYU5hdmlnYXRpb24iLCJ1cmwiLCJmbGlnaHREYXRhIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwiVVJMIiwibG9jYXRpb24iLCJvcmlnaW4iLCJ0b1N0cmluZyIsImNhbm9uaWNhbFVybCIsInVuZGVmaW5lZCIsImNvdWxkQmVJbnRlcmNlcHRlZCIsInByZXJlbmRlcmVkIiwicG9zdHBvbmVkIiwic3RhbGVUaW1lIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0Iiwib3B0aW9ucyIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsInByZWZldGNoS2luZCIsImhlYWRlcnMiLCJSU0NfSEVBREVSIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRV9IRUFERVIiLCJwcmVwYXJlRmxpZ2h0Um91dGVyU3RhdGVGb3JSZXF1ZXN0IiwiaXNIbXJSZWZyZXNoIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIk5FWFRfUk9VVEVSX1BSRUZFVENIX0hFQURFUiIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIk5FWFRfSE1SX1JFRlJFU0hfSEVBREVSIiwiTkVYVF9VUkwiLCJyZXMiLCJmZXRjaFByaW9yaXR5IiwiVEVNUE9SQVJZIiwiX19ORVhUX0NPTkZJR19PVVRQVVQiLCJwYXRobmFtZSIsImVuZHNXaXRoIiwic2lnbmFsIiwicmVzcG9uc2VVcmwiLCJyZWRpcmVjdGVkIiwiY29udGVudFR5cGUiLCJnZXQiLCJpbnRlcmNlcHRpb24iLCJpbmNsdWRlcyIsIk5FWFRfRElEX1BPU1RQT05FX0hFQURFUiIsInN0YWxlVGltZUhlYWRlclNlY29uZHMiLCJORVhUX1JPVVRFUl9TVEFMRV9USU1FX0hFQURFUiIsInBhcnNlSW50IiwiaXNGbGlnaHRSZXNwb25zZSIsInN0YXJ0c1dpdGgiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIm9rIiwiYm9keSIsImhhc2giLCJUVVJCT1BBQ0siLCJyZXF1aXJlIiwid2FpdEZvcldlYnBhY2tSdW50aW1lSG90VXBkYXRlIiwiZmxpZ2h0U3RyZWFtIiwiY3JlYXRlVW5jbG9zaW5nUHJlZmV0Y2hTdHJlYW0iLCJyZXNwb25zZSIsImdldEFwcEJ1aWxkSWQiLCJiIiwibm9ybWFsaXplRmxpZ2h0RGF0YSIsImYiLCJTIiwiZXJyIiwiYWJvcnRlZCIsImNvbnNvbGUiLCJlcnJvciIsIl9fTkVYVF9URVNUX01PREUiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJmZXRjaE9wdGlvbnMiLCJjcmVkZW50aWFscyIsInByaW9yaXR5IiwiZmV0Y2hVcmwiLCJzZXRDYWNoZUJ1c3RpbmdTZWFyY2hQYXJhbSIsImJyb3dzZXJSZXNwb25zZSIsImZldGNoIiwiX19ORVhUX0NMSUVOVF9WQUxJREFURV9SU0NfUkVRVUVTVF9IRUFERVJTIiwiTUFYX1JFRElSRUNUUyIsIm4iLCJzZWFyY2hQYXJhbXMiLCJORVhUX1JTQ19VTklPTl9RVUVSWSIsImRlbGV0ZSIsInJzY1Jlc3BvbnNlIiwiaHJlZiIsInN0YXR1cyIsImNhbGxTZXJ2ZXIiLCJmaW5kU291cmNlTWFwVVJMIiwib3JpZ2luYWxGbGlnaHRTdHJlYW0iLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbSIsInB1bGwiLCJjb250cm9sbGVyIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImVucXVldWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DYNAMIC_STALETIME_MS: function() {\n        return DYNAMIC_STALETIME_MS;\n    },\n    STATIC_STALETIME_MS: function() {\n        return STATIC_STALETIME_MS;\n    },\n    createSeededPrefetchCacheEntry: function() {\n        return createSeededPrefetchCacheEntry;\n    },\n    getOrCreatePrefetchCacheEntry: function() {\n        return getOrCreatePrefetchCacheEntry;\n    },\n    prunePrefetchCache: function() {\n        return prunePrefetchCache;\n    }\n});\nconst _fetchserverresponse = __webpack_require__(/*! ./fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst _prefetchreducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\nconst INTERCEPTION_CACHE_KEY_MARKER = '%';\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */ function createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {\n    // Initially we only use the pathname as the cache key. We don't want to include\n    // search params so that multiple URLs with the same search parameter can re-use\n    // loading states.\n    let pathnameFromUrl = url.pathname;\n    // RSC responses can differ based on search params, specifically in the case where we aren't\n    // returning a partial response (ie with `PrefetchKind.AUTO`).\n    // In the auto case, since loading.js & layout.js won't have access to search params,\n    // we can safely re-use that cache entry. But for full prefetches, we should not\n    // re-use the cache entry as the response may differ.\n    if (includeSearchParams) {\n        // if we have a full prefetch, we can include the search param in the key,\n        // as we'll be getting back a full response. The server might have read the search\n        // params when generating the full response.\n        pathnameFromUrl += url.search;\n    }\n    if (prefix) {\n        return \"\" + prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;\n    }\n    return pathnameFromUrl;\n}\nfunction createPrefetchCacheKey(url, kind, nextUrl) {\n    return createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);\n}\nfunction getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {\n    if (kind === void 0) kind = _routerreducertypes.PrefetchKind.TEMPORARY;\n    // We first check if there's a more specific interception route prefetch entry\n    // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n    // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n    for (const maybeNextUrl of [\n        nextUrl,\n        null\n    ]){\n        const cacheKeyWithParams = createPrefetchCacheKeyImpl(url, true, maybeNextUrl);\n        const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, false, maybeNextUrl);\n        // First, we check if we have a cache entry that exactly matches the URL\n        const cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;\n        const existingEntry = prefetchCache.get(cacheKeyToUse);\n        if (existingEntry && allowAliasing) {\n            // We know we're returning an aliased entry when the pathname matches but the search params don't,\n            const isAliased = existingEntry.url.pathname === url.pathname && existingEntry.url.search !== url.search;\n            if (isAliased) {\n                return {\n                    ...existingEntry,\n                    aliased: true\n                };\n            }\n            return existingEntry;\n        }\n        // If the request contains search params, and we're not doing a full prefetch, we can return the\n        // param-less entry if it exists.\n        // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n        // but lets us arrive there quicker in the param-full case.\n        const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);\n        if (false) {}\n    }\n    // If we've gotten to this point, we didn't find a specific cache entry that matched\n    // the request URL.\n    // We attempt a partial match by checking if there's a cache entry with the same pathname.\n    // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n    // This will signal to the router that it should only apply the loading state on the prefetched data.\n    if (false) {}\n    return undefined;\n}\nfunction getOrCreatePrefetchCacheEntry(param) {\n    let { url, nextUrl, tree, prefetchCache, kind, allowAliasing = true } = param;\n    const existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);\n    if (existingCacheEntry) {\n        // Grab the latest status of the cache entry and update it\n        existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);\n        // when `kind` is provided, an explicit prefetch was requested.\n        // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n        const switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL && kind === _routerreducertypes.PrefetchKind.FULL;\n        if (switchedToFullPrefetch) {\n            // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n            // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n            // are seeded but without a prefetch intent)\n            existingCacheEntry.data.then((prefetchResponse)=>{\n                const isFullPrefetch = Array.isArray(prefetchResponse.flightData) && prefetchResponse.flightData.some((flightData)=>{\n                    // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n                    return flightData.isRootRender && flightData.seedData !== null;\n                });\n                if (!isFullPrefetch) {\n                    return createLazyPrefetchEntry({\n                        tree,\n                        url,\n                        nextUrl,\n                        prefetchCache,\n                        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n                        // rather than assuming the same intent as the previous entry, to be consistent with how we\n                        // lazily create prefetch entries when intent is left unspecified.\n                        kind: kind != null ? kind : _routerreducertypes.PrefetchKind.TEMPORARY\n                    });\n                }\n            });\n        }\n        // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n        // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n        if (kind && existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {\n            existingCacheEntry.kind = kind;\n        }\n        // We've determined that the existing entry we found is still valid, so we return it.\n        return existingCacheEntry;\n    }\n    // If we didn't return an entry, create a new one.\n    return createLazyPrefetchEntry({\n        tree,\n        url,\n        nextUrl,\n        prefetchCache,\n        kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY\n    });\n}\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */ function prefixExistingPrefetchCacheEntry(param) {\n    let { url, nextUrl, prefetchCache, existingCacheKey } = param;\n    const existingCacheEntry = prefetchCache.get(existingCacheKey);\n    if (!existingCacheEntry) {\n        // no-op -- there wasn't an entry to move\n        return;\n    }\n    const newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);\n    prefetchCache.set(newCacheKey, {\n        ...existingCacheEntry,\n        key: newCacheKey\n    });\n    prefetchCache.delete(existingCacheKey);\n    return newCacheKey;\n}\nfunction createSeededPrefetchCacheEntry(param) {\n    let { nextUrl, tree, prefetchCache, url, data, kind } = param;\n    // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n    // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n    // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n    const prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data: Promise.resolve(data),\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: Date.now(),\n        staleTime: data.staleTime,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */ function createLazyPrefetchEntry(param) {\n    let { url, kind, tree, nextUrl, prefetchCache } = param;\n    const prefetchCacheKey = createPrefetchCacheKey(url, kind);\n    // initiates the fetch request for the prefetch and attaches a listener\n    // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n    const data = _prefetchreducer.prefetchQueue.enqueue(()=>(0, _fetchserverresponse.fetchServerResponse)(url, {\n            flightRouterState: tree,\n            nextUrl,\n            prefetchKind: kind\n        }).then((prefetchResponse)=>{\n            // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n            // to avoid drift between this cache key prefixing logic\n            // (which is currently directly influenced by the server response)\n            let newCacheKey;\n            if (prefetchResponse.couldBeIntercepted) {\n                // Determine if we need to prefix the cache key with the nextUrl\n                newCacheKey = prefixExistingPrefetchCacheEntry({\n                    url,\n                    existingCacheKey: prefetchCacheKey,\n                    nextUrl,\n                    prefetchCache\n                });\n            }\n            // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n            // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n            // staleTime.\n            if (prefetchResponse.prerendered) {\n                const existingCacheEntry = prefetchCache.get(newCacheKey != null ? newCacheKey : prefetchCacheKey);\n                if (existingCacheEntry) {\n                    existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;\n                    if (prefetchResponse.staleTime !== -1) {\n                        // This is the stale time that was collected by the server during\n                        // static generation. Use this in place of the default stale time.\n                        existingCacheEntry.staleTime = prefetchResponse.staleTime;\n                    }\n                }\n            }\n            return prefetchResponse;\n        }));\n    const prefetchEntry = {\n        treeAtTimeOfPrefetch: tree,\n        data,\n        kind,\n        prefetchTime: Date.now(),\n        lastUsedTime: null,\n        staleTime: -1,\n        key: prefetchCacheKey,\n        status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,\n        url\n    };\n    prefetchCache.set(prefetchCacheKey, prefetchEntry);\n    return prefetchEntry;\n}\nfunction prunePrefetchCache(prefetchCache) {\n    for (const [href, prefetchCacheEntry] of prefetchCache){\n        if (getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {\n            prefetchCache.delete(href);\n        }\n    }\n}\nconst DYNAMIC_STALETIME_MS = Number(\"0\") * 1000;\nconst STATIC_STALETIME_MS = Number(\"300\") * 1000;\nfunction getPrefetchEntryCacheStatus(param) {\n    let { kind, prefetchTime, lastUsedTime } = param;\n    // We will re-use the cache entry data for up to the `dynamic` staletime window.\n    if (Date.now() < (lastUsedTime != null ? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {\n        return lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;\n    }\n    // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n    // A stale entry will only re-use the `loading` boundary, not the full data.\n    // This will trigger a \"lazy fetch\" for the full data.\n    if (kind === _routerreducertypes.PrefetchKind.AUTO) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.stale;\n        }\n    }\n    // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n    if (kind === _routerreducertypes.PrefetchKind.FULL) {\n        if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n            return _routerreducertypes.PrefetchCacheEntryStatus.reusable;\n        }\n    }\n    return _routerreducertypes.PrefetchCacheEntryStatus.expired;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-cache-utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcHJlZmV0Y2gtY2FjaGUtdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNFlhQSxvQkFBb0I7ZUFBcEJBOztJQUdBQyxtQkFBbUI7ZUFBbkJBOztJQW5JR0MsOEJBQThCO2VBQTlCQTs7SUE5R0FDLDZCQUE2QjtlQUE3QkE7O0lBK05BQyxrQkFBa0I7ZUFBbEJBOzs7aURBMVhUO2dEQU1BOzZDQUN1QjtBQUU5QixNQUFNQyxnQ0FBZ0M7QUFVdEM7Ozs7OztDQU1DLEdBQ0QsU0FBU0MsMkJBQ1BDLEdBQVEsRUFDUkMsbUJBQTRCLEVBQzVCQyxNQUFzQjtJQUV0QixnRkFBZ0Y7SUFDaEYsZ0ZBQWdGO0lBQ2hGLGtCQUFrQjtJQUNsQixJQUFJQyxrQkFBa0JILElBQUlJLFFBQVE7SUFFbEMsNEZBQTRGO0lBQzVGLDhEQUE4RDtJQUM5RCxxRkFBcUY7SUFDckYsZ0ZBQWdGO0lBQ2hGLHFEQUFxRDtJQUNyRCxJQUFJSCxxQkFBcUI7UUFDdkIsMEVBQTBFO1FBQzFFLGtGQUFrRjtRQUNsRiw0Q0FBNEM7UUFDNUNFLG1CQUFtQkgsSUFBSUssTUFBTTtJQUMvQjtJQUVBLElBQUlILFFBQVE7UUFDVixPQUFRLEtBQUVBLFNBQVNKLGdDQUFnQ0s7SUFDckQ7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU0csdUJBQ1BOLEdBQVEsRUFDUk8sSUFBOEIsRUFDOUJDLE9BQXVCO0lBRXZCLE9BQU9ULDJCQUEyQkMsS0FBS08sU0FBU0Usb0JBQUFBLFlBQVksQ0FBQ0MsSUFBSSxFQUFFRjtBQUNyRTtBQUVBLFNBQVNHLHNCQUNQWCxHQUFRLEVBQ1JPLElBQTJDLEVBQzNDQyxPQUFzQixFQUN0QkksYUFBOEMsRUFDOUNDLGFBQXNCO0lBSHRCTixJQUFBQSxTQUFBQSxLQUFBQSxHQUFBQSxPQUFxQkUsb0JBQUFBLFlBQVksQ0FBQ0ss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RyxLQUFLRixlQUFlakUscUJBQXFCO1lBQ25ELE9BQU9zRSxvQkFBQUEsd0JBQXdCLENBQUNjLFFBQVE7UUFDMUM7SUFDRjtJQUVBLE9BQU9kLG9CQUFBQSx3QkFBd0IsQ0FBQ1UsT0FBTztBQUN6QyIsInNvdXJjZXMiOlsiL1VzZXJzL21hY21pbmkvRG9jdW1lbnRzL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9wcmVmZXRjaC1jYWNoZS11dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBmZXRjaFNlcnZlclJlc3BvbnNlLFxuICB0eXBlIEZldGNoU2VydmVyUmVzcG9uc2VSZXN1bHQsXG59IGZyb20gJy4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHtcbiAgUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLFxuICB0eXBlIFByZWZldGNoQ2FjaGVFbnRyeSxcbiAgUHJlZmV0Y2hLaW5kLFxuICB0eXBlIFJlYWRvbmx5UmVkdWNlclN0YXRlLFxufSBmcm9tICcuL3JvdXRlci1yZWR1Y2VyLXR5cGVzJ1xuaW1wb3J0IHsgcHJlZmV0Y2hRdWV1ZSB9IGZyb20gJy4vcmVkdWNlcnMvcHJlZmV0Y2gtcmVkdWNlcidcblxuY29uc3QgSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIgPSAnJSdcblxuZXhwb3J0IHR5cGUgQWxpYXNlZFByZWZldGNoQ2FjaGVFbnRyeSA9IFByZWZldGNoQ2FjaGVFbnRyeSAmIHtcbiAgLyoqIFRoaXMgaXMgYSBzcGVjaWFsIHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIGEgcHJlZmV0Y2ggZW50cnkgYXNzb2NpYXRlZCB3aXRoIGEgZGlmZmVyZW50IFVSTFxuICAgKiB3YXMgcmV0dXJuZWQgcmF0aGVyIHRoYW4gdGhlIHJlcXVlc3RlZCBVUkwuIFRoaXMgc2lnbmFscyB0byB0aGUgcm91dGVyIHRoYXQgaXQgc2hvdWxkIG9ubHlcbiAgICogYXBwbHkgdGhlIHBhcnQgdGhhdCBkb2Vzbid0IGRlcGVuZCBvbiBzZWFyY2hQYXJhbXMgKHNwZWNpZmljYWxseSB0aGUgbG9hZGluZyBzdGF0ZSkuXG4gICAqL1xuICBhbGlhc2VkPzogYm9vbGVhblxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjYWNoZSBrZXkgZm9yIHRoZSByb3V0ZXIgcHJlZmV0Y2ggY2FjaGVcbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBiZWluZyBuYXZpZ2F0ZWQgdG9cbiAqIEBwYXJhbSBuZXh0VXJsIC0gYW4gaW50ZXJuYWwgVVJMLCBwcmltYXJpbHkgdXNlZCBmb3IgaGFuZGxpbmcgcmV3cml0ZXMuIERlZmF1bHRzIHRvICcvJy5cbiAqIEByZXR1cm4gVGhlIGdlbmVyYXRlZCBwcmVmZXRjaCBjYWNoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByZWZldGNoQ2FjaGVLZXlJbXBsKFxuICB1cmw6IFVSTCxcbiAgaW5jbHVkZVNlYXJjaFBhcmFtczogYm9vbGVhbixcbiAgcHJlZml4Pzogc3RyaW5nIHwgbnVsbFxuKSB7XG4gIC8vIEluaXRpYWxseSB3ZSBvbmx5IHVzZSB0aGUgcGF0aG5hbWUgYXMgdGhlIGNhY2hlIGtleS4gV2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gIC8vIHNlYXJjaCBwYXJhbXMgc28gdGhhdCBtdWx0aXBsZSBVUkxzIHdpdGggdGhlIHNhbWUgc2VhcmNoIHBhcmFtZXRlciBjYW4gcmUtdXNlXG4gIC8vIGxvYWRpbmcgc3RhdGVzLlxuICBsZXQgcGF0aG5hbWVGcm9tVXJsID0gdXJsLnBhdGhuYW1lXG5cbiAgLy8gUlNDIHJlc3BvbnNlcyBjYW4gZGlmZmVyIGJhc2VkIG9uIHNlYXJjaCBwYXJhbXMsIHNwZWNpZmljYWxseSBpbiB0aGUgY2FzZSB3aGVyZSB3ZSBhcmVuJ3RcbiAgLy8gcmV0dXJuaW5nIGEgcGFydGlhbCByZXNwb25zZSAoaWUgd2l0aCBgUHJlZmV0Y2hLaW5kLkFVVE9gKS5cbiAgLy8gSW4gdGhlIGF1dG8gY2FzZSwgc2luY2UgbG9hZGluZy5qcyAmIGxheW91dC5qcyB3b24ndCBoYXZlIGFjY2VzcyB0byBzZWFyY2ggcGFyYW1zLFxuICAvLyB3ZSBjYW4gc2FmZWx5IHJlLXVzZSB0aGF0IGNhY2hlIGVudHJ5LiBCdXQgZm9yIGZ1bGwgcHJlZmV0Y2hlcywgd2Ugc2hvdWxkIG5vdFxuICAvLyByZS11c2UgdGhlIGNhY2hlIGVudHJ5IGFzIHRoZSByZXNwb25zZSBtYXkgZGlmZmVyLlxuICBpZiAoaW5jbHVkZVNlYXJjaFBhcmFtcykge1xuICAgIC8vIGlmIHdlIGhhdmUgYSBmdWxsIHByZWZldGNoLCB3ZSBjYW4gaW5jbHVkZSB0aGUgc2VhcmNoIHBhcmFtIGluIHRoZSBrZXksXG4gICAgLy8gYXMgd2UnbGwgYmUgZ2V0dGluZyBiYWNrIGEgZnVsbCByZXNwb25zZS4gVGhlIHNlcnZlciBtaWdodCBoYXZlIHJlYWQgdGhlIHNlYXJjaFxuICAgIC8vIHBhcmFtcyB3aGVuIGdlbmVyYXRpbmcgdGhlIGZ1bGwgcmVzcG9uc2UuXG4gICAgcGF0aG5hbWVGcm9tVXJsICs9IHVybC5zZWFyY2hcbiAgfVxuXG4gIGlmIChwcmVmaXgpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4fSR7SU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVJ9JHtwYXRobmFtZUZyb21Vcmx9YFxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lRnJvbVVybFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KFxuICB1cmw6IFVSTCxcbiAga2luZDogUHJlZmV0Y2hLaW5kIHwgdW5kZWZpbmVkLFxuICBuZXh0VXJsPzogc3RyaW5nIHwgbnVsbFxuKSB7XG4gIHJldHVybiBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbCh1cmwsIGtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMLCBuZXh0VXJsKVxufVxuXG5mdW5jdGlvbiBnZXRFeGlzdGluZ0NhY2hlRW50cnkoXG4gIHVybDogVVJMLFxuICBraW5kOiBQcmVmZXRjaEtpbmQgPSBQcmVmZXRjaEtpbmQuVEVNUE9SQVJZLFxuICBuZXh0VXJsOiBzdHJpbmcgfCBudWxsLFxuICBwcmVmZXRjaENhY2hlOiBNYXA8c3RyaW5nLCBQcmVmZXRjaENhY2hlRW50cnk+LFxuICBhbGxvd0FsaWFzaW5nOiBib29sZWFuXG4pOiBBbGlhc2VkUHJlZmV0Y2hDYWNoZUVudHJ5IHwgdW5kZWZpbmVkIHtcbiAgLy8gV2UgZmlyc3QgY2hlY2sgaWYgdGhlcmUncyBhIG1vcmUgc3BlY2lmaWMgaW50ZXJjZXB0aW9uIHJvdXRlIHByZWZldGNoIGVudHJ5XG4gIC8vIFRoaXMgaXMgYmVjYXVzZSB3aGVuIHdlIGRldGVjdCBhIHByZWZldGNoIHRoYXQgY29ycmVzcG9uZHMgd2l0aCBhbiBpbnRlcmNlcHRpb24gcm91dGUsIHdlIHByZWZpeCBpdCB3aXRoIG5leHRVcmwgKHNlZSBgY3JlYXRlUHJlZmV0Y2hDYWNoZUtleWApXG4gIC8vIHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBhZ2VzIHRoYXQgbWF5IGhhdmUgdGhlIHNhbWUgVVJMIGJ1dCByZW5kZXIgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIGBOZXh0LVVSTGAgaGVhZGVyLlxuICBmb3IgKGNvbnN0IG1heWJlTmV4dFVybCBvZiBbbmV4dFVybCwgbnVsbF0pIHtcbiAgICBjb25zdCBjYWNoZUtleVdpdGhQYXJhbXMgPSBjcmVhdGVQcmVmZXRjaENhY2hlS2V5SW1wbChcbiAgICAgIHVybCxcbiAgICAgIHRydWUsXG4gICAgICBtYXliZU5leHRVcmxcbiAgICApXG4gICAgY29uc3QgY2FjaGVLZXlXaXRob3V0UGFyYW1zID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwoXG4gICAgICB1cmwsXG4gICAgICBmYWxzZSxcbiAgICAgIG1heWJlTmV4dFVybFxuICAgIClcblxuICAgIC8vIEZpcnN0LCB3ZSBjaGVjayBpZiB3ZSBoYXZlIGEgY2FjaGUgZW50cnkgdGhhdCBleGFjdGx5IG1hdGNoZXMgdGhlIFVSTFxuICAgIGNvbnN0IGNhY2hlS2V5VG9Vc2UgPSB1cmwuc2VhcmNoXG4gICAgICA/IGNhY2hlS2V5V2l0aFBhcmFtc1xuICAgICAgOiBjYWNoZUtleVdpdGhvdXRQYXJhbXNcblxuICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChjYWNoZUtleVRvVXNlKVxuICAgIGlmIChleGlzdGluZ0VudHJ5ICYmIGFsbG93QWxpYXNpbmcpIHtcbiAgICAgIC8vIFdlIGtub3cgd2UncmUgcmV0dXJuaW5nIGFuIGFsaWFzZWQgZW50cnkgd2hlbiB0aGUgcGF0aG5hbWUgbWF0Y2hlcyBidXQgdGhlIHNlYXJjaCBwYXJhbXMgZG9uJ3QsXG4gICAgICBjb25zdCBpc0FsaWFzZWQgPVxuICAgICAgICBleGlzdGluZ0VudHJ5LnVybC5wYXRobmFtZSA9PT0gdXJsLnBhdGhuYW1lICYmXG4gICAgICAgIGV4aXN0aW5nRW50cnkudXJsLnNlYXJjaCAhPT0gdXJsLnNlYXJjaFxuXG4gICAgICBpZiAoaXNBbGlhc2VkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uZXhpc3RpbmdFbnRyeSxcbiAgICAgICAgICBhbGlhc2VkOiB0cnVlLFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlzdGluZ0VudHJ5XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgY29udGFpbnMgc2VhcmNoIHBhcmFtcywgYW5kIHdlJ3JlIG5vdCBkb2luZyBhIGZ1bGwgcHJlZmV0Y2gsIHdlIGNhbiByZXR1cm4gdGhlXG4gICAgLy8gcGFyYW0tbGVzcyBlbnRyeSBpZiBpdCBleGlzdHMuXG4gICAgLy8gVGhpcyBpcyB0ZWNobmljYWxseSBjb3ZlcmVkIGJ5IHRoZSBjaGVjayBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZnVuY3Rpb24sIHdoaWNoIGl0ZXJhdGVzIG92ZXIgY2FjaGUgZW50cmllcyxcbiAgICAvLyBidXQgbGV0cyB1cyBhcnJpdmUgdGhlcmUgcXVpY2tlciBpbiB0aGUgcGFyYW0tZnVsbCBjYXNlLlxuICAgIGNvbnN0IGVudHJ5V2l0aG91dFBhcmFtcyA9IHByZWZldGNoQ2FjaGUuZ2V0KGNhY2hlS2V5V2l0aG91dFBhcmFtcylcbiAgICBpZiAoXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJlxuICAgICAgYWxsb3dBbGlhc2luZyAmJlxuICAgICAgdXJsLnNlYXJjaCAmJlxuICAgICAga2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICAgIGVudHJ5V2l0aG91dFBhcmFtcyAmJlxuICAgICAgLy8gV2Ugc2hvdWxkbid0IHJldHVybiB0aGUgYWxpYXNlZCBlbnRyeSBpZiBpdCB3YXMgcmVsb2NhdGVkIHRvIGEgbmV3IGNhY2hlIGtleS5cbiAgICAgIC8vIFNpbmNlIGl0J3MgcmV3cml0dGVuLCBpdCBjb3VsZCByZXNwb25kIHdpdGggYSBjb21wbGV0ZWx5IGRpZmZlcmVudCBsb2FkaW5nIHN0YXRlLlxuICAgICAgIWVudHJ5V2l0aG91dFBhcmFtcy5rZXkuaW5jbHVkZXMoSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIpXG4gICAgKSB7XG4gICAgICByZXR1cm4geyAuLi5lbnRyeVdpdGhvdXRQYXJhbXMsIGFsaWFzZWQ6IHRydWUgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlJ3ZlIGdvdHRlbiB0byB0aGlzIHBvaW50LCB3ZSBkaWRuJ3QgZmluZCBhIHNwZWNpZmljIGNhY2hlIGVudHJ5IHRoYXQgbWF0Y2hlZFxuICAvLyB0aGUgcmVxdWVzdCBVUkwuXG4gIC8vIFdlIGF0dGVtcHQgYSBwYXJ0aWFsIG1hdGNoIGJ5IGNoZWNraW5nIGlmIHRoZXJlJ3MgYSBjYWNoZSBlbnRyeSB3aXRoIHRoZSBzYW1lIHBhdGhuYW1lLlxuICAvLyBSZWdhcmRsZXNzIG9mIHdoYXQgd2UgZmluZCwgc2luY2UgaXQgZG9lc24ndCBjb3JyZXNwb25kIHdpdGggdGhlIHJlcXVlc3RlZCBVUkwsIHdlJ2xsIG1hcmsgaXQgXCJhbGlhc2VkXCIuXG4gIC8vIFRoaXMgd2lsbCBzaWduYWwgdG8gdGhlIHJvdXRlciB0aGF0IGl0IHNob3VsZCBvbmx5IGFwcGx5IHRoZSBsb2FkaW5nIHN0YXRlIG9uIHRoZSBwcmVmZXRjaGVkIGRhdGEuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJlxuICAgIGtpbmQgIT09IFByZWZldGNoS2luZC5GVUxMICYmXG4gICAgYWxsb3dBbGlhc2luZ1xuICApIHtcbiAgICBmb3IgKGNvbnN0IGNhY2hlRW50cnkgb2YgcHJlZmV0Y2hDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKFxuICAgICAgICBjYWNoZUVudHJ5LnVybC5wYXRobmFtZSA9PT0gdXJsLnBhdGhuYW1lICYmXG4gICAgICAgIC8vIFdlIHNob3VsZG4ndCByZXR1cm4gdGhlIGFsaWFzZWQgZW50cnkgaWYgaXQgd2FzIHJlbG9jYXRlZCB0byBhIG5ldyBjYWNoZSBrZXkuXG4gICAgICAgIC8vIFNpbmNlIGl0J3MgcmV3cml0dGVuLCBpdCBjb3VsZCByZXNwb25kIHdpdGggYSBjb21wbGV0ZWx5IGRpZmZlcmVudCBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAhY2FjaGVFbnRyeS5rZXkuaW5jbHVkZXMoSU5URVJDRVBUSU9OX0NBQ0hFX0tFWV9NQVJLRVIpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHsgLi4uY2FjaGVFbnRyeSwgYWxpYXNlZDogdHJ1ZSB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwcmVmZXRjaCBjYWNoZSBlbnRyeSBpZiBvbmUgZXhpc3RzLiBPdGhlcndpc2UgY3JlYXRlcyBhIG5ldyBvbmUgYW5kIGVucXVldWVzIGEgZmV0Y2ggcmVxdWVzdFxuICogdG8gcmV0cmlldmUgdGhlIHByZWZldGNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3JDcmVhdGVQcmVmZXRjaENhY2hlRW50cnkoe1xuICB1cmwsXG4gIG5leHRVcmwsXG4gIHRyZWUsXG4gIHByZWZldGNoQ2FjaGUsXG4gIGtpbmQsXG4gIGFsbG93QWxpYXNpbmcgPSB0cnVlLFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3ByZWZldGNoQ2FjaGUnIHwgJ3RyZWUnPiAmIHtcbiAgdXJsOiBVUkxcbiAga2luZD86IFByZWZldGNoS2luZFxuICBhbGxvd0FsaWFzaW5nOiBib29sZWFuXG59KTogQWxpYXNlZFByZWZldGNoQ2FjaGVFbnRyeSB7XG4gIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IGdldEV4aXN0aW5nQ2FjaGVFbnRyeShcbiAgICB1cmwsXG4gICAga2luZCxcbiAgICBuZXh0VXJsLFxuICAgIHByZWZldGNoQ2FjaGUsXG4gICAgYWxsb3dBbGlhc2luZ1xuICApXG5cbiAgaWYgKGV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgIC8vIEdyYWIgdGhlIGxhdGVzdCBzdGF0dXMgb2YgdGhlIGNhY2hlIGVudHJ5IGFuZCB1cGRhdGUgaXRcbiAgICBleGlzdGluZ0NhY2hlRW50cnkuc3RhdHVzID0gZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKGV4aXN0aW5nQ2FjaGVFbnRyeSlcblxuICAgIC8vIHdoZW4gYGtpbmRgIGlzIHByb3ZpZGVkLCBhbiBleHBsaWNpdCBwcmVmZXRjaCB3YXMgcmVxdWVzdGVkLlxuICAgIC8vIGlmIHRoZSByZXF1ZXN0ZWQgcHJlZmV0Y2ggaXMgXCJmdWxsXCIgYW5kIHRoZSBjdXJyZW50IGNhY2hlIGVudHJ5IHdhc24ndCwgd2Ugd2FudCB0byByZS1wcmVmZXRjaCB3aXRoIHRoZSBuZXcgaW50ZW50XG4gICAgY29uc3Qgc3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCA9XG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkua2luZCAhPT0gUHJlZmV0Y2hLaW5kLkZVTEwgJiZcbiAgICAgIGtpbmQgPT09IFByZWZldGNoS2luZC5GVUxMXG5cbiAgICBpZiAoc3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCkge1xuICAgICAgLy8gSWYgd2Ugc3dpdGNoZWQgdG8gYSBmdWxsIHByZWZldGNoLCB2YWxpZGF0ZSB0aGF0IHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSBjb250YWluZWQgcGFydGlhbCBkYXRhLlxuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjYWNoZSBlbnRyeSB3YXMgc2VlZGVkIHdpdGggZnVsbCBkYXRhIGJ1dCBoYXMgYSBjYWNoZSB0eXBlIG9mIFwiYXV0b1wiIChpZSB3aGVuIGNhY2hlIGVudHJpZXNcbiAgICAgIC8vIGFyZSBzZWVkZWQgYnV0IHdpdGhvdXQgYSBwcmVmZXRjaCBpbnRlbnQpXG4gICAgICBleGlzdGluZ0NhY2hlRW50cnkuZGF0YS50aGVuKChwcmVmZXRjaFJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzRnVsbFByZWZldGNoID1cbiAgICAgICAgICBBcnJheS5pc0FycmF5KHByZWZldGNoUmVzcG9uc2UuZmxpZ2h0RGF0YSkgJiZcbiAgICAgICAgICBwcmVmZXRjaFJlc3BvbnNlLmZsaWdodERhdGEuc29tZSgoZmxpZ2h0RGF0YSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCByZW5kZXJpbmcgZnJvbSB0aGUgcm9vdCBhbmQgd2UgcmV0dXJuZWQgUlNDIGRhdGEgKHNlZWREYXRhKSwgd2UgYWxyZWFkeSBoYWQgYSBmdWxsIHByZWZldGNoLlxuICAgICAgICAgICAgcmV0dXJuIGZsaWdodERhdGEuaXNSb290UmVuZGVyICYmIGZsaWdodERhdGEuc2VlZERhdGEgIT09IG51bGxcbiAgICAgICAgICB9KVxuXG4gICAgICAgIGlmICghaXNGdWxsUHJlZmV0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICAgICAgICAgICAgdHJlZSxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG5leHRVcmwsXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGdldCBhbiBleHBsaWNpdCBwcmVmZXRjaCBraW5kLCB3ZSB3YW50IHRvIHNldCBhIHRlbXBvcmFyeSBraW5kXG4gICAgICAgICAgICAvLyByYXRoZXIgdGhhbiBhc3N1bWluZyB0aGUgc2FtZSBpbnRlbnQgYXMgdGhlIHByZXZpb3VzIGVudHJ5LCB0byBiZSBjb25zaXN0ZW50IHdpdGggaG93IHdlXG4gICAgICAgICAgICAvLyBsYXppbHkgY3JlYXRlIHByZWZldGNoIGVudHJpZXMgd2hlbiBpbnRlbnQgaXMgbGVmdCB1bnNwZWNpZmllZC5cbiAgICAgICAgICAgIGtpbmQ6IGtpbmQgPz8gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBleGlzdGluZyBjYWNoZSBlbnRyeSB3YXMgbWFya2VkIGFzIHRlbXBvcmFyeSwgaXQgbWVhbnMgaXQgd2FzIGxhemlseSBjcmVhdGVkIHdoZW4gYXR0ZW1wdGluZyB0byBnZXQgYW4gZW50cnksXG4gICAgLy8gd2hlcmUgd2UgZGlkbid0IGhhdmUgdGhlIHByZWZldGNoIGludGVudC4gTm93IHRoYXQgd2UgaGF2ZSB0aGUgaW50ZW50IChpbiBga2luZGApLCB3ZSB3YW50IHRvIHVwZGF0ZSB0aGUgZW50cnkgdG8gdGhlIG1vcmUgYWNjdXJhdGUga2luZC5cbiAgICBpZiAoa2luZCAmJiBleGlzdGluZ0NhY2hlRW50cnkua2luZCA9PT0gUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSkge1xuICAgICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQgPSBraW5kXG4gICAgfVxuXG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IHRoZSBleGlzdGluZyBlbnRyeSB3ZSBmb3VuZCBpcyBzdGlsbCB2YWxpZCwgc28gd2UgcmV0dXJuIGl0LlxuICAgIHJldHVybiBleGlzdGluZ0NhY2hlRW50cnlcbiAgfVxuXG4gIC8vIElmIHdlIGRpZG4ndCByZXR1cm4gYW4gZW50cnksIGNyZWF0ZSBhIG5ldyBvbmUuXG4gIHJldHVybiBjcmVhdGVMYXp5UHJlZmV0Y2hFbnRyeSh7XG4gICAgdHJlZSxcbiAgICB1cmwsXG4gICAgbmV4dFVybCxcbiAgICBwcmVmZXRjaENhY2hlLFxuICAgIGtpbmQ6IGtpbmQgfHwgUHJlZmV0Y2hLaW5kLlRFTVBPUkFSWSxcbiAgfSlcbn1cblxuLypcbiAqIFVzZWQgdG8gdGFrZSBhbiBleGlzdGluZyBjYWNoZSBlbnRyeSBhbmQgcHJlZml4IGl0IHdpdGggdGhlIG5leHRVcmwsIGlmIGl0IGV4aXN0cy5cbiAqIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IGhhdmUgY29uZmxpY3RpbmcgY2FjaGUgZW50cmllcyBmb3IgdGhlIHNhbWUgVVJMIChhcyBpcyB0aGUgY2FzZSB3aXRoIHJvdXRlIGludGVyY2VwdGlvbikuXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEV4aXN0aW5nUHJlZmV0Y2hDYWNoZUVudHJ5KHtcbiAgdXJsLFxuICBuZXh0VXJsLFxuICBwcmVmZXRjaENhY2hlLFxuICBleGlzdGluZ0NhY2hlS2V5LFxufTogUGljazxSZWFkb25seVJlZHVjZXJTdGF0ZSwgJ25leHRVcmwnIHwgJ3ByZWZldGNoQ2FjaGUnPiAmIHtcbiAgdXJsOiBVUkxcbiAgZXhpc3RpbmdDYWNoZUtleTogc3RyaW5nXG59KSB7XG4gIGNvbnN0IGV4aXN0aW5nQ2FjaGVFbnRyeSA9IHByZWZldGNoQ2FjaGUuZ2V0KGV4aXN0aW5nQ2FjaGVLZXkpXG4gIGlmICghZXhpc3RpbmdDYWNoZUVudHJ5KSB7XG4gICAgLy8gbm8tb3AgLS0gdGhlcmUgd2Fzbid0IGFuIGVudHJ5IHRvIG1vdmVcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IG5ld0NhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleShcbiAgICB1cmwsXG4gICAgZXhpc3RpbmdDYWNoZUVudHJ5LmtpbmQsXG4gICAgbmV4dFVybFxuICApXG4gIHByZWZldGNoQ2FjaGUuc2V0KG5ld0NhY2hlS2V5LCB7IC4uLmV4aXN0aW5nQ2FjaGVFbnRyeSwga2V5OiBuZXdDYWNoZUtleSB9KVxuICBwcmVmZXRjaENhY2hlLmRlbGV0ZShleGlzdGluZ0NhY2hlS2V5KVxuXG4gIHJldHVybiBuZXdDYWNoZUtleVxufVxuXG4vKipcbiAqIFVzZSB0byBzZWVkIHRoZSBwcmVmZXRjaCBjYWNoZSB3aXRoIGRhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGZldGNoZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkoe1xuICBuZXh0VXJsLFxuICB0cmVlLFxuICBwcmVmZXRjaENhY2hlLFxuICB1cmwsXG4gIGRhdGEsXG4gIGtpbmQsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAndHJlZScgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBkYXRhOiBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0XG4gIGtpbmQ6IFByZWZldGNoS2luZFxufSkge1xuICAvLyBUaGUgaW5pdGlhbCBjYWNoZSBlbnRyeSB0ZWNobmljYWxseSBpbmNsdWRlcyBmdWxsIGRhdGEsIGJ1dCBpdCBpc24ndCBleHBsaWNpdGx5IHByZWZldGNoZWQgLS0gd2UganVzdCBzZWVkIHRoZVxuICAvLyBwcmVmZXRjaCBjYWNoZSBzbyB0aGF0IHdlIGNhbiBza2lwIGFuIGV4dHJhIHByZWZldGNoIHJlcXVlc3QgbGF0ZXIsIHNpbmNlIHdlIGFscmVhZHkgaGF2ZSB0aGUgZGF0YS5cbiAgLy8gaWYgdGhlIHByZWZldGNoIGNvcnJlc3BvbmRzIHdpdGggYW4gaW50ZXJjZXB0aW9uIHJvdXRlLCB3ZSB1c2UgdGhlIG5leHRVcmwgdG8gcHJlZml4IHRoZSBjYWNoZSBrZXlcbiAgY29uc3QgcHJlZmV0Y2hDYWNoZUtleSA9IGRhdGEuY291bGRCZUludGVyY2VwdGVkXG4gICAgPyBjcmVhdGVQcmVmZXRjaENhY2hlS2V5KHVybCwga2luZCwgbmV4dFVybClcbiAgICA6IGNyZWF0ZVByZWZldGNoQ2FjaGVLZXkodXJsLCBraW5kKVxuXG4gIGNvbnN0IHByZWZldGNoRW50cnkgPSB7XG4gICAgdHJlZUF0VGltZU9mUHJlZmV0Y2g6IHRyZWUsXG4gICAgZGF0YTogUHJvbWlzZS5yZXNvbHZlKGRhdGEpLFxuICAgIGtpbmQsXG4gICAgcHJlZmV0Y2hUaW1lOiBEYXRlLm5vdygpLFxuICAgIGxhc3RVc2VkVGltZTogRGF0ZS5ub3coKSxcbiAgICBzdGFsZVRpbWU6IGRhdGEuc3RhbGVUaW1lLFxuICAgIGtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICBzdGF0dXM6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaCxcbiAgICB1cmwsXG4gIH0gc2F0aXNmaWVzIFByZWZldGNoQ2FjaGVFbnRyeVxuXG4gIHByZWZldGNoQ2FjaGUuc2V0KHByZWZldGNoQ2FjaGVLZXksIHByZWZldGNoRW50cnkpXG5cbiAgcmV0dXJuIHByZWZldGNoRW50cnlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJlZmV0Y2ggZW50cnkgZW50cnkgYW5kIGVucXVldWVzIGEgZmV0Y2ggcmVxdWVzdCB0byByZXRyaWV2ZSB0aGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGF6eVByZWZldGNoRW50cnkoe1xuICB1cmwsXG4gIGtpbmQsXG4gIHRyZWUsXG4gIG5leHRVcmwsXG4gIHByZWZldGNoQ2FjaGUsXG59OiBQaWNrPFJlYWRvbmx5UmVkdWNlclN0YXRlLCAnbmV4dFVybCcgfCAndHJlZScgfCAncHJlZmV0Y2hDYWNoZSc+ICYge1xuICB1cmw6IFVSTFxuICBraW5kOiBQcmVmZXRjaEtpbmRcbn0pOiBQcmVmZXRjaENhY2hlRW50cnkge1xuICBjb25zdCBwcmVmZXRjaENhY2hlS2V5ID0gY3JlYXRlUHJlZmV0Y2hDYWNoZUtleSh1cmwsIGtpbmQpXG5cbiAgLy8gaW5pdGlhdGVzIHRoZSBmZXRjaCByZXF1ZXN0IGZvciB0aGUgcHJlZmV0Y2ggYW5kIGF0dGFjaGVzIGEgbGlzdGVuZXJcbiAgLy8gdG8gdGhlIHByb21pc2UgdG8gdXBkYXRlIHRoZSBwcmVmZXRjaCBjYWNoZSBlbnRyeSB3aGVuIHRoZSBwcm9taXNlIHJlc29sdmVzIChpZiBuZWNlc3NhcnkpXG4gIGNvbnN0IGRhdGEgPSBwcmVmZXRjaFF1ZXVlLmVucXVldWUoKCkgPT5cbiAgICBmZXRjaFNlcnZlclJlc3BvbnNlKHVybCwge1xuICAgICAgZmxpZ2h0Um91dGVyU3RhdGU6IHRyZWUsXG4gICAgICBuZXh0VXJsLFxuICAgICAgcHJlZmV0Y2hLaW5kOiBraW5kLFxuICAgIH0pLnRoZW4oKHByZWZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgIC8vIFRPRE86IGBmZXRjaFNlcnZlclJlc3BvbnNlYCBzaG91bGQgYmUgbW9yZSB0aWdobHkgY291cGxlZCB0byB0aGVzZSBwcmVmZXRjaCBjYWNoZSBvcGVyYXRpb25zXG4gICAgICAvLyB0byBhdm9pZCBkcmlmdCBiZXR3ZWVuIHRoaXMgY2FjaGUga2V5IHByZWZpeGluZyBsb2dpY1xuICAgICAgLy8gKHdoaWNoIGlzIGN1cnJlbnRseSBkaXJlY3RseSBpbmZsdWVuY2VkIGJ5IHRoZSBzZXJ2ZXIgcmVzcG9uc2UpXG4gICAgICBsZXQgbmV3Q2FjaGVLZXlcblxuICAgICAgaWYgKHByZWZldGNoUmVzcG9uc2UuY291bGRCZUludGVyY2VwdGVkKSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB3ZSBuZWVkIHRvIHByZWZpeCB0aGUgY2FjaGUga2V5IHdpdGggdGhlIG5leHRVcmxcbiAgICAgICAgbmV3Q2FjaGVLZXkgPSBwcmVmaXhFeGlzdGluZ1ByZWZldGNoQ2FjaGVFbnRyeSh7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGV4aXN0aW5nQ2FjaGVLZXk6IHByZWZldGNoQ2FjaGVLZXksXG4gICAgICAgICAgbmV4dFVybCxcbiAgICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcHJlZmV0Y2ggd2FzIGEgY2FjaGUgaGl0LCB3ZSB3YW50IHRvIHVwZGF0ZSB0aGUgZXhpc3RpbmcgY2FjaGUgZW50cnkgdG8gcmVmbGVjdCB0aGF0IGl0IHdhcyBhIGZ1bGwgcHJlZmV0Y2guXG4gICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGEgc3RhdGljIHJlc3BvbnNlIHdpbGwgY29udGFpbiB0aGUgZnVsbCBSU0MgcGF5bG9hZCwgYW5kIGNhbiBiZSB1cGRhdGVkIHRvIHJlc3BlY3QgdGhlIGBzdGF0aWNgXG4gICAgICAvLyBzdGFsZVRpbWUuXG4gICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5wcmVyZW5kZXJlZCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0NhY2hlRW50cnkgPSBwcmVmZXRjaENhY2hlLmdldChcbiAgICAgICAgICAvLyBpZiB3ZSBwcmVmaXhlZCB0aGUgY2FjaGUga2V5IGR1ZSB0byByb3V0ZSBpbnRlcmNlcHRpb24sIHdlIHdhbnQgdG8gdXNlIHRoZSBuZXcga2V5LiBPdGhlcndpc2Ugd2UgdXNlIHRoZSBvcmlnaW5hbCBrZXlcbiAgICAgICAgICBuZXdDYWNoZUtleSA/PyBwcmVmZXRjaENhY2hlS2V5XG4gICAgICAgIClcbiAgICAgICAgaWYgKGV4aXN0aW5nQ2FjaGVFbnRyeSkge1xuICAgICAgICAgIGV4aXN0aW5nQ2FjaGVFbnRyeS5raW5kID0gUHJlZmV0Y2hLaW5kLkZVTExcbiAgICAgICAgICBpZiAocHJlZmV0Y2hSZXNwb25zZS5zdGFsZVRpbWUgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBzdGFsZSB0aW1lIHRoYXQgd2FzIGNvbGxlY3RlZCBieSB0aGUgc2VydmVyIGR1cmluZ1xuICAgICAgICAgICAgLy8gc3RhdGljIGdlbmVyYXRpb24uIFVzZSB0aGlzIGluIHBsYWNlIG9mIHRoZSBkZWZhdWx0IHN0YWxlIHRpbWUuXG4gICAgICAgICAgICBleGlzdGluZ0NhY2hlRW50cnkuc3RhbGVUaW1lID0gcHJlZmV0Y2hSZXNwb25zZS5zdGFsZVRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZWZldGNoUmVzcG9uc2VcbiAgICB9KVxuICApXG5cbiAgY29uc3QgcHJlZmV0Y2hFbnRyeSA9IHtcbiAgICB0cmVlQXRUaW1lT2ZQcmVmZXRjaDogdHJlZSxcbiAgICBkYXRhLFxuICAgIGtpbmQsXG4gICAgcHJlZmV0Y2hUaW1lOiBEYXRlLm5vdygpLFxuICAgIGxhc3RVc2VkVGltZTogbnVsbCxcbiAgICBzdGFsZVRpbWU6IC0xLFxuICAgIGtleTogcHJlZmV0Y2hDYWNoZUtleSxcbiAgICBzdGF0dXM6IFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5mcmVzaCxcbiAgICB1cmwsXG4gIH1cblxuICBwcmVmZXRjaENhY2hlLnNldChwcmVmZXRjaENhY2hlS2V5LCBwcmVmZXRjaEVudHJ5KVxuXG4gIHJldHVybiBwcmVmZXRjaEVudHJ5XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcnVuZVByZWZldGNoQ2FjaGUoXG4gIHByZWZldGNoQ2FjaGU6IFJlYWRvbmx5UmVkdWNlclN0YXRlWydwcmVmZXRjaENhY2hlJ11cbikge1xuICBmb3IgKGNvbnN0IFtocmVmLCBwcmVmZXRjaENhY2hlRW50cnldIG9mIHByZWZldGNoQ2FjaGUpIHtcbiAgICBpZiAoXG4gICAgICBnZXRQcmVmZXRjaEVudHJ5Q2FjaGVTdGF0dXMocHJlZmV0Y2hDYWNoZUVudHJ5KSA9PT1cbiAgICAgIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5leHBpcmVkXG4gICAgKSB7XG4gICAgICBwcmVmZXRjaENhY2hlLmRlbGV0ZShocmVmKVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGVzZSB2YWx1ZXMgYXJlIHNldCBieSBgZGVmaW5lLWVudi1wbHVnaW5gIChiYXNlZCBvbiBgbmV4dENvbmZpZy5leHBlcmltZW50YWwuc3RhbGVUaW1lc2ApXG4vLyBhbmQgZGVmYXVsdCB0byA1IG1pbnV0ZXMgKHN0YXRpYykgLyAwIHNlY29uZHMgKGR5bmFtaWMpXG5leHBvcnQgY29uc3QgRFlOQU1JQ19TVEFMRVRJTUVfTVMgPVxuICBOdW1iZXIocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRFlOQU1JQ19TVEFMRVRJTUUpICogMTAwMFxuXG5leHBvcnQgY29uc3QgU1RBVElDX1NUQUxFVElNRV9NUyA9XG4gIE51bWJlcihwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TVEFUSUNfU1RBTEVUSU1FKSAqIDEwMDBcblxuZnVuY3Rpb24gZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzKHtcbiAga2luZCxcbiAgcHJlZmV0Y2hUaW1lLFxuICBsYXN0VXNlZFRpbWUsXG59OiBQcmVmZXRjaENhY2hlRW50cnkpOiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMge1xuICAvLyBXZSB3aWxsIHJlLXVzZSB0aGUgY2FjaGUgZW50cnkgZGF0YSBmb3IgdXAgdG8gdGhlIGBkeW5hbWljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoRGF0ZS5ub3coKSA8IChsYXN0VXNlZFRpbWUgPz8gcHJlZmV0Y2hUaW1lKSArIERZTkFNSUNfU1RBTEVUSU1FX01TKSB7XG4gICAgcmV0dXJuIGxhc3RVc2VkVGltZVxuICAgICAgPyBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICAgIDogUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmZyZXNoXG4gIH1cblxuICAvLyBGb3IgXCJhdXRvXCIgcHJlZmV0Y2hpbmcsIHdlJ2xsIHJlLXVzZSBvbmx5IHRoZSBsb2FkaW5nIGJvdW5kYXJ5IGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICAvLyBBIHN0YWxlIGVudHJ5IHdpbGwgb25seSByZS11c2UgdGhlIGBsb2FkaW5nYCBib3VuZGFyeSwgbm90IHRoZSBmdWxsIGRhdGEuXG4gIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIGEgXCJsYXp5IGZldGNoXCIgZm9yIHRoZSBmdWxsIGRhdGEuXG4gIGlmIChraW5kID09PSBQcmVmZXRjaEtpbmQuQVVUTykge1xuICAgIGlmIChEYXRlLm5vdygpIDwgcHJlZmV0Y2hUaW1lICsgU1RBVElDX1NUQUxFVElNRV9NUykge1xuICAgICAgcmV0dXJuIFByZWZldGNoQ2FjaGVFbnRyeVN0YXR1cy5zdGFsZVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvciBcImZ1bGxcIiBwcmVmZXRjaGluZywgd2UnbGwgcmUtdXNlIHRoZSBjYWNoZSBlbnRyeSBkYXRhIGZvciB1cCB0byBgc3RhdGljYCBzdGFsZXRpbWUgd2luZG93LlxuICBpZiAoa2luZCA9PT0gUHJlZmV0Y2hLaW5kLkZVTEwpIHtcbiAgICBpZiAoRGF0ZS5ub3coKSA8IHByZWZldGNoVGltZSArIFNUQVRJQ19TVEFMRVRJTUVfTVMpIHtcbiAgICAgIHJldHVybiBQcmVmZXRjaENhY2hlRW50cnlTdGF0dXMucmV1c2FibGVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzLmV4cGlyZWRcbn1cbiJdLCJuYW1lcyI6WyJEWU5BTUlDX1NUQUxFVElNRV9NUyIsIlNUQVRJQ19TVEFMRVRJTUVfTVMiLCJjcmVhdGVTZWVkZWRQcmVmZXRjaENhY2hlRW50cnkiLCJnZXRPckNyZWF0ZVByZWZldGNoQ2FjaGVFbnRyeSIsInBydW5lUHJlZmV0Y2hDYWNoZSIsIklOVEVSQ0VQVElPTl9DQUNIRV9LRVlfTUFSS0VSIiwiY3JlYXRlUHJlZmV0Y2hDYWNoZUtleUltcGwiLCJ1cmwiLCJpbmNsdWRlU2VhcmNoUGFyYW1zIiwicHJlZml4IiwicGF0aG5hbWVGcm9tVXJsIiwicGF0aG5hbWUiLCJzZWFyY2giLCJjcmVhdGVQcmVmZXRjaENhY2hlS2V5Iiwia2luZCIsIm5leHRVcmwiLCJQcmVmZXRjaEtpbmQiLCJGVUxMIiwiZ2V0RXhpc3RpbmdDYWNoZUVudHJ5IiwicHJlZmV0Y2hDYWNoZSIsImFsbG93QWxpYXNpbmciLCJURU1QT1JBUlkiLCJtYXliZU5leHRVcmwiLCJjYWNoZUtleVdpdGhQYXJhbXMiLCJjYWNoZUtleVdpdGhvdXRQYXJhbXMiLCJjYWNoZUtleVRvVXNlIiwiZXhpc3RpbmdFbnRyeSIsImdldCIsImlzQWxpYXNlZCIsImFsaWFzZWQiLCJlbnRyeVdpdGhvdXRQYXJhbXMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJrZXkiLCJpbmNsdWRlcyIsImNhY2hlRW50cnkiLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJ0cmVlIiwiZXhpc3RpbmdDYWNoZUVudHJ5Iiwic3RhdHVzIiwiZ2V0UHJlZmV0Y2hFbnRyeUNhY2hlU3RhdHVzIiwic3dpdGNoZWRUb0Z1bGxQcmVmZXRjaCIsImRhdGEiLCJ0aGVuIiwicHJlZmV0Y2hSZXNwb25zZSIsImlzRnVsbFByZWZldGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiZmxpZ2h0RGF0YSIsInNvbWUiLCJpc1Jvb3RSZW5kZXIiLCJzZWVkRGF0YSIsImNyZWF0ZUxhenlQcmVmZXRjaEVudHJ5IiwicHJlZml4RXhpc3RpbmdQcmVmZXRjaENhY2hlRW50cnkiLCJleGlzdGluZ0NhY2hlS2V5IiwibmV3Q2FjaGVLZXkiLCJzZXQiLCJkZWxldGUiLCJwcmVmZXRjaENhY2hlS2V5IiwiY291bGRCZUludGVyY2VwdGVkIiwicHJlZmV0Y2hFbnRyeSIsInRyZWVBdFRpbWVPZlByZWZldGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwcmVmZXRjaFRpbWUiLCJEYXRlIiwibm93IiwibGFzdFVzZWRUaW1lIiwic3RhbGVUaW1lIiwiUHJlZmV0Y2hDYWNoZUVudHJ5U3RhdHVzIiwiZnJlc2giLCJwcmVmZXRjaFF1ZXVlIiwiZW5xdWV1ZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJmbGlnaHRSb3V0ZXJTdGF0ZSIsInByZWZldGNoS2luZCIsInByZXJlbmRlcmVkIiwiaHJlZiIsInByZWZldGNoQ2FjaGVFbnRyeSIsImV4cGlyZWQiLCJOdW1iZXIiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EWU5BTUlDX1NUQUxFVElNRSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX1NUQVRJQ19TVEFMRVRJTUUiLCJyZXVzYWJsZSIsIkFVVE8iLCJzdGFsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js ***!
  \*************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"hmrRefreshReducer\", ({\n    enumerable: true,\n    get: function() {\n        return hmrRefreshReducer;\n    }\n}));\nconst _fetchserverresponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _createhreffromurl = __webpack_require__(/*! ../create-href-from-url */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nconst _applyrouterstatepatchtotree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nconst _isnavigatingtonewrootlayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nconst _navigatereducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nconst _handlemutable = __webpack_require__(/*! ../handle-mutable */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-mutable.js\");\nconst _applyflightdata = __webpack_require__(/*! ../apply-flight-data */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/apply-flight-data.js\");\nconst _approuter = __webpack_require__(/*! ../../app-router */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router.js\");\nconst _handlesegmentmismatch = __webpack_require__(/*! ../handle-segment-mismatch */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js\");\nconst _hasinterceptionrouteincurrenttree = __webpack_require__(/*! ./has-interception-route-in-current-tree */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js\");\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(state, action) {\n    const { origin } = action;\n    const mutable = {};\n    const href = state.canonicalUrl;\n    mutable.preserveCustomHistoryState = false;\n    const cache = (0, _approuter.createEmptyCacheNode)();\n    // If the current tree was intercepted, the nextUrl should be included in the request.\n    // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n    const includeNextUrl = (0, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);\n    // TODO-APP: verify that `href` is not an external url.\n    // Fetch data from the root of the tree.\n    const navigatedAt = Date.now();\n    cache.lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(href, origin), {\n        flightRouterState: [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            'refetch'\n        ],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n        isHmrRefresh: true\n    });\n    return cache.lazyData.then((param)=>{\n        let { flightData, canonicalUrl: canonicalUrlOverride } = param;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === 'string') {\n            return (0, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);\n        }\n        // Remove cache.lazyData as it has been resolved at this point.\n        cache.lazyData = null;\n        let currentTree = state.tree;\n        let currentCache = state.cache;\n        for (const normalizedFlightData of flightData){\n            const { tree: treePatch, isRootRender } = normalizedFlightData;\n            if (!isRootRender) {\n                // TODO-APP: handle this case better\n                console.log('REFRESH FAILED');\n                return state;\n            }\n            const newTree = (0, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([\n                ''\n            ], currentTree, treePatch, state.canonicalUrl);\n            if (newTree === null) {\n                return (0, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);\n            }\n            if ((0, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {\n                return (0, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);\n            }\n            const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;\n            if (canonicalUrlOverride) {\n                mutable.canonicalUrl = canonicalUrlOverrideHref;\n            }\n            const applied = (0, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);\n            if (applied) {\n                mutable.cache = cache;\n                currentCache = cache;\n            }\n            mutable.patchedTree = newTree;\n            mutable.canonicalUrl = href;\n            currentTree = newTree;\n        }\n        return (0, _handlemutable.handleMutable)(state, mutable);\n    }, ()=>state);\n}\nfunction hmrRefreshReducerNoop(state, _action) {\n    return state;\n}\nconst hmrRefreshReducer =  false ? 0 : hmrRefreshReducerImpl;\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=hmr-refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvaG1yLXJlZnJlc2gtcmVkdWNlci5qcyIsIm1hcHBpbmdzIjoiOzs7O3FEQStIYUE7OztlQUFBQTs7O2lEQS9IdUI7K0NBQ0Y7eURBQ1U7eURBQ0E7NkNBT1Y7MkNBQ0o7NkNBQ0U7dUNBRUs7bURBQ0M7K0RBQ1k7QUFFbEQsd0ZBQXdGO0FBQ3hGLFNBQVNDLHNCQUNQQyxLQUEyQixFQUMzQkMsTUFBd0I7SUFFeEIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0Q7SUFDbkIsTUFBTUUsVUFBbUIsQ0FBQztJQUMxQixNQUFNQyxPQUFPSixNQUFNSyxZQUFZO0lBRS9CRixRQUFRRywwQkFBMEIsR0FBRztJQUVyQyxNQUFNQyxRQUFtQkMsQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQUFBO0lBQ3pCLHNGQUFzRjtJQUN0RixzSEFBc0g7SUFDdEgsTUFBTUMsaUJBQWlCQyxDQUFBQSxHQUFBQSxtQ0FBQUEsaUNBQWlDLEVBQUNWLE1BQU1XLElBQUk7SUFFbkUsdURBQXVEO0lBQ3ZELHdDQUF3QztJQUN4QyxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHO0lBQzVCUCxNQUFNUSxRQUFRLEdBQUdDLENBQUFBLEdBQUFBLHFCQUFBQSxtQkFBQUEsRUFBb0IsSUFBSUMsSUFBSWIsTUFBTUYsU0FBUztRQUMxRGdCLG1CQUFtQjtZQUFDbEIsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRVgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFBRTtTQUFVO1FBQzNFUSxTQUFTVixpQkFBaUJULE1BQU1tQixPQUFPLEdBQUc7UUFDMUNDLGNBQWM7SUFDaEI7SUFFQSxPQUFPYixNQUFNUSxRQUFRLENBQUNNLElBQUksQ0FDeEI7WUFBQyxFQUFFQyxVQUFVLEVBQUVqQixjQUFja0Isb0JBQW9CLEVBQUU7UUFDakQsNERBQTREO1FBQzVELElBQUksT0FBT0QsZUFBZSxVQUFVO1lBQ2xDLE9BQU9FLENBQUFBLEdBQUFBLGlCQUFBQSxpQkFBQUEsRUFDTHhCLE9BQ0FHLFNBQ0FtQixZQUNBdEIsTUFBTXlCLE9BQU8sQ0FBQ0MsV0FBVztRQUU3QjtRQUVBLCtEQUErRDtRQUMvRG5CLE1BQU1RLFFBQVEsR0FBRztRQUVqQixJQUFJWSxjQUFjM0IsTUFBTVcsSUFBSTtRQUM1QixJQUFJaUIsZUFBZTVCLE1BQU1PLEtBQUs7UUFFOUIsS0FBSyxNQUFNc0Isd0JBQXdCUCxXQUFZO1lBQzdDLE1BQU0sRUFBRVgsTUFBTW1CLFNBQVMsRUFBRUMsWUFBWSxFQUFFLEdBQUdGO1lBQzFDLElBQUksQ0FBQ0UsY0FBYztnQkFDakIsb0NBQW9DO2dCQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLE9BQU9qQztZQUNUO1lBRUEsTUFBTWtDLFVBQVVDLENBQUFBLEdBQUFBLDZCQUFBQSwyQkFBQUEsRUFDZDtnQkFDQzthQUFHLEVBQ0pSLGFBQ0FHLFdBQ0E5QixNQUFNSyxZQUFZO1lBR3BCLElBQUk2QixZQUFZLE1BQU07Z0JBQ3BCLE9BQU9FLENBQUFBLEdBQUFBLHVCQUFBQSxxQkFBQUEsRUFBc0JwQyxPQUFPQyxRQUFRNkI7WUFDOUM7WUFFQSxJQUFJTyxDQUFBQSxHQUFBQSw2QkFBQUEsMkJBQUFBLEVBQTRCVixhQUFhTyxVQUFVO2dCQUNyRCxPQUFPVixDQUFBQSxHQUFBQSxpQkFBQUEsaUJBQUFBLEVBQ0x4QixPQUNBRyxTQUNBQyxNQUNBSixNQUFNeUIsT0FBTyxDQUFDQyxXQUFXO1lBRTdCO1lBRUEsTUFBTVksMkJBQTJCZix1QkFDN0JnQixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCaEIsd0JBQ2xCaUI7WUFFSixJQUFJakIsc0JBQXNCO2dCQUN4QnBCLFFBQVFFLFlBQVksR0FBR2lDO1lBQ3pCO1lBQ0EsTUFBTUcsVUFBVUMsQ0FBQUEsR0FBQUEsaUJBQUFBLGVBQUFBLEVBQ2Q5QixhQUNBZ0IsY0FDQXJCLE9BQ0FzQjtZQUdGLElBQUlZLFNBQVM7Z0JBQ1h0QyxRQUFRSSxLQUFLLEdBQUdBO2dCQUNoQnFCLGVBQWVyQjtZQUNqQjtZQUVBSixRQUFRd0MsV0FBVyxHQUFHVDtZQUN0Qi9CLFFBQVFFLFlBQVksR0FBR0Q7WUFFdkJ1QixjQUFjTztRQUNoQjtRQUNBLE9BQU9VLENBQUFBLEdBQUFBLGVBQUFBLGFBQUFBLEVBQWM1QyxPQUFPRztJQUM5QixHQUNBLElBQU1IO0FBRVY7QUFFQSxTQUFTNkMsc0JBQ1A3QyxLQUEyQixFQUMzQjhDLE9BQXlCO0lBRXpCLE9BQU85QztBQUNUO0FBRU8sTUFBTUYsb0JBQ1hpRCxNQUFvQixHQUNoQkYsQ0FBcUJBLEdBQ3JCOUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNtaW5pL3NyYy9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9obXItcmVmcmVzaC1yZWR1Y2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZldGNoU2VydmVyUmVzcG9uc2UgfSBmcm9tICcuLi9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5pbXBvcnQgeyBjcmVhdGVIcmVmRnJvbVVybCB9IGZyb20gJy4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsJ1xuaW1wb3J0IHsgYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIH0gZnJvbSAnLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUnXG5pbXBvcnQgeyBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgfSBmcm9tICcuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dCdcbmltcG9ydCB0eXBlIHtcbiAgUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIFJlZHVjZXJTdGF0ZSxcbiAgSG1yUmVmcmVzaEFjdGlvbixcbiAgTXV0YWJsZSxcbn0gZnJvbSAnLi4vcm91dGVyLXJlZHVjZXItdHlwZXMnXG5pbXBvcnQgeyBoYW5kbGVFeHRlcm5hbFVybCB9IGZyb20gJy4vbmF2aWdhdGUtcmVkdWNlcidcbmltcG9ydCB7IGhhbmRsZU11dGFibGUgfSBmcm9tICcuLi9oYW5kbGUtbXV0YWJsZSdcbmltcG9ydCB7IGFwcGx5RmxpZ2h0RGF0YSB9IGZyb20gJy4uL2FwcGx5LWZsaWdodC1kYXRhJ1xuaW1wb3J0IHR5cGUgeyBDYWNoZU5vZGUgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGNyZWF0ZUVtcHR5Q2FjaGVOb2RlIH0gZnJvbSAnLi4vLi4vYXBwLXJvdXRlcidcbmltcG9ydCB7IGhhbmRsZVNlZ21lbnRNaXNtYXRjaCB9IGZyb20gJy4uL2hhbmRsZS1zZWdtZW50LW1pc21hdGNoJ1xuaW1wb3J0IHsgaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIH0gZnJvbSAnLi9oYXMtaW50ZXJjZXB0aW9uLXJvdXRlLWluLWN1cnJlbnQtdHJlZSdcblxuLy8gQSB2ZXJzaW9uIG9mIHJlZnJlc2ggcmVkdWNlciB0aGF0IGtlZXBzIHRoZSBjYWNoZSBhcm91bmQgaW5zdGVhZCBvZiB3aXBpbmcgYWxsIG9mIGl0LlxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJJbXBsKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIGFjdGlvbjogSG1yUmVmcmVzaEFjdGlvblxuKTogUmVkdWNlclN0YXRlIHtcbiAgY29uc3QgeyBvcmlnaW4gfSA9IGFjdGlvblxuICBjb25zdCBtdXRhYmxlOiBNdXRhYmxlID0ge31cbiAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybFxuXG4gIG11dGFibGUucHJlc2VydmVDdXN0b21IaXN0b3J5U3RhdGUgPSBmYWxzZVxuXG4gIGNvbnN0IGNhY2hlOiBDYWNoZU5vZGUgPSBjcmVhdGVFbXB0eUNhY2hlTm9kZSgpXG4gIC8vIElmIHRoZSBjdXJyZW50IHRyZWUgd2FzIGludGVyY2VwdGVkLCB0aGUgbmV4dFVybCBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIHJlcXVlc3QuXG4gIC8vIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgdGhlIHJlZnJlc2ggcmVxdWVzdCBkb2Vzbid0IGdldCBpbnRlcmNlcHRlZCwgYWNjaWRlbnRhbGx5IHRyaWdnZXJpbmcgdGhlIGludGVyY2VwdGlvbiByb3V0ZS5cbiAgY29uc3QgaW5jbHVkZU5leHRVcmwgPSBoYXNJbnRlcmNlcHRpb25Sb3V0ZUluQ3VycmVudFRyZWUoc3RhdGUudHJlZSlcblxuICAvLyBUT0RPLUFQUDogdmVyaWZ5IHRoYXQgYGhyZWZgIGlzIG5vdCBhbiBleHRlcm5hbCB1cmwuXG4gIC8vIEZldGNoIGRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZS5cbiAgY29uc3QgbmF2aWdhdGVkQXQgPSBEYXRlLm5vdygpXG4gIGNhY2hlLmxhenlEYXRhID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIHtcbiAgICBmbGlnaHRSb3V0ZXJTdGF0ZTogW3N0YXRlLnRyZWVbMF0sIHN0YXRlLnRyZWVbMV0sIHN0YXRlLnRyZWVbMl0sICdyZWZldGNoJ10sXG4gICAgbmV4dFVybDogaW5jbHVkZU5leHRVcmwgPyBzdGF0ZS5uZXh0VXJsIDogbnVsbCxcbiAgICBpc0htclJlZnJlc2g6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIGNhY2hlLmxhenlEYXRhLnRoZW4oXG4gICAgKHsgZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsOiBjYW5vbmljYWxVcmxPdmVycmlkZSB9KSA9PiB7XG4gICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIG11dGFibGUsXG4gICAgICAgICAgZmxpZ2h0RGF0YSxcbiAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNhY2hlLmxhenlEYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjYWNoZS5sYXp5RGF0YSA9IG51bGxcblxuICAgICAgbGV0IGN1cnJlbnRUcmVlID0gc3RhdGUudHJlZVxuICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IHN0YXRlLmNhY2hlXG5cbiAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEZsaWdodERhdGEgb2YgZmxpZ2h0RGF0YSkge1xuICAgICAgICBjb25zdCB7IHRyZWU6IHRyZWVQYXRjaCwgaXNSb290UmVuZGVyIH0gPSBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICBpZiAoIWlzUm9vdFJlbmRlcikge1xuICAgICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdSRUZSRVNIIEZBSUxFRCcpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKFxuICAgICAgICAgIC8vIFRPRE8tQVBQOiByZW1vdmUgJydcbiAgICAgICAgICBbJyddLFxuICAgICAgICAgIGN1cnJlbnRUcmVlLFxuICAgICAgICAgIHRyZWVQYXRjaCxcbiAgICAgICAgICBzdGF0ZS5jYW5vbmljYWxVcmxcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZVNlZ21lbnRNaXNtYXRjaChzdGF0ZSwgYWN0aW9uLCB0cmVlUGF0Y2gpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbXV0YWJsZSxcbiAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVcbiAgICAgICAgICA/IGNyZWF0ZUhyZWZGcm9tVXJsKGNhbm9uaWNhbFVybE92ZXJyaWRlKVxuICAgICAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAgICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBjYW5vbmljYWxVcmxPdmVycmlkZUhyZWZcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHBsaWVkID0gYXBwbHlGbGlnaHREYXRhKFxuICAgICAgICAgIG5hdmlnYXRlZEF0LFxuICAgICAgICAgIGN1cnJlbnRDYWNoZSxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBub3JtYWxpemVkRmxpZ2h0RGF0YVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGVcbiAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBjYWNoZVxuICAgICAgICB9XG5cbiAgICAgICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWVcbiAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBocmVmXG5cbiAgICAgICAgY3VycmVudFRyZWUgPSBuZXdUcmVlXG4gICAgICB9XG4gICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSlcbiAgICB9LFxuICAgICgpID0+IHN0YXRlXG4gIClcbn1cblxuZnVuY3Rpb24gaG1yUmVmcmVzaFJlZHVjZXJOb29wKFxuICBzdGF0ZTogUmVhZG9ubHlSZWR1Y2VyU3RhdGUsXG4gIF9hY3Rpb246IEhtclJlZnJlc2hBY3Rpb25cbik6IFJlZHVjZXJTdGF0ZSB7XG4gIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgaG1yUmVmcmVzaFJlZHVjZXIgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBobXJSZWZyZXNoUmVkdWNlck5vb3BcbiAgICA6IGhtclJlZnJlc2hSZWR1Y2VySW1wbFxuIl0sIm5hbWVzIjpbImhtclJlZnJlc2hSZWR1Y2VyIiwiaG1yUmVmcmVzaFJlZHVjZXJJbXBsIiwic3RhdGUiLCJhY3Rpb24iLCJvcmlnaW4iLCJtdXRhYmxlIiwiaHJlZiIsImNhbm9uaWNhbFVybCIsInByZXNlcnZlQ3VzdG9tSGlzdG9yeVN0YXRlIiwiY2FjaGUiLCJjcmVhdGVFbXB0eUNhY2hlTm9kZSIsImluY2x1ZGVOZXh0VXJsIiwiaGFzSW50ZXJjZXB0aW9uUm91dGVJbkN1cnJlbnRUcmVlIiwidHJlZSIsIm5hdmlnYXRlZEF0IiwiRGF0ZSIsIm5vdyIsImxhenlEYXRhIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImZsaWdodFJvdXRlclN0YXRlIiwibmV4dFVybCIsImlzSG1yUmVmcmVzaCIsInRoZW4iLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImN1cnJlbnRUcmVlIiwiY3VycmVudENhY2hlIiwibm9ybWFsaXplZEZsaWdodERhdGEiLCJ0cmVlUGF0Y2giLCJpc1Jvb3RSZW5kZXIiLCJjb25zb2xlIiwibG9nIiwibmV3VHJlZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsImhhbmRsZVNlZ21lbnRNaXNtYXRjaCIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiaGFuZGxlTXV0YWJsZSIsImhtclJlZnJlc2hSZWR1Y2VyTm9vcCIsIl9hY3Rpb24iLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js ***!
  \******************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This file is only used in app router due to the specific error state handling.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    onCaughtError: function() {\n        return onCaughtError;\n    },\n    onUncaughtError: function() {\n        return onUncaughtError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _isnextroutererror = __webpack_require__(/*! ../components/is-next-router-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _errorboundary = __webpack_require__(/*! ../components/error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _globalerror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../components/builtin/global-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/builtin/global-error.js\"));\nconst devToolErrorMod =  true ? __webpack_require__(/*! ../../next-devtools/userspace/app/errors */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/errors/index.js\") : 0;\nfunction onCaughtError(thrownValue, errorInfo) {\n    var _errorInfo_errorBoundary;\n    const errorBoundaryComponent = (_errorInfo_errorBoundary = errorInfo.errorBoundary) == null ? void 0 : _errorInfo_errorBoundary.constructor;\n    let isImplicitErrorBoundary;\n    if (true) {\n        const { AppDevOverlayErrorBoundary } = __webpack_require__(/*! ../../next-devtools/userspace/app/app-dev-overlay-error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js\");\n        isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;\n    }\n    isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler && errorInfo.errorBoundary.props.errorComponent === _globalerror.default;\n    // Skip the segment explorer triggered error\n    if (true) {\n        const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } = __webpack_require__(/*! ../../next-devtools/userspace/app/segment-explorer-node */ \"(app-pages-browser)/./node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js\");\n        if (thrownValue instanceof Error && thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {\n            return;\n        }\n    }\n    if (isImplicitErrorBoundary) {\n        // We don't consider errors caught unless they're caught by an explicit error\n        // boundary. The built-in ones are considered implicit.\n        // This mimics how the same app would behave without Next.js.\n        return onUncaughtError(thrownValue);\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        var _errorInfo_componentStack;\n        const errorBoundaryName = (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.displayName) || (errorBoundaryComponent == null ? void 0 : errorBoundaryComponent.name) || 'Unknown';\n        const componentThatErroredFrame = errorInfo == null ? void 0 : (_errorInfo_componentStack = errorInfo.componentStack) == null ? void 0 : _errorInfo_componentStack.split('\\n')[1];\n        var // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n        // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n        _componentThatErroredFrame_match;\n        // Match chrome or safari stack trace\n        const matches = (_componentThatErroredFrame_match = componentThatErroredFrame == null ? void 0 : componentThatErroredFrame.match(/\\s+at (\\w+)\\s+|(\\w+)@/)) != null ? _componentThatErroredFrame_match : [];\n        const componentThatErroredName = matches[1] || matches[2] || 'Unknown';\n        // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n        const errorBoundaryMessage = \"It was handled by the <\" + errorBoundaryName + \"> error boundary.\";\n        const componentErrorMessage = componentThatErroredName ? \"The above error occurred in the <\" + componentThatErroredName + \"> component.\" : \"The above error occurred in one of your components.\";\n        const errorLocation = componentErrorMessage + \" \" + errorBoundaryMessage;\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // Log and report the error with location but without modifying the error stack\n        devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation);\n        devToolErrorMod.handleClientError(error);\n    } else {}\n}\nfunction onUncaughtError(thrownValue) {\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (0, _isnextroutererror.isNextRouterError)(thrownValue)) return;\n    if (true) {\n        const error = devToolErrorMod.decorateDevError(thrownValue);\n        // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n        (0, _reportglobalerror.reportGlobalError)(error);\n    } else {}\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary-callbacks.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlGQUFpRjs7Ozs7Ozs7Ozs7OztJQWtCakVBLGFBQWE7ZUFBYkE7O0lBK0VBQyxlQUFlO2VBQWZBOzs7OytDQTlGa0I7MENBQ0U7K0NBQ0Y7MkNBQ0c7a0ZBQ0o7QUFFakMsTUFBTUMsa0JBQ0pDLEtBQW9CLEdBQ2ZHLG1CQUFPQSxDQUFDLDBJQUEwQyxJQUNuRCxDQUlDO0FBRUEsU0FBU04sY0FDZGEsV0FBb0IsRUFDcEJDLFNBQTBEO1FBRTNCQTtJQUEvQixNQUFNQyx5QkFBQUEsQ0FBeUJELDJCQUFBQSxVQUFVRSxhQUFBQSxLQUFhLGdCQUF2QkYseUJBQXlCRyxXQUFXO0lBRW5FLElBQUlDO0lBRUosSUFBSWYsSUFBb0IsRUFBbUI7UUFDekMsTUFBTSxFQUFFZ0IsMEJBQTBCLEVBQUUsR0FDbENiLG1CQUFPQSxDQUFDLG9MQUFrRTtRQUU1RVksMEJBQ0VILDJCQUEyQkk7SUFDL0I7SUFFQUQsMEJBQ0VBLDJCQUNDSCwyQkFBMkJLLGVBQUFBLG9CQUFvQixJQUM3Q04sVUFBVUUsYUFBYSxDQUNyQkssS0FBSyxDQUFDQyxjQUFjLEtBQUtDLGFBQUFBLE9BQW9CO0lBRXBELDRDQUE0QztJQUM1QyxJQUFJcEIsSUFBb0IsRUFBbUI7UUFDekMsTUFBTSxFQUFFcUIsd0NBQXdDLEVBQUUsR0FDaERsQixtQkFBT0EsQ0FBQyxrS0FBeUQ7UUFDbkUsSUFDRU8sdUJBQXVCWSxTQUN2QlosWUFBWWEsT0FBTyxLQUFLRiwwQ0FDeEI7WUFDQTtRQUNGO0lBQ0Y7SUFFQSxJQUFJTix5QkFBeUI7UUFDM0IsNkVBQTZFO1FBQzdFLHVEQUF1RDtRQUN2RCw2REFBNkQ7UUFDN0QsT0FBT2pCLGdCQUFnQlk7SUFDekI7SUFFQSw2RUFBNkU7SUFDN0UsSUFBSWMsQ0FBQUEsR0FBQUEsY0FBQUEsbUJBQUFBLEVBQW9CZCxnQkFBZ0JlLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBaUIsRUFBQ2YsY0FBYztJQUV4RSxJQUFJVixJQUFvQixFQUFtQjtZQU9QVztRQU5sQyxNQUFNZSxvQkFFSixDQURBLDBCQUNDZCxPQUFBQSxFQURrQyxHQUNsQ0EsSUFBQUEsdUJBQWdDZSxXQUFBQSxNQUNqQ2YsMEJBQUFBLE9BQUFBLEtBQUFBLElBQUFBLHVCQUF3QmdCLElBQUFBLEtBQ3hCO1FBRUYsTUFBTUMsNEJBQTRCbEIsYUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsNkJBQUFBLFVBQVdtQixjQUFBQSxLQUFjLGdCQUF6Qm5CLDBCQUEyQm9CLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUl6RSxzREFBc0QsK0NBQytDO1FBQ3JHLGdHQUFnRztRQUNoR0Y7UUFMRixxQ0FBcUM7UUFDckMsTUFBTUcsVUFJSkgsQ0FBQUEsbUNBQUFBLDZCQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSwwQkFBMkJJLEtBQUssQ0FBQyxvQ0FBakNKLG1DQUE2RCxFQUFFO1FBQ2pFLE1BQU1LLDJCQUEyQkYsT0FBTyxDQUFDLEVBQUUsSUFBSUEsT0FBTyxDQUFDLEVBQUUsSUFBSTtRQUU3RCxpSUFBaUk7UUFDakksTUFBTUcsdUJBQXdCLDRCQUF5QlQsb0JBQWtCO1FBQ3pFLE1BQU1VLHdCQUF3QkYsMkJBQ3pCLHNDQUFtQ0EsMkJBQXlCLGlCQUM1RDtRQUVMLE1BQU1HLGdCQUFtQkQsd0JBQXNCLE1BQUdEO1FBQ2xELE1BQU05QixRQUFRTixnQkFBZ0JLLGdCQUFnQixDQUFDTTtRQUUvQywrRUFBK0U7UUFDL0VYLGdCQUFnQlEsa0JBQWtCLENBQUMsWUFBWUcsYUFBYTJCO1FBRTVEdEMsZ0JBQWdCTyxpQkFBaUIsQ0FBQ0Q7SUFDcEMsT0FBTyxFQUVOO0FBQ0g7QUFFTyxTQUFTUCxnQkFBZ0JZLFdBQW9CO0lBQ2xELDZFQUE2RTtJQUM3RSxJQUFJYyxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBQUEsRUFBb0JkLGdCQUFnQmUsQ0FBQUEsR0FBQUEsbUJBQUFBLGlCQUFBQSxFQUFrQmYsY0FBYztJQUV4RSxJQUFJVixJQUFvQixFQUFtQjtRQUN6QyxNQUFNSyxRQUFRTixnQkFBZ0JLLGdCQUFnQixDQUFDTTtRQUUvQyxvRkFBb0Y7UUFDcEY0QixDQUFBQSxHQUFBQSxtQkFBQUEsaUJBQUFBLEVBQWtCakM7SUFDcEIsT0FBTyxFQUVOO0FBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWNtaW5pL0RvY3VtZW50cy9Qcm9qZWN0cy9zcmMvY2xpZW50L3JlYWN0LWNsaWVudC1jYWxsYmFja3MvZXJyb3ItYm91bmRhcnktY2FsbGJhY2tzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBpcyBvbmx5IHVzZWQgaW4gYXBwIHJvdXRlciBkdWUgdG8gdGhlIHNwZWNpZmljIGVycm9yIHN0YXRlIGhhbmRsaW5nLlxuXG5pbXBvcnQgdHlwZSB7IEVycm9ySW5mbyB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaXNOZXh0Um91dGVyRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuaW1wb3J0IHsgaXNCYWlsb3V0VG9DU1JFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2JhaWxvdXQtdG8tY3NyJ1xuaW1wb3J0IHsgcmVwb3J0R2xvYmFsRXJyb3IgfSBmcm9tICcuL3JlcG9ydC1nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBFcnJvckJvdW5kYXJ5SGFuZGxlciB9IGZyb20gJy4uL2NvbXBvbmVudHMvZXJyb3ItYm91bmRhcnknXG5pbXBvcnQgRGVmYXVsdEVycm9yQm91bmRhcnkgZnJvbSAnLi4vY29tcG9uZW50cy9idWlsdGluL2dsb2JhbC1lcnJvcidcblxuY29uc3QgZGV2VG9vbEVycm9yTW9kOiB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvZXJyb3JzJykgPVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyAocmVxdWlyZSgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL2Vycm9ycycpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9lcnJvcnMnKSlcbiAgICA6IHtcbiAgICAgICAgZGVjb3JhdGVEZXZFcnJvcjogKGVycm9yOiB1bmtub3duKSA9PiBlcnJvciBhcyBFcnJvcixcbiAgICAgICAgaGFuZGxlQ2xpZW50RXJyb3I6ICgpID0+IHt9LFxuICAgICAgICBvcmlnaW5Db25zb2xlRXJyb3I6IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxcbiAgICAgIH1cblxuZXhwb3J0IGZ1bmN0aW9uIG9uQ2F1Z2h0RXJyb3IoXG4gIHRocm93blZhbHVlOiB1bmtub3duLFxuICBlcnJvckluZm86IEVycm9ySW5mbyAmIHsgZXJyb3JCb3VuZGFyeT86IFJlYWN0LkNvbXBvbmVudCB9XG4pIHtcbiAgY29uc3QgZXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9IGVycm9ySW5mby5lcnJvckJvdW5kYXJ5Py5jb25zdHJ1Y3RvclxuXG4gIGxldCBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgeyBBcHBEZXZPdmVybGF5RXJyb3JCb3VuZGFyeSB9ID1cbiAgICAgIHJlcXVpcmUoJy4uLy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL2FwcC9hcHAtZGV2LW92ZXJsYXktZXJyb3ItYm91bmRhcnknKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvYXBwLWRldi1vdmVybGF5LWVycm9yLWJvdW5kYXJ5JylcblxuICAgIGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5ID1cbiAgICAgIGVycm9yQm91bmRhcnlDb21wb25lbnQgPT09IEFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5XG4gIH1cblxuICBpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSA9XG4gICAgaXNJbXBsaWNpdEVycm9yQm91bmRhcnkgfHxcbiAgICAoZXJyb3JCb3VuZGFyeUNvbXBvbmVudCA9PT0gRXJyb3JCb3VuZGFyeUhhbmRsZXIgJiZcbiAgICAgIChlcnJvckluZm8uZXJyb3JCb3VuZGFyeSEgYXMgSW5zdGFuY2VUeXBlPHR5cGVvZiBFcnJvckJvdW5kYXJ5SGFuZGxlcj4pXG4gICAgICAgIC5wcm9wcy5lcnJvckNvbXBvbmVudCA9PT0gRGVmYXVsdEVycm9yQm91bmRhcnkpXG5cbiAgLy8gU2tpcCB0aGUgc2VnbWVudCBleHBsb3JlciB0cmlnZ2VyZWQgZXJyb3JcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCB7IFNFR01FTlRfRVhQTE9SRVJfU0lNVUxBVEVEX0VSUk9SX01FU1NBR0UgfSA9XG4gICAgICByZXF1aXJlKCcuLi8uLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9hcHAvc2VnbWVudC1leHBsb3Jlci1ub2RlJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vLi4vbmV4dC1kZXZ0b29scy91c2Vyc3BhY2UvYXBwL3NlZ21lbnQtZXhwbG9yZXItbm9kZScpXG4gICAgaWYgKFxuICAgICAgdGhyb3duVmFsdWUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgdGhyb3duVmFsdWUubWVzc2FnZSA9PT0gU0VHTUVOVF9FWFBMT1JFUl9TSU1VTEFURURfRVJST1JfTUVTU0FHRVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzSW1wbGljaXRFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gV2UgZG9uJ3QgY29uc2lkZXIgZXJyb3JzIGNhdWdodCB1bmxlc3MgdGhleSdyZSBjYXVnaHQgYnkgYW4gZXhwbGljaXQgZXJyb3JcbiAgICAvLyBib3VuZGFyeS4gVGhlIGJ1aWx0LWluIG9uZXMgYXJlIGNvbnNpZGVyZWQgaW1wbGljaXQuXG4gICAgLy8gVGhpcyBtaW1pY3MgaG93IHRoZSBzYW1lIGFwcCB3b3VsZCBiZWhhdmUgd2l0aG91dCBOZXh0LmpzLlxuICAgIHJldHVybiBvblVuY2F1Z2h0RXJyb3IodGhyb3duVmFsdWUpXG4gIH1cblxuICAvLyBTa2lwIGNlcnRhaW4gY3VzdG9tIGVycm9ycyB3aGljaCBhcmUgbm90IGV4cGVjdGVkIHRvIGJlIHJlcG9ydGVkIG9uIGNsaWVudFxuICBpZiAoaXNCYWlsb3V0VG9DU1JFcnJvcih0aHJvd25WYWx1ZSkgfHwgaXNOZXh0Um91dGVyRXJyb3IodGhyb3duVmFsdWUpKSByZXR1cm5cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbnN0IGVycm9yQm91bmRhcnlOYW1lID1cbiAgICAgIC8vIHJlYWQgcmVhY3QgY29tcG9uZW50IGRpc3BsYXlOYW1lXG4gICAgICAoZXJyb3JCb3VuZGFyeUNvbXBvbmVudCBhcyBhbnkpPy5kaXNwbGF5TmFtZSB8fFxuICAgICAgZXJyb3JCb3VuZGFyeUNvbXBvbmVudD8ubmFtZSB8fFxuICAgICAgJ1Vua25vd24nXG5cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lID0gZXJyb3JJbmZvPy5jb21wb25lbnRTdGFjaz8uc3BsaXQoJ1xcbicpWzFdXG5cbiAgICAvLyBNYXRjaCBjaHJvbWUgb3Igc2FmYXJpIHN0YWNrIHRyYWNlXG4gICAgY29uc3QgbWF0Y2hlcyA9XG4gICAgICAvLyByZWdleCB0byBtYXRjaCB0aGUgZnVuY3Rpb24gbmFtZSBpbiB0aGUgc3RhY2sgdHJhY2VcbiAgICAgIC8vIGV4YW1wbGUgMTogYXQgUGFnZSAoaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjEpXG4gICAgICAvLyBleGFtcGxlIDI6IFBhZ2VAaHR0cDovL2xvY2FsaG9zdDozMDAwL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMvaW5kZXguanM/dHM9MTYzMTYwMDAwMDAwMDoyOjFcbiAgICAgIGNvbXBvbmVudFRoYXRFcnJvcmVkRnJhbWU/Lm1hdGNoKC9cXHMrYXQgKFxcdyspXFxzK3woXFx3KylALykgPz8gW11cbiAgICBjb25zdCBjb21wb25lbnRUaGF0RXJyb3JlZE5hbWUgPSBtYXRjaGVzWzFdIHx8IG1hdGNoZXNbMl0gfHwgJ1Vua25vd24nXG5cbiAgICAvLyBDcmVhdGUgZXJyb3IgbG9jYXRpb24gd2l0aCBlcnJvcmVkIGNvbXBvbmVudCBhbmQgZXJyb3IgYm91bmRhcnksIHRvIG1hdGNoIHRoZSBiZWhhdmlvciBvZiBkZWZhdWx0IFJlYWN0IG9uQ2F1Z2h0RXJyb3IgaGFuZGxlci5cbiAgICBjb25zdCBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IGBJdCB3YXMgaGFuZGxlZCBieSB0aGUgPCR7ZXJyb3JCb3VuZGFyeU5hbWV9PiBlcnJvciBib3VuZGFyeS5gXG4gICAgY29uc3QgY29tcG9uZW50RXJyb3JNZXNzYWdlID0gY29tcG9uZW50VGhhdEVycm9yZWROYW1lXG4gICAgICA/IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwke2NvbXBvbmVudFRoYXRFcnJvcmVkTmFtZX0+IGNvbXBvbmVudC5gXG4gICAgICA6IGBUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgY29tcG9uZW50cy5gXG5cbiAgICBjb25zdCBlcnJvckxvY2F0aW9uID0gYCR7Y29tcG9uZW50RXJyb3JNZXNzYWdlfSAke2Vycm9yQm91bmRhcnlNZXNzYWdlfWBcbiAgICBjb25zdCBlcnJvciA9IGRldlRvb2xFcnJvck1vZC5kZWNvcmF0ZURldkVycm9yKHRocm93blZhbHVlKVxuXG4gICAgLy8gTG9nIGFuZCByZXBvcnQgdGhlIGVycm9yIHdpdGggbG9jYXRpb24gYnV0IHdpdGhvdXQgbW9kaWZ5aW5nIHRoZSBlcnJvciBzdGFja1xuICAgIGRldlRvb2xFcnJvck1vZC5vcmlnaW5Db25zb2xlRXJyb3IoJyVvXFxuXFxuJXMnLCB0aHJvd25WYWx1ZSwgZXJyb3JMb2NhdGlvbilcblxuICAgIGRldlRvb2xFcnJvck1vZC5oYW5kbGVDbGllbnRFcnJvcihlcnJvcilcbiAgfSBlbHNlIHtcbiAgICBkZXZUb29sRXJyb3JNb2Qub3JpZ2luQ29uc29sZUVycm9yKHRocm93blZhbHVlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IodGhyb3duVmFsdWU6IHVua25vd24pIHtcbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IodGhyb3duVmFsdWUpIHx8IGlzTmV4dFJvdXRlckVycm9yKHRocm93blZhbHVlKSkgcmV0dXJuXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBlcnJvciA9IGRldlRvb2xFcnJvck1vZC5kZWNvcmF0ZURldkVycm9yKHRocm93blZhbHVlKVxuXG4gICAgLy8gVE9ETzogQWRkIGFuIGFkZW5kdW0gdG8gdGhlIG92ZXJsYXkgdGVsbGluZyBwZW9wbGUgYWJvdXQgY3VzdG9tIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgcmVwb3J0R2xvYmFsRXJyb3IodGhyb3duVmFsdWUpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJvbkNhdWdodEVycm9yIiwib25VbmNhdWdodEVycm9yIiwiZGV2VG9vbEVycm9yTW9kIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwicmVxdWlyZSIsImRlY29yYXRlRGV2RXJyb3IiLCJlcnJvciIsImhhbmRsZUNsaWVudEVycm9yIiwib3JpZ2luQ29uc29sZUVycm9yIiwiY29uc29sZSIsImJpbmQiLCJ0aHJvd25WYWx1ZSIsImVycm9ySW5mbyIsImVycm9yQm91bmRhcnlDb21wb25lbnQiLCJlcnJvckJvdW5kYXJ5IiwiY29uc3RydWN0b3IiLCJpc0ltcGxpY2l0RXJyb3JCb3VuZGFyeSIsIkFwcERldk92ZXJsYXlFcnJvckJvdW5kYXJ5IiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJwcm9wcyIsImVycm9yQ29tcG9uZW50IiwiRGVmYXVsdEVycm9yQm91bmRhcnkiLCJTRUdNRU5UX0VYUExPUkVSX1NJTVVMQVRFRF9FUlJPUl9NRVNTQUdFIiwiRXJyb3IiLCJtZXNzYWdlIiwiaXNCYWlsb3V0VG9DU1JFcnJvciIsImlzTmV4dFJvdXRlckVycm9yIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJjb21wb25lbnRUaGF0RXJyb3JlZEZyYW1lIiwiY29tcG9uZW50U3RhY2siLCJzcGxpdCIsIm1hdGNoZXMiLCJtYXRjaCIsImNvbXBvbmVudFRoYXRFcnJvcmVkTmFtZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tcG9uZW50RXJyb3JNZXNzYWdlIiwiZXJyb3JMb2NhdGlvbiIsInJlcG9ydEdsb2JhbEVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/route-params.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-params.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    doesStaticSegmentAppearInURL: function() {\n        return doesStaticSegmentAppearInURL;\n    },\n    getCacheKeyForDynamicParam: function() {\n        return getCacheKeyForDynamicParam;\n    },\n    getParamValueFromCacheKey: function() {\n        return getParamValueFromCacheKey;\n    },\n    getRenderedPathname: function() {\n        return getRenderedPathname;\n    },\n    getRenderedSearch: function() {\n        return getRenderedSearch;\n    },\n    parseDynamicParamFromURLPart: function() {\n        return parseDynamicParamFromURLPart;\n    },\n    urlToUrlWithoutFlightMarker: function() {\n        return urlToUrlWithoutFlightMarker;\n    }\n});\nconst _segment = __webpack_require__(/*! ../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _segmentvalueencoding = __webpack_require__(/*! ../shared/lib/segment-cache/segment-value-encoding */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js\");\nconst _approuterheaders = __webpack_require__(/*! ./components/app-router-headers */ \"(app-pages-browser)/./node_modules/next/dist/client/components/app-router-headers.js\");\nfunction getRenderedSearch(response) {\n    // If the server performed a rewrite, the search params used to render the\n    // page will be different from the params in the request URL. In this case,\n    // the response will include a header that gives the rewritten search query.\n    const rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);\n    if (rewrittenQuery !== null) {\n        return rewrittenQuery === '' ? '' : '?' + rewrittenQuery;\n    }\n    // If the header is not present, there was no rewrite, so we use the search\n    // query of the response URL.\n    return urlToUrlWithoutFlightMarker(new URL(response.url)).search;\n}\nfunction getRenderedPathname(response) {\n    // If the server performed a rewrite, the pathname used to render the\n    // page will be different from the pathname in the request URL. In this case,\n    // the response will include a header that gives the rewritten pathname.\n    const rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);\n    return rewrittenPath != null ? rewrittenPath : urlToUrlWithoutFlightMarker(new URL(response.url)).pathname;\n}\nfunction parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {\n    // This needs to match the behavior in get-dynamic-param.ts.\n    switch(paramType){\n        // Catchalls\n        case 'c':\n        case 'ci':\n            {\n                // Catchalls receive all the remaining URL parts. If there are no\n                // remaining pathname parts, return an empty array.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : [];\n            }\n        // Optional catchalls\n        case 'oc':\n            {\n                // Optional catchalls receive all the remaining URL parts, unless this is\n                // the end of the pathname, in which case they return null.\n                return partIndex < pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=>encodeURIComponent(s)) : null;\n            }\n        // Dynamic\n        case 'd':\n        case 'di':\n            {\n                if (partIndex >= pathnameParts.length) {\n                    // The route tree expected there to be more parts in the URL than there\n                    // actually are. This could happen if the x-nextjs-rewritten-path header\n                    // is incorrectly set, or potentially due to bug in Next.js. TODO:\n                    // Should this be a hard error? During a prefetch, we can just abort.\n                    // During a client navigation, we could trigger a hard refresh. But if\n                    // it happens during initial render, we don't really have any\n                    // recovery options.\n                    return '';\n                }\n                return encodeURIComponent(pathnameParts[partIndex]);\n            }\n        default:\n            paramType;\n            return '';\n    }\n}\nfunction doesStaticSegmentAppearInURL(segment) {\n    // This is not a parameterized segment; however, we need to determine\n    // whether or not this segment appears in the URL. For example, this route\n    // groups do not appear in the URL, so they should be skipped. Any other\n    // special cases must be handled here.\n    // TODO: Consider encoding this directly into the router tree instead of\n    // inferring it on the client based on the segment type. Something like\n    // a `doesAppearInURL` flag in FlightRouterState.\n    if (segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(_segment.PAGE_SEGMENT_KEY) || // Route groups.\n    segment[0] === '(' && segment.endsWith(')') || segment === _segment.DEFAULT_SEGMENT_KEY || segment === '/_not-found') {\n        return false;\n    } else {\n        // All other segment types appear in the URL\n        return true;\n    }\n}\nfunction getCacheKeyForDynamicParam(paramValue, renderedSearch) {\n    // This needs to match the logic in get-dynamic-param.ts, until we're able to\n    // unify the various implementations so that these are always computed on\n    // the client.\n    if (typeof paramValue === 'string') {\n        // TODO: Refactor or remove this helper function to accept a string rather\n        // than the whole segment type. Also we can probably just append the\n        // search string instead of turning it into JSON.\n        const pageSegmentWithSearchParams = (0, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(new URLSearchParams(renderedSearch)));\n        return pageSegmentWithSearchParams;\n    } else if (paramValue === null) {\n        return '';\n    } else {\n        return paramValue.join('/');\n    }\n}\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url);\n    urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);\n    if (false) {}\n    return urlWithoutFlightParameters;\n}\nfunction getParamValueFromCacheKey(paramCacheKey, paramType) {\n    // Turn the cache key string sent by the server (as part of FlightRouterState)\n    // into a value that can be passed to `useParams` and client components.\n    const isCatchAll = paramType === 'c' || paramType === 'oc';\n    if (isCatchAll) {\n        // Catch-all param keys are a concatenation of the path segments.\n        // See equivalent logic in `getSelectedParams`.\n        // TODO: We should just pass the array directly, rather than concatenate\n        // it to a string and then split it back to an array. It needs to be an\n        // array in some places, like when passing a key React, but we can convert\n        // it at runtime in those places.\n        return paramCacheKey.split('/');\n    }\n    return paramCacheKey;\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-params.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLXBhcmFtcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUE4RmdCQSw0QkFBNEI7ZUFBNUJBOztJQTRCQUMsMEJBQTBCO2VBQTFCQTs7SUF3Q0FDLHlCQUF5QjtlQUF6QkE7O0lBM0hBQyxtQkFBbUI7ZUFBbkJBOztJQWhCQUMsaUJBQWlCO2VBQWpCQTs7SUEwQkFDLDRCQUE0QjtlQUE1QkE7O0lBZ0dBQywyQkFBMkI7ZUFBM0JBOzs7cUNBNUlUO2tEQUNrQzs4Q0FLbEM7QUFZQSxTQUFTRixrQkFBa0JHLFFBQXFCO0lBQ3JELDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0UsNEVBQTRFO0lBQzVFLE1BQU1DLGlCQUFpQkQsU0FBU0UsT0FBTyxDQUFDQyxHQUFHLENBQUNDLGtCQUFBQSwyQkFBMkI7SUFDdkUsSUFBSUgsbUJBQW1CLE1BQU07UUFDM0IsT0FDRUEsbUJBQW1CLEtBQUssS0FBSyxNQUFNQTtJQUV2QztJQUNBLDJFQUEyRTtJQUMzRSw2QkFBNkI7SUFDN0IsT0FBT0YsNEJBQTRCLElBQUlNLElBQUlMLFNBQVNNLEdBQUcsR0FDcERDLE1BQU07QUFDWDtBQUVPLFNBQVNYLG9CQUFvQkksUUFBcUI7SUFDdkQscUVBQXFFO0lBQ3JFLDZFQUE2RTtJQUM3RSx3RUFBd0U7SUFDeEUsTUFBTVEsZ0JBQWdCUixTQUFTRSxPQUFPLENBQUNDLEdBQUcsQ0FBQ00sa0JBQUFBLDBCQUEwQjtJQUNyRSxPQUNFRCxpQkFBQUEsT0FBQUEsZ0JBQWlCVCw0QkFBNEIsSUFBSU0sSUFBSUwsU0FBU00sR0FBRyxHQUFHSSxRQUFRO0FBRWhGO0FBRU8sU0FBU1osNkJBQ2RhLFNBQWlDLEVBQ2pDQyxhQUE0QixFQUM1QkMsU0FBaUI7SUFFakIsNERBQTREO0lBQzVELE9BQVFGO1FBQ04sWUFBWTtRQUNaLEtBQUs7UUFDTCxLQUFLO1lBQU07Z0JBQ1QsaUVBQWlFO2dCQUNqRSxtREFBbUQ7Z0JBQ25ELE9BQU9FLFlBQVlELGNBQWNFLE1BQU0sR0FDbkNGLGNBQWNHLEtBQUssQ0FBQ0YsV0FBV0csR0FBRyxDQUFDLENBQUNDLElBQU1DLG1CQUFtQkQsTUFDN0QsRUFBRTtZQUNSO1FBQ0EscUJBQXFCO1FBQ3JCLEtBQUs7WUFBTTtnQkFDVCx5RUFBeUU7Z0JBQ3pFLDJEQUEyRDtnQkFDM0QsT0FBT0osWUFBWUQsY0FBY0UsTUFBTSxHQUNuQ0YsY0FBY0csS0FBSyxDQUFDRixXQUFXRyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUMsbUJBQW1CRCxNQUM3RDtZQUNOO1FBQ0EsVUFBVTtRQUNWLEtBQUs7UUFDTCxLQUFLO1lBQU07Z0JBQ1QsSUFBSUosYUFBYUQsY0FBY0UsTUFBTSxFQUFFO29CQUNyQyx1RUFBdUU7b0JBQ3ZFLHdFQUF3RTtvQkFDeEUsa0VBQWtFO29CQUNsRSxxRUFBcUU7b0JBQ3JFLHNFQUFzRTtvQkFDdEUsNkRBQTZEO29CQUM3RCxvQkFBb0I7b0JBQ3BCLE9BQU87Z0JBQ1Q7Z0JBQ0EsT0FBT0ksbUJBQW1CTixhQUFhLENBQUNDLFVBQVU7WUFDcEQ7UUFDQTtZQUNFRjtZQUNBLE9BQU87SUFDWDtBQUNGO0FBRU8sU0FBU2xCLDZCQUE2QjBCLE9BQWU7SUFDMUQscUVBQXFFO0lBQ3JFLDBFQUEwRTtJQUMxRSx3RUFBd0U7SUFDeEUsc0NBQXNDO0lBQ3RDLHdFQUF3RTtJQUN4RSx1RUFBdUU7SUFDdkUsaURBQWlEO0lBQ2pELElBQ0VBLFlBQVlDLHNCQUFBQSx3QkFBd0IsSUFDcEMscUVBQXFFO0lBQ3JFLHFFQUFxRTtJQUNyRSxrRUFBa0U7SUFDbEUscUJBQXFCO0lBQ3JCLHNFQUFzRTtJQUN0RUQsUUFBUUUsVUFBVSxDQUFDQyxTQUFBQSxnQkFBZ0IsS0FDbkMsZ0JBQWdCO0lBQ2ZILE9BQU8sQ0FBQyxFQUFFLEtBQUssT0FBT0EsUUFBUUksUUFBUSxDQUFDLFFBQ3hDSixZQUFZSyxTQUFBQSxtQkFBbUIsSUFDL0JMLFlBQVksZUFDWjtRQUNBLE9BQU87SUFDVCxPQUFPO1FBQ0wsNENBQTRDO1FBQzVDLE9BQU87SUFDVDtBQUNGO0FBRU8sU0FBU3pCLDJCQUNkK0IsVUFBMkIsRUFDM0JDLGNBQWdDO0lBRWhDLDZFQUE2RTtJQUM3RSx5RUFBeUU7SUFDekUsY0FBYztJQUNkLElBQUksT0FBT0QsZUFBZSxVQUFVO1FBQ2xDLDBFQUEwRTtRQUMxRSxvRUFBb0U7UUFDcEUsaURBQWlEO1FBQ2pELE1BQU1FLDhCQUE4QkMsQ0FBQUEsR0FBQUEsU0FBQUEsNEJBQUFBLEVBQ2xDSCxZQUNBSSxPQUFPQyxXQUFXLENBQUMsSUFBSUMsZ0JBQWdCTDtRQUV6QyxPQUFPQztJQUNULE9BQU8sSUFBSUYsZUFBZSxNQUFNO1FBQzlCLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBT0EsV0FBV08sSUFBSSxDQUFDO0lBQ3pCO0FBQ0Y7QUFFTyxTQUFTakMsNEJBQTRCTyxHQUFRO0lBQ2xELE1BQU0yQiw2QkFBNkIsSUFBSTVCLElBQUlDO0lBQzNDMkIsMkJBQTJCQyxZQUFZLENBQUNDLE1BQU0sQ0FBQ0Msa0JBQUFBLG9CQUFvQjtJQUNuRSxJQUFJQyxLQUFvQixFQUFtQixFQVUxQztJQUNELE9BQU9KO0FBQ1Q7QUFFTyxTQUFTdEMsMEJBQ2Q4QyxhQUFxQixFQUNyQjlCLFNBQWlDO0lBRWpDLDhFQUE4RTtJQUM5RSx3RUFBd0U7SUFDeEUsTUFBTStCLGFBQWEvQixjQUFjLE9BQU9BLGNBQWM7SUFDdEQsSUFBSStCLFlBQVk7UUFDZCxpRUFBaUU7UUFDakUsK0NBQStDO1FBQy9DLHdFQUF3RTtRQUN4RSx1RUFBdUU7UUFDdkUsMEVBQTBFO1FBQzFFLGlDQUFpQztRQUNqQyxPQUFPRCxjQUFjRSxLQUFLLENBQUM7SUFDN0I7SUFDQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvbWFjbWluaS9Eb2N1bWVudHMvUHJvamVjdHMvU2FhUyBGYWN0b3J5L3NyYy9jbGllbnQvcm91dGUtcGFyYW1zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgRHluYW1pY1BhcmFtVHlwZXNTaG9ydCB9IGZyb20gJy4uL3NlcnZlci9hcHAtcmVuZGVyL3R5cGVzJ1xuaW1wb3J0IHtcbiAgYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCxcbiAgREVGQVVMVF9TRUdNRU5UX0tFWSxcbiAgUEFHRV9TRUdNRU5UX0tFWSxcbn0gZnJvbSAnLi4vc2hhcmVkL2xpYi9zZWdtZW50J1xuaW1wb3J0IHsgUk9PVF9TRUdNRU5UX1JFUVVFU1RfS0VZIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9zZWdtZW50LWNhY2hlL3NlZ21lbnQtdmFsdWUtZW5jb2RpbmcnXG5pbXBvcnQge1xuICBORVhUX1JFV1JJVFRFTl9QQVRIX0hFQURFUixcbiAgTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSLFxuICBORVhUX1JTQ19VTklPTl9RVUVSWSxcbn0gZnJvbSAnLi9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycydcbmltcG9ydCB0eXBlIHsgTm9ybWFsaXplZFNlYXJjaCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWdtZW50LWNhY2hlJ1xuaW1wb3J0IHR5cGUgeyBSU0NSZXNwb25zZSB9IGZyb20gJy4vY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UnXG5cbmV4cG9ydCB0eXBlIFJvdXRlUGFyYW1WYWx1ZSA9IHN0cmluZyB8IEFycmF5PHN0cmluZz4gfCBudWxsXG5cbmV4cG9ydCB0eXBlIFJvdXRlUGFyYW0gPSB7XG4gIG5hbWU6IHN0cmluZ1xuICB2YWx1ZTogUm91dGVQYXJhbVZhbHVlXG4gIHR5cGU6IER5bmFtaWNQYXJhbVR5cGVzU2hvcnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbmRlcmVkU2VhcmNoKHJlc3BvbnNlOiBSU0NSZXNwb25zZSk6IE5vcm1hbGl6ZWRTZWFyY2gge1xuICAvLyBJZiB0aGUgc2VydmVyIHBlcmZvcm1lZCBhIHJld3JpdGUsIHRoZSBzZWFyY2ggcGFyYW1zIHVzZWQgdG8gcmVuZGVyIHRoZVxuICAvLyBwYWdlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHBhcmFtcyBpbiB0aGUgcmVxdWVzdCBVUkwuIEluIHRoaXMgY2FzZSxcbiAgLy8gdGhlIHJlc3BvbnNlIHdpbGwgaW5jbHVkZSBhIGhlYWRlciB0aGF0IGdpdmVzIHRoZSByZXdyaXR0ZW4gc2VhcmNoIHF1ZXJ5LlxuICBjb25zdCByZXdyaXR0ZW5RdWVyeSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfUkVXUklUVEVOX1FVRVJZX0hFQURFUilcbiAgaWYgKHJld3JpdHRlblF1ZXJ5ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHJld3JpdHRlblF1ZXJ5ID09PSAnJyA/ICcnIDogJz8nICsgcmV3cml0dGVuUXVlcnlcbiAgICApIGFzIE5vcm1hbGl6ZWRTZWFyY2hcbiAgfVxuICAvLyBJZiB0aGUgaGVhZGVyIGlzIG5vdCBwcmVzZW50LCB0aGVyZSB3YXMgbm8gcmV3cml0ZSwgc28gd2UgdXNlIHRoZSBzZWFyY2hcbiAgLy8gcXVlcnkgb2YgdGhlIHJlc3BvbnNlIFVSTC5cbiAgcmV0dXJuIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcihuZXcgVVJMKHJlc3BvbnNlLnVybCkpXG4gICAgLnNlYXJjaCBhcyBOb3JtYWxpemVkU2VhcmNoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW5kZXJlZFBhdGhuYW1lKHJlc3BvbnNlOiBSU0NSZXNwb25zZSk6IHN0cmluZyB7XG4gIC8vIElmIHRoZSBzZXJ2ZXIgcGVyZm9ybWVkIGEgcmV3cml0ZSwgdGhlIHBhdGhuYW1lIHVzZWQgdG8gcmVuZGVyIHRoZVxuICAvLyBwYWdlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHBhdGhuYW1lIGluIHRoZSByZXF1ZXN0IFVSTC4gSW4gdGhpcyBjYXNlLFxuICAvLyB0aGUgcmVzcG9uc2Ugd2lsbCBpbmNsdWRlIGEgaGVhZGVyIHRoYXQgZ2l2ZXMgdGhlIHJld3JpdHRlbiBwYXRobmFtZS5cbiAgY29uc3QgcmV3cml0dGVuUGF0aCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KE5FWFRfUkVXUklUVEVOX1BBVEhfSEVBREVSKVxuICByZXR1cm4gKFxuICAgIHJld3JpdHRlblBhdGggPz8gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKG5ldyBVUkwocmVzcG9uc2UudXJsKSkucGF0aG5hbWVcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEeW5hbWljUGFyYW1Gcm9tVVJMUGFydChcbiAgcGFyYW1UeXBlOiBEeW5hbWljUGFyYW1UeXBlc1Nob3J0LFxuICBwYXRobmFtZVBhcnRzOiBBcnJheTxzdHJpbmc+LFxuICBwYXJ0SW5kZXg6IG51bWJlclxuKTogUm91dGVQYXJhbVZhbHVlIHtcbiAgLy8gVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gZ2V0LWR5bmFtaWMtcGFyYW0udHMuXG4gIHN3aXRjaCAocGFyYW1UeXBlKSB7XG4gICAgLy8gQ2F0Y2hhbGxzXG4gICAgY2FzZSAnYyc6XG4gICAgY2FzZSAnY2knOiB7XG4gICAgICAvLyBDYXRjaGFsbHMgcmVjZWl2ZSBhbGwgdGhlIHJlbWFpbmluZyBVUkwgcGFydHMuIElmIHRoZXJlIGFyZSBub1xuICAgICAgLy8gcmVtYWluaW5nIHBhdGhuYW1lIHBhcnRzLCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gICAgICByZXR1cm4gcGFydEluZGV4IDwgcGF0aG5hbWVQYXJ0cy5sZW5ndGhcbiAgICAgICAgPyBwYXRobmFtZVBhcnRzLnNsaWNlKHBhcnRJbmRleCkubWFwKChzKSA9PiBlbmNvZGVVUklDb21wb25lbnQocykpXG4gICAgICAgIDogW11cbiAgICB9XG4gICAgLy8gT3B0aW9uYWwgY2F0Y2hhbGxzXG4gICAgY2FzZSAnb2MnOiB7XG4gICAgICAvLyBPcHRpb25hbCBjYXRjaGFsbHMgcmVjZWl2ZSBhbGwgdGhlIHJlbWFpbmluZyBVUkwgcGFydHMsIHVubGVzcyB0aGlzIGlzXG4gICAgICAvLyB0aGUgZW5kIG9mIHRoZSBwYXRobmFtZSwgaW4gd2hpY2ggY2FzZSB0aGV5IHJldHVybiBudWxsLlxuICAgICAgcmV0dXJuIHBhcnRJbmRleCA8IHBhdGhuYW1lUGFydHMubGVuZ3RoXG4gICAgICAgID8gcGF0aG5hbWVQYXJ0cy5zbGljZShwYXJ0SW5kZXgpLm1hcCgocykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHMpKVxuICAgICAgICA6IG51bGxcbiAgICB9XG4gICAgLy8gRHluYW1pY1xuICAgIGNhc2UgJ2QnOlxuICAgIGNhc2UgJ2RpJzoge1xuICAgICAgaWYgKHBhcnRJbmRleCA+PSBwYXRobmFtZVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBUaGUgcm91dGUgdHJlZSBleHBlY3RlZCB0aGVyZSB0byBiZSBtb3JlIHBhcnRzIGluIHRoZSBVUkwgdGhhbiB0aGVyZVxuICAgICAgICAvLyBhY3R1YWxseSBhcmUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHRoZSB4LW5leHRqcy1yZXdyaXR0ZW4tcGF0aCBoZWFkZXJcbiAgICAgICAgLy8gaXMgaW5jb3JyZWN0bHkgc2V0LCBvciBwb3RlbnRpYWxseSBkdWUgdG8gYnVnIGluIE5leHQuanMuIFRPRE86XG4gICAgICAgIC8vIFNob3VsZCB0aGlzIGJlIGEgaGFyZCBlcnJvcj8gRHVyaW5nIGEgcHJlZmV0Y2gsIHdlIGNhbiBqdXN0IGFib3J0LlxuICAgICAgICAvLyBEdXJpbmcgYSBjbGllbnQgbmF2aWdhdGlvbiwgd2UgY291bGQgdHJpZ2dlciBhIGhhcmQgcmVmcmVzaC4gQnV0IGlmXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIGluaXRpYWwgcmVuZGVyLCB3ZSBkb24ndCByZWFsbHkgaGF2ZSBhbnlcbiAgICAgICAgLy8gcmVjb3Zlcnkgb3B0aW9ucy5cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG4gICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHBhdGhuYW1lUGFydHNbcGFydEluZGV4XSlcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHBhcmFtVHlwZSBzYXRpc2ZpZXMgbmV2ZXJcbiAgICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb2VzU3RhdGljU2VnbWVudEFwcGVhckluVVJMKHNlZ21lbnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBUaGlzIGlzIG5vdCBhIHBhcmFtZXRlcml6ZWQgc2VnbWVudDsgaG93ZXZlciwgd2UgbmVlZCB0byBkZXRlcm1pbmVcbiAgLy8gd2hldGhlciBvciBub3QgdGhpcyBzZWdtZW50IGFwcGVhcnMgaW4gdGhlIFVSTC4gRm9yIGV4YW1wbGUsIHRoaXMgcm91dGVcbiAgLy8gZ3JvdXBzIGRvIG5vdCBhcHBlYXIgaW4gdGhlIFVSTCwgc28gdGhleSBzaG91bGQgYmUgc2tpcHBlZC4gQW55IG90aGVyXG4gIC8vIHNwZWNpYWwgY2FzZXMgbXVzdCBiZSBoYW5kbGVkIGhlcmUuXG4gIC8vIFRPRE86IENvbnNpZGVyIGVuY29kaW5nIHRoaXMgZGlyZWN0bHkgaW50byB0aGUgcm91dGVyIHRyZWUgaW5zdGVhZCBvZlxuICAvLyBpbmZlcnJpbmcgaXQgb24gdGhlIGNsaWVudCBiYXNlZCBvbiB0aGUgc2VnbWVudCB0eXBlLiBTb21ldGhpbmcgbGlrZVxuICAvLyBhIGBkb2VzQXBwZWFySW5VUkxgIGZsYWcgaW4gRmxpZ2h0Um91dGVyU3RhdGUuXG4gIGlmIChcbiAgICBzZWdtZW50ID09PSBST09UX1NFR01FTlRfUkVRVUVTVF9LRVkgfHxcbiAgICAvLyBGb3Igc29tZSByZWFzb24sIHRoZSBsb2FkZXIgdHJlZSBzb21ldGltZXMgaW5jbHVkZXMgZXh0cmEgX19QQUdFX19cbiAgICAvLyBcImxheW91dHNcIiB3aGVuIHBhcnQgb2YgYSBwYXJhbGxlbCByb3V0ZS4gQnV0IGl0J3Mgbm90IGEgbGVhZiBub2RlLlxuICAgIC8vIE90aGVyd2lzZSwgd2Ugd291bGRuJ3QgbmVlZCB0aGlzIHNwZWNpYWwgY2FzZSBiZWNhdXNlIHBhZ2VzIGFyZVxuICAgIC8vIGFsd2F5cyBsZWFmIG5vZGVzLlxuICAgIC8vIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGUgbG9hZGVyIHByb2R1Y2VzIHRoZXNlIGZha2UgcGFnZSBzZWdtZW50cy5cbiAgICBzZWdtZW50LnN0YXJ0c1dpdGgoUEFHRV9TRUdNRU5UX0tFWSkgfHxcbiAgICAvLyBSb3V0ZSBncm91cHMuXG4gICAgKHNlZ21lbnRbMF0gPT09ICcoJyAmJiBzZWdtZW50LmVuZHNXaXRoKCcpJykpIHx8XG4gICAgc2VnbWVudCA9PT0gREVGQVVMVF9TRUdNRU5UX0tFWSB8fFxuICAgIHNlZ21lbnQgPT09ICcvX25vdC1mb3VuZCdcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgLy8gQWxsIG90aGVyIHNlZ21lbnQgdHlwZXMgYXBwZWFyIGluIHRoZSBVUkxcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYWNoZUtleUZvckR5bmFtaWNQYXJhbShcbiAgcGFyYW1WYWx1ZTogUm91dGVQYXJhbVZhbHVlLFxuICByZW5kZXJlZFNlYXJjaDogTm9ybWFsaXplZFNlYXJjaFxuKTogc3RyaW5nIHtcbiAgLy8gVGhpcyBuZWVkcyB0byBtYXRjaCB0aGUgbG9naWMgaW4gZ2V0LWR5bmFtaWMtcGFyYW0udHMsIHVudGlsIHdlJ3JlIGFibGUgdG9cbiAgLy8gdW5pZnkgdGhlIHZhcmlvdXMgaW1wbGVtZW50YXRpb25zIHNvIHRoYXQgdGhlc2UgYXJlIGFsd2F5cyBjb21wdXRlZCBvblxuICAvLyB0aGUgY2xpZW50LlxuICBpZiAodHlwZW9mIHBhcmFtVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVE9ETzogUmVmYWN0b3Igb3IgcmVtb3ZlIHRoaXMgaGVscGVyIGZ1bmN0aW9uIHRvIGFjY2VwdCBhIHN0cmluZyByYXRoZXJcbiAgICAvLyB0aGFuIHRoZSB3aG9sZSBzZWdtZW50IHR5cGUuIEFsc28gd2UgY2FuIHByb2JhYmx5IGp1c3QgYXBwZW5kIHRoZVxuICAgIC8vIHNlYXJjaCBzdHJpbmcgaW5zdGVhZCBvZiB0dXJuaW5nIGl0IGludG8gSlNPTi5cbiAgICBjb25zdCBwYWdlU2VnbWVudFdpdGhTZWFyY2hQYXJhbXMgPSBhZGRTZWFyY2hQYXJhbXNJZlBhZ2VTZWdtZW50KFxuICAgICAgcGFyYW1WYWx1ZSxcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhuZXcgVVJMU2VhcmNoUGFyYW1zKHJlbmRlcmVkU2VhcmNoKSlcbiAgICApIGFzIHN0cmluZ1xuICAgIHJldHVybiBwYWdlU2VnbWVudFdpdGhTZWFyY2hQYXJhbXNcbiAgfSBlbHNlIGlmIChwYXJhbVZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcmFtVmFsdWUuam9pbignLycpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlcih1cmw6IFVSTCk6IFVSTCB7XG4gIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwpXG4gIHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzLnNlYXJjaFBhcmFtcy5kZWxldGUoTkVYVF9SU0NfVU5JT05fUVVFUlkpXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0NPTkZJR19PVVRQVVQgPT09ICdleHBvcnQnICYmXG4gICAgICB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycy5wYXRobmFtZS5lbmRzV2l0aCgnLnR4dCcpXG4gICAgKSB7XG4gICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSB1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVyc1xuICAgICAgY29uc3QgbGVuZ3RoID0gcGF0aG5hbWUuZW5kc1dpdGgoJy9pbmRleC50eHQnKSA/IDEwIDogNFxuICAgICAgLy8gU2xpY2Ugb2ZmIGAvaW5kZXgudHh0YCBvciBgLnR4dGAgZnJvbSB0aGUgZW5kIG9mIHRoZSBwYXRobmFtZVxuICAgICAgdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnMucGF0aG5hbWUgPSBwYXRobmFtZS5zbGljZSgwLCAtbGVuZ3RoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmFtVmFsdWVGcm9tQ2FjaGVLZXkoXG4gIHBhcmFtQ2FjaGVLZXk6IHN0cmluZyxcbiAgcGFyYW1UeXBlOiBEeW5hbWljUGFyYW1UeXBlc1Nob3J0XG4pIHtcbiAgLy8gVHVybiB0aGUgY2FjaGUga2V5IHN0cmluZyBzZW50IGJ5IHRoZSBzZXJ2ZXIgKGFzIHBhcnQgb2YgRmxpZ2h0Um91dGVyU3RhdGUpXG4gIC8vIGludG8gYSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gYHVzZVBhcmFtc2AgYW5kIGNsaWVudCBjb21wb25lbnRzLlxuICBjb25zdCBpc0NhdGNoQWxsID0gcGFyYW1UeXBlID09PSAnYycgfHwgcGFyYW1UeXBlID09PSAnb2MnXG4gIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgLy8gQ2F0Y2gtYWxsIHBhcmFtIGtleXMgYXJlIGEgY29uY2F0ZW5hdGlvbiBvZiB0aGUgcGF0aCBzZWdtZW50cy5cbiAgICAvLyBTZWUgZXF1aXZhbGVudCBsb2dpYyBpbiBgZ2V0U2VsZWN0ZWRQYXJhbXNgLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBqdXN0IHBhc3MgdGhlIGFycmF5IGRpcmVjdGx5LCByYXRoZXIgdGhhbiBjb25jYXRlbmF0ZVxuICAgIC8vIGl0IHRvIGEgc3RyaW5nIGFuZCB0aGVuIHNwbGl0IGl0IGJhY2sgdG8gYW4gYXJyYXkuIEl0IG5lZWRzIHRvIGJlIGFuXG4gICAgLy8gYXJyYXkgaW4gc29tZSBwbGFjZXMsIGxpa2Ugd2hlbiBwYXNzaW5nIGEga2V5IFJlYWN0LCBidXQgd2UgY2FuIGNvbnZlcnRcbiAgICAvLyBpdCBhdCBydW50aW1lIGluIHRob3NlIHBsYWNlcy5cbiAgICByZXR1cm4gcGFyYW1DYWNoZUtleS5zcGxpdCgnLycpXG4gIH1cbiAgcmV0dXJuIHBhcmFtQ2FjaGVLZXlcbn1cbiJdLCJuYW1lcyI6WyJkb2VzU3RhdGljU2VnbWVudEFwcGVhckluVVJMIiwiZ2V0Q2FjaGVLZXlGb3JEeW5hbWljUGFyYW0iLCJnZXRQYXJhbVZhbHVlRnJvbUNhY2hlS2V5IiwiZ2V0UmVuZGVyZWRQYXRobmFtZSIsImdldFJlbmRlcmVkU2VhcmNoIiwicGFyc2VEeW5hbWljUGFyYW1Gcm9tVVJMUGFydCIsInVybFRvVXJsV2l0aG91dEZsaWdodE1hcmtlciIsInJlc3BvbnNlIiwicmV3cml0dGVuUXVlcnkiLCJoZWFkZXJzIiwiZ2V0IiwiTkVYVF9SRVdSSVRURU5fUVVFUllfSEVBREVSIiwiVVJMIiwidXJsIiwic2VhcmNoIiwicmV3cml0dGVuUGF0aCIsIk5FWFRfUkVXUklUVEVOX1BBVEhfSEVBREVSIiwicGF0aG5hbWUiLCJwYXJhbVR5cGUiLCJwYXRobmFtZVBhcnRzIiwicGFydEluZGV4IiwibGVuZ3RoIiwic2xpY2UiLCJtYXAiLCJzIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VnbWVudCIsIlJPT1RfU0VHTUVOVF9SRVFVRVNUX0tFWSIsInN0YXJ0c1dpdGgiLCJQQUdFX1NFR01FTlRfS0VZIiwiZW5kc1dpdGgiLCJERUZBVUxUX1NFR01FTlRfS0VZIiwicGFyYW1WYWx1ZSIsInJlbmRlcmVkU2VhcmNoIiwicGFnZVNlZ21lbnRXaXRoU2VhcmNoUGFyYW1zIiwiYWRkU2VhcmNoUGFyYW1zSWZQYWdlU2VnbWVudCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiVVJMU2VhcmNoUGFyYW1zIiwiam9pbiIsInVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIiwiTkVYVF9SU0NfVU5JT05fUVVFUlkiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJfX05FWFRfQ09ORklHX09VVFBVVCIsInBhcmFtQ2FjaGVLZXkiLCJpc0NhdGNoQWxsIiwic3BsaXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/route-params.js\n"));

/***/ })

});